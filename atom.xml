<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>simyy</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://simyy.cn/"/>
  <updated>2019-12-17T02:25:10.605Z</updated>
  <id>http://simyy.cn/</id>
  
  <author>
    <name>simyy</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Reactor &amp; Proactor</title>
    <link href="http://simyy.cn/2019/12/16/re-pro-actor/"/>
    <id>http://simyy.cn/2019/12/16/re-pro-actor/</id>
    <published>2019-12-16T14:52:17.000Z</published>
    <updated>2019-12-17T02:25:10.605Z</updated>
    
    <content type="html"><![CDATA[<p>总结常见的两种网络模型设计模式Reactor和Proactor。</p><a id="more"></a><h3 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h3><p>在网络模型设计中，有两个的高性能模型：<code>Reactor</code>和<code>Proactor</code>。</p><p>这里会涉及到<code>同步/异步</code>、<code>阻塞/非阻塞</code>两个知识点。</p><p><strong>同步/异步</strong>：应用程序和系统内核之间交互（通信）方式，主动监听还是被动通知。</p><p><code>select/poll/epoll</code>都需要用户程序不断轮询检查IO操作是否就绪，所以它们都属于<code>同步IO</code>。</p><p><code>Boost.Asio</code>通过对<code>epoll</code>的二次封装实现了<code>异步IO</code>，WIN下的<code>IOCP</code>同样也属于<code>异步IO</code>；</p><p><strong>阻塞/非阻塞</strong>：用户进程执行IO操作后如何等待调用结果。</p><p>进程挂起等待属于<code>阻塞</code>，进程直接返回等待下次重试属于<code>非阻塞</code>。</p><h3 id="Reactor"><a href="#Reactor" class="headerlink" title="Reactor"></a>Reactor</h3><p><code>Reactor</code>属于<code>同步非阻塞</code>模型。</p><p><strong>同步</strong>：同步监听，需要用户端主动监听IO就绪状态。</p><p><strong>非阻塞</strong>：用户进程执行IO操作后不会导致用户进程的挂起，会通过重试的方式来尝试获取执行结果。</p><p>Reactor模型中，主要分为<code>Acceptor</code>、<code>Reactor</code>、<code>Handler</code>三个主要组件。</p><ul><li><strong>Acceptor</strong>：获取客户端链接，绑定客户端注册事件。</li><li><strong>Reactor</strong>：监控触发的事件，并分发给对应的事件处理器。</li><li><strong>Handler</strong>：处理对应的事件请求，例如，读写处理器、加解密处理器、命令执行处理器等。</li></ul><p><code>Reactor组件</code>是模型中的关键组件（也是和<code>Proactor</code>的不同之处），包括以下两部分：</p><ul><li>通过不断轮询<code>select/epoll</code>来监听准备就绪的事件；</li><li>通过<code>Dispatch</code>来分发事件到对应的时间处理器。</li></ul><blockquote><p><code>Reactor</code>中的读和写是由<code>应用程序</code>来决定何时操作的。</p></blockquote><p>Reactor模型的实现方式：<code>单Reactor单处理器</code>、<code>单Reactor多处理器</code>、<code>多Reactor多处理器</code>。</p><h5 id="单Reactor单处理器"><a href="#单Reactor单处理器" class="headerlink" title="单Reactor单处理器"></a>单Reactor单处理器</h5><p><code>单Reactor单处理器</code>也就是简单的单线程模型。</p><p><img src="/images/RE_PRO_ACTOR_1.png" alt=""></p><h5 id="单Reactor多处理器"><a href="#单Reactor多处理器" class="headerlink" title="单Reactor多处理器"></a>单Reactor多处理器</h5><p><code>单Reactor多处理器</code>是通过处理器多线程化来实现并发能力，但是需要考虑多处理器的并发情况下<code>资源竞争</code>的问题。</p><p><img src="/images/RE_PRO_ACTOR_2.png" alt=""></p><h5 id="多Reactor多处理器"><a href="#多Reactor多处理器" class="headerlink" title="多Reactor多处理器"></a>多Reactor多处理器</h5><p><code>多Reactor多处理器</code>是在<code>单Reactor多处理器</code>的基础之上，分离了<code>Acceptor</code>的能力，并且增加多个<code>子Reactor</code>来实现分而治之的方法。</p><p><img src="/images/RE_PRO_ACTOR_3.png" alt=""></p><h3 id="Proactor"><a href="#Proactor" class="headerlink" title="Proactor"></a>Proactor</h3><p><code>Reactor</code>属于<code>异步非阻塞</code>模型。</p><p><strong>异步</strong>：异步回调，系统自动回调用户程序通知IO就绪状态。</p><p><strong>非阻塞</strong>：同<code>Reactor</code>。</p><p><code>Proactor</code>模型中，主要分为<code>Proactor</code>、<code>Proactor Initiator</code>、<code>Handler</code>、<code>Asynchronous Operation Processor</code>四个主要组件。</p><ul><li><strong>Asynchronous Operation Processor</strong>：异步操作处理器，操作系统提供；</li><li><strong>Proactor Initiator</strong>：事件注册器，用于注册事件以及对应的事件处理器；</li><li><strong>Proactor</strong>：用于监听触发的事件，并分发给不同的事件处理器处理；</li><li><strong>Handler</strong>：同<code>Reactor</code>。</li></ul><p><img src="/images/RE_PRO_ACTOR_4.png" alt=""></p><blockquote><p>在<code>Proactor</code>中，<code>数据的读写</code>都是由<code>系统内核</code>来实现的，<code>应用程序</code>只是从<code>缓存区</code>上进行读写。</p></blockquote><p>Proactor模型的关键在于系统提供的<code>Asynchronous Operation Processor</code>异步操作处理器。</p><blockquote><p>由于基于<code>缓存区的</code>交互方式，<code>Proactor</code>中的读和写是<code>操作系统</code>来决定何时操作的。</p></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>Reactor</code>和<code>Proactor</code>均为非阻塞I/O模型。</p><p><code>Reactor</code>是同步的（主动查询），<code>Proactor</code>是异步的（被动通知）。</p><p><code>Proactor</code>接收到的是IO操作已完成事件（缓存区），<code>Reactor</code>接收到的是IO操作就绪事件。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://mp.weixin.qq.com/s?__biz=MzUyNzgyNzAwNg==&amp;mid=2247483941&amp;idx=1&amp;sn=97628f4d69d8607badf39bfeb7557457&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">彻底搞懂Java的网络IO</a><br><a href="https://zhuanlan.zhihu.com/p/35065251" target="_blank" rel="noopener">Linux 的 IO 通信 以及 Reactor 线程模型浅析</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总结常见的两种网络模型设计模式Reactor和Proactor。&lt;/p&gt;
    
    </summary>
    
      <category term="架构" scheme="http://simyy.cn/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="网络" scheme="http://simyy.cn/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="架构" scheme="http://simyy.cn/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="中间件" scheme="http://simyy.cn/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
      <category term="网络模型" scheme="http://simyy.cn/tags/%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>分布式任务调度</title>
    <link href="http://simyy.cn/2019/12/08/distributed-job-dispatch/"/>
    <id>http://simyy.cn/2019/12/08/distributed-job-dispatch/</id>
    <published>2019-12-08T04:19:34.000Z</published>
    <updated>2019-12-17T02:24:47.671Z</updated>
    
    <content type="html"><![CDATA[<p>任务调度解决定时触发的问题，分布式解决单点触发的问题。</p><a id="more"></a><h3 id="任务调度"><a href="#任务调度" class="headerlink" title="任务调度"></a>任务调度</h3><blockquote><p><code>任务调度</code>来<code>触发</code>那些无法自动触发的任务。</p></blockquote><p>任务调度中最重要的三个基础组件：<code>任务</code>、<code>触发器</code>和<code>执行器</code>。</p><p><strong>任务</strong>：保存待处理的任务，包括任务的触发的关键信息（例如，目标地址、调用方式、触发参数）。</p><p><strong>触发器</strong>：保存待处理任务的执行时间，包括定时触发、周期触发。</p><p><strong>执行器</strong>：任务触发的媒介，任务达到触发状态后都交于执行器来触发任务的执行。</p><h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p>任务调度的组件大体依赖关系如下图，</p><p><img src="/images/distributed_job_dispatch_1.png" alt="组件依赖关系"></p><p><strong>任务的创建和触发流程</strong>：</p><ul><li>创建<code>Job</code>，并指定具体的任务类型（<code>RpcJob</code>或<code>HttpJob</code>）；</li><li>创建<code>Trigger</code>作为任务的触发器，指定任务触发方式（<code>TimeTrigger</code>或<code>CrondTrigger</code>）；</li><li>计算<code>Trigger</code>下一次触发时间；</li><li>关联<code>Job</code>和<code>Trigger</code>，用于组装<code>JobContext</code>；</li><li>扫描<code>最近一段时间内</code>待触发的<code>Trigger</code>，并组装对应的<code>JobContext</code>；</li><li><code>Executor</code>拉取待触发的<code>JobContext</code>，按<code>Trigger</code>指定的执行时间来执行<code>Job</code>。</li></ul><h4 id="任务状态"><a href="#任务状态" class="headerlink" title="任务状态"></a>任务状态</h4><p>任务调度系统的状态可划分为：</p><p><img src="/images/distributed_job_dispatch_2.png" alt="任务状态流转图"></p><h3 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h3><p>对于单机任务调度系统来说，存在问题包括：<code>单点故障</code>、<code>任务堆积</code>。</p><blockquote><p>分布式系统通过把任务分配给到不同的调度节点来解决<code>单点</code>和<code>任务堆积</code>的问题。</p></blockquote><p>常见的分布式解决方案：</p><ul><li><code>Quartz</code>：基于数据库实现作业的高可用，存在代码入侵。</li><li><code>Elastic Job</code>：采用zookeeper实现分布式协调，实现任务高可用以及分片。</li></ul><h5 id="并行调度"><a href="#并行调度" class="headerlink" title="并行调度"></a>并行调度</h5><blockquote><p><code>并行调度</code>：将任务分配到多个实例节点，使得多个应用实例能并行执行任务，以提升调度系统的执行效率。</p></blockquote><p>从单实例到多实例，<code>任务的分配</code>是<code>并行调度</code>的关键问题，常见的分配方式包括：</p><p><code>哈希分配</code>：计算任务的哈希值，分配到固定的实例节点，需要处理集群扩容和缩容的问题。</p><p><code>负载优先分配</code>：需要动态调整各个实例节点的负载压力，难点在于机器负载的定义与计算。</p><p><code>平均分配</code>：任务轮询分配到各个集群实例节点。</p><p><code>抢占式分配</code>：实现相对简单，不需要集群的管理节点来实现，只需要控制好并发锁的问题。</p><h5 id="高可用性"><a href="#高可用性" class="headerlink" title="高可用性"></a>高可用性</h5><blockquote><p><code>高可用性</code>：当执行任务的应用实例崩溃后，其他应用实例可以继续执行该任务。</p><p>也就是说，如何保证分布式中节点异常情况下，所有任务的正常执行。</p></blockquote><p><code>异常节点的任务迁移</code>是关<code>高可用</code>的键问题。</p><p>迁移必然带来任务的<code>动态分配</code>问题（与扩容类似），具体方法与使用的<code>任务分配</code>方式相关。</p><ul><li><code>哈希分配</code>：采用<code>一致性哈希算法</code>来解决节点异常导致的大量的任务迁移问题；</li><li><code>负载优先分配</code>：把节点异常的任务迁移到负载最低的节点来处理；</li><li><code>平均分配</code>：把节点异常的任务平均分配到集群其他节点上。</li><li><code>抢占式分配</code>：把节点异常的任务丢回任务池中等待其他节点来抢占。</li></ul><p>其中，负载优先分配方式下需要实时监控每个实例节点的负载能力，并需要实现动态调整实例的负载，实现任务的高效执行。</p><blockquote><p>集群实例节点的状态如何监控？</p></blockquote><p>利用<code>Zookeeper</code>和<code>Etcd</code>来实现应用实例状态的监控，当发生异常情况时及时迁移异常节点的待处理任务。</p><p>一般情况下，集群中会有一台实例节点充当管理者，利用<code>Zookeeper</code>和<code>Etcd</code>的分布式协调能力来选择集群的管理者，并监控整个集群的状态。</p><blockquote><p><code>Zookeeper</code>和<code>Etcd</code>分别实现了<code>zab</code>和<code>raft</code>一致性算法，可以辅助其他系统实现集群的状态管理。</p></blockquote><hr><p>下图代表了一致性hash来实现集群任务的分配及异常节点的任务迁移。</p><p><img src="/images/distributed_job_dispatch_3.png" alt="一致性哈希下的任务分配和异常迁移"></p><hr><h5 id="弹性扩容"><a href="#弹性扩容" class="headerlink" title="弹性扩容"></a>弹性扩容</h5><blockquote><p><code>动态扩容</code>：当集群无法满足大量任务的并发执行时，需要动态增加集群实例数量，同时保证历史任务的正常触发。</p></blockquote><p>上面有提到过，<code>一致性哈希</code>来实现任务的哈希分配扩容情况下造成的节点任务迁移问题。</p><p>此外，在扩容过程中也需要考虑扩容的任务迁移对任务的准时执行是否存在的影响，如果存在影响的话，是否可以考虑把可能会受到影响的任务留在当前实例节点。</p><h5 id="失败处理"><a href="#失败处理" class="headerlink" title="失败处理"></a>失败处理</h5><blockquote><p>只要是程序就会出现异常，任务调度也不例外，异常处理也是重要的一部分。</p></blockquote><p>失败一般包括以下几种情况：</p><ul><li>集群实例节点down机</li><li>任务调用超时</li><li>任务无法调用到目标应用（网络 or 目标应用down机）</li></ul><p>任务调度系统需要设置合理的<code>任务重试机制</code>，包括<code>重试次数</code>、<code>超时时间</code>等。</p><p>此外，对于异常任务，需要配置对应的<code>报警策略</code>来通知相关业务人员及时处理异常问题。</p><h5 id="任务优先级"><a href="#任务优先级" class="headerlink" title="任务优先级"></a>任务优先级</h5><blockquote><p>集群的并行处理能力是有限的，在满足需求的条件下，允许配置任务的优先级。</p></blockquote><p>任务调度系统中，通过设置<code>不同的优先级的任务处理器</code>来实现任务的优先处理。</p><p><code>带有优先级的任务处理器</code>可以由预分配多个线程池来处理，优先级的高低决定了任务处理器线程池中并发执行线程的数量，高优先级的线程池配置更多的线程，低优先级的线程池配置更少的线程，从而实现高低优先级任务的隔离处理。</p><h5 id="任务分片"><a href="#任务分片" class="headerlink" title="任务分片"></a>任务分片</h5><blockquote><p><code>任务分片</code>：任务按照参数可以拆分成多个子任务，子任务下发到集群的不同实例节点并发执行。</p></blockquote><p>任务分片的关键问题：<code>任务的拆分</code>。</p><p>可以分片的任务一定是可以<code>逻辑拆分</code>的，拆分之后的子任务没有任何关联关系。</p><p>例如，为每一个用户统计他最近一天的消费信息，可以按照用户id的取模方式来实现任务的拆分：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. id % 5 = 任务拆分为5个子任务</span><br><span class="line">2. 5个子任务分配分配到集群的5个节点来并发执行</span><br></pre></td></tr></table></figure></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>任务调度的目的是准时触发任务，分布式的目的是解决单点问题，通过zookeeper和etcd等组件来实现集群的状态管理。</p><p>为了试下准时触发和优先级触发，实例节点需要配置对应的线程池来实现高低优先级任务的隔离。</p><h5 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h5><p><a href="https://zhuanlan.zhihu.com/p/26493355" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/26493355</a><br><a href="https://juejin.im/post/5c55ac0bf265da2da771a216" target="_blank" rel="noopener">https://juejin.im/post/5c55ac0bf265da2da771a216</a><br><a href="https://www.cnblogs.com/davidwang456/p/9057839.html" target="_blank" rel="noopener">https://www.cnblogs.com/davidwang456/p/9057839.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;任务调度解决定时触发的问题，分布式解决单点触发的问题。&lt;/p&gt;
    
    </summary>
    
      <category term="架构" scheme="http://simyy.cn/categories/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="中间件" scheme="http://simyy.cn/categories/%E6%9E%B6%E6%9E%84/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
      <category term="分布式" scheme="http://simyy.cn/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="架构" scheme="http://simyy.cn/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="任务调度" scheme="http://simyy.cn/tags/%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/"/>
    
      <category term="中间件" scheme="http://simyy.cn/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>Java 虚拟机</title>
    <link href="http://simyy.cn/2019/11/26/jvm/"/>
    <id>http://simyy.cn/2019/11/26/jvm/</id>
    <published>2019-11-26T11:36:26.000Z</published>
    <updated>2019-12-17T02:30:47.105Z</updated>
    
    <content type="html"><![CDATA[<p><code>Java虚拟机（Java Virtual Machine）</code>是一种能够运行<code>Java字节码</code>的虚拟机。</p><a id="more"></a><p>实际上只要编译文件符合JVM对加载编译文件格式要求，任何语言都可以由JVM编译运行，例如<code>JPython</code>、<code>Scala</code>、<code>JRupy</code>。</p><h3 id="总体结构"><a href="#总体结构" class="headerlink" title="总体结构"></a>总体结构</h3><p><code>Java虚拟机</code>主要被划分为四部分： </p><ul><li><code>类加载器（ClassLoader）</code></li><li><code>运行时数据区（Runtime Data Area）</code></li><li><code>执行引擎（Execution Engine）</code></li><li><code>本地库接口（Native Interface）</code></li></ul><p><img src="/images/JVM_1.jpg" alt=""></p><blockquote><p><code>Java</code>是如何<code>跨平台</code>运行的？</p><p><code>Java虚拟机</code>在这里充当了<code>桥梁</code>的作用，通过屏蔽了具体操作系统的API(不同平台JVM实现有所不同)，只要生成<code>Java字节码</code>就可以在多平台不加修改的运行。</p></blockquote><h4 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h4><p><code>类加载器（ClassLoader）</code>负责把class加载到JVM。</p><p><img src="/images/JVM_2.jpg" alt=""></p><p>Java文件再被JVM处理之前，需要编译成<code>Java字节码</code>格式的class文件，然后通过类加载器加载到JVM。</p><h4 id="执行引擎"><a href="#执行引擎" class="headerlink" title="执行引擎"></a>执行引擎</h4><p><code>Java虚拟机</code>通过模拟操作系统实现了一套虚拟架构，包括<code>处理器</code>、<code>堆栈</code>、<code>寄存器</code>等。</p><p><code>执行引擎（Execution Engine）</code>就是模拟操作系统执行命令的原理，以指令为单位读取<code>Java字节码</code>。</p><blockquote><p><code>Java字节码</code>指令都由<code>操作码</code>和<code>操作数</code>组成。</p></blockquote><p><code>Java字节码</code>是实现跨平台的关键，所以在不同平台并不能直接执行，这就需要<code>不同平台实现各自的执行引擎来</code>生成各自可执行机器语言。</p><hr><p>在<code>Java虚拟机</code>中，存在三种执行方式：</p><p><strong>解释器模式</strong>：读取字节码解释并且执行字节码指令，由于省去编译时间，应用启动快，但执行效率差，<code>Python</code>默认就是采用此方法。</p><p><strong>JIT编译模式</strong>：通过把字节码编译成机器码达到提供执行效率的方法，由于在程序运行前需要编译，导致程序启动慢，但是执行效率高。</p><blockquote><p><code>JIT（Just In Time）即时编译</code>：在程序运行中对<code>热点代码</code>进行即时编译成机器码，从而提高程序运行效率。<code>热点代码（HotSpotCode）</code>可划分为：<code>多次被调用的方法</code>和<code>多次被执行的循环体</code>。</p></blockquote><p><strong>混合模式</strong>：上面两种模式的混合，在适合的时候选择合适的模式，从而解决两种模式存在的问题。</p><p><img src="/images/JVM_3.jpg" alt=""></p><blockquote><p><code>Java虚拟机</code>到底采用那种模式呢？</p><p>实际上，不同的JVM采用了不同的方式，<code>HotSpotVM</code>才用了混合模式来执行引擎，而<code>JRockitVM</code>才用了<code>JIT编译模式</code>(并没有实现解析器)。<br>如果对解释和编译感兴趣的话，可以戳一下 <a href="https://www.zhihu.com/question/37389356" target="_blank" rel="noopener">为什么 JVM 不用 JIT 全程编译？</a></p></blockquote><h4 id="本地库接口"><a href="#本地库接口" class="headerlink" title="本地库接口"></a>本地库接口</h4><p><code>本地接口</code>的作用是融合不同的编程语言为<code>Java虚拟机</code>所用，其一般被称为JNI（Java Native Interface）。</p><blockquote><p><strong>wikipedia</strong>： <code>JNI</code>是一种编程框架，使得<code>Java虚拟机</code>中的Java程序可以<code>调用本地应用/或库</code>，也可以<code>被其他程序调用</code>。</p></blockquote><h4 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h4><p><code>运行时数据区</code>是<code>Java虚拟机</code>中最重要的组成部分，也常被称为<code>JVM内存</code>。</p><p><img src="/images/JVM_4.jpg" alt=""></p><p><code>JVM内存</code>可分为以下<code>五个部分</code>：</p><p><strong>方法区</strong>：<code>线程共享</code>，主要用于存储<code>加载的类信息</code>、<code>常量池</code>、<code>静态变量</code>、<code>JIT编译的代码</code>等。</p><hr><blockquote><p>实际上不同JVM实现上也有所不同，</p><ul><li><code>JDK1.7</code>中，已经把放在永久代的<code>字符串常量池</code>移到<code>堆</code>中。</li><li><code>JDK1.8</code>中，已经把放在永久代的<code>静态变量</code>移到<code>堆</code>中。</li><li><code>JDK1.8</code>撤销<code>永久代(Perm)</code>，引入<code>元空间(Metaspace)</code>（存放在本地内存，不在受JVM内存限制）。</li><li>其他VM都不存在永久代，例如，<code>JRockitVM</code>就没有<code>永久代</code>。</li></ul></blockquote><blockquote><p><code>JDK1.8</code>中JVM进程占用的内存会多出来1G？</p></blockquote><p>由于<code>JDK1.8</code>默认开启了<code>-XX:+UseCompressedClassPointers</code>，<code>CompressedClassSpace</code>默认值为<code>1G</code>，因此会发现JVM进程占用的内存会多出来1G。</p><hr><p><strong>堆</strong>：<code>线程共享</code>，用于存储对象，是<code>GC</code>的主要区域。</p><p>与<code>C/C++</code>不同之处就在于此，<code>Java虚拟机</code>为开发者省去了内存管理的麻烦，也降低了软件开发和维护的难度。</p><p>内存管理一般会涉及到<code>内存释放的时机</code>、<code>内存碎片</code>、<code>并发清理内存垃圾的性能</code>等问题。</p><p>具体GC算法可以戳 <a href="http://simyy.cn/2017/01/25/gc/">垃圾回收GC</a></p><hr><p><strong>虚拟机栈</strong>：<code>线程独占</code>，用于存储<code>局部变量表、操作栈、动态链接、方法返回地址</code>等信息。</p><blockquote><p><code>局部变量表</code>：是用于存放<code>方法参数</code>和方法内部定义的<code>局部变量</code>，在<code>编译期确定</code>最大容量。<br><code>操作栈</code>：执行引擎就是基于<code>操作栈</code>来工作的，在<code>编译期确定</code>最大容量。<br><code>动态链接</code>：运行期加载的<code>常量池</code>中关联当前方法的<code>符号引用</code>。</p></blockquote><hr><p><strong>本地方法栈</strong>：<code>线程独占</code>，用于执行<code>本地方法（Native Method）</code>。</p><hr><p><strong>程序计数器</strong>：<code>线程独占</code>，用于保存当前线程执行的内存地址，用于JVM程序多线程切换后恢复执行环境。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>Java虚拟机</code>不仅提供了<code>平台无关</code>运行环境，并且接管了<code>内存管理</code>机制，从而使得<code>Java</code>开发、维护变得简单和流行。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;Java虚拟机（Java Virtual Machine）&lt;/code&gt;是一种能够运行&lt;code&gt;Java字节码&lt;/code&gt;的虚拟机。&lt;/p&gt;
    
    </summary>
    
      <category term="编程语言" scheme="http://simyy.cn/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="Java" scheme="http://simyy.cn/tags/Java/"/>
    
      <category term="JVM" scheme="http://simyy.cn/tags/JVM/"/>
    
      <category term="编程语言" scheme="http://simyy.cn/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>拓扑排序</title>
    <link href="http://simyy.cn/2019/11/10/topological-sort/"/>
    <id>http://simyy.cn/2019/11/10/topological-sort/</id>
    <published>2019-11-10T10:20:35.000Z</published>
    <updated>2019-12-17T02:24:46.038Z</updated>
    
    <content type="html"><![CDATA[<p>简单介绍下图及拓扑排序。</p><a id="more"></a><h3 id="图"><a href="#图" class="headerlink" title="图"></a>图</h3><p>图（Graph）是由<code>顶点的有穷非空集合</code>和顶点之间的<code>边的集合</code>组合。</p><blockquote><p>一般可以用<code>G(V,E)</code>来标识一个<code>图</code>，其中，<code>V</code>表示图G的<code>顶点集合</code>，<code>E</code>表示图G的<code>边集合</code>。</p></blockquote><p><strong>无向图</strong>：图中任意两个顶点之间的边都是<code>无向边</code>（顶点之间的边没有方向，则称该条边为无向边）。</p><p><img src="/images/topological_sort_01.png?200x" alt="无向图"></p><p><strong>连通图</strong>：所有顶点之间都是连通的无向图（顶点之间的连通允许跨多条边的路径）。</p><p><strong>有向图</strong>：图中任意两个顶点之间的边都是<code>有向边</code>（顶点之间的边有方向，则称该条边为有向边）。</p><p><img src="/images/topological_sort_02.png" alt="有向图"></p><p><strong>入度</strong>：有向图中以顶点为<code>终点</code>的边的个数。</p><p><strong>出度</strong>：有向图中以顶点为<code>起点</code>的边的个数。</p><h3 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><p><code>邻接矩阵（Adjaceny Matrix）</code>是图的存储方式，由<code>一维数组存储图的顶点集合</code>和<code>二维数据存储图的边集合</code>组成。</p><p>假设图G存在<code>n个顶点</code>，则邻接矩阵可以表示为一个<code>n * n</code>的矩阵matrix，<code>matix[i][j]</code>代表<code>顶点i</code>和<code>顶点j</code>之间的边。</p><p><img src="/images/topological_sort_03.png" alt="无向图邻接矩阵"></p><p><img src="/images/topological_sort_04.png" alt="有向图邻接矩阵"></p><h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><p>在图论中，由一个有向无环图的顶点组成的序列，当且仅当满足下列条件时，称为该图的一个拓扑排序（Topological Sort）</p><ul><li>每个顶点出现且只出现一次；</li><li>若A在序列中排在B的前面，则在图中不存在从B到A的路径。</li></ul><p>在拓扑排序中实现方式有两种：<code>Kahn算法</code>和<code>DFS深度遍历算法</code>，算法的时间复杂度均为<code>O(N+E)</code>。</p><blockquote><p>由于遍历存在随机性，所以拓扑排序的结果不一定唯一。</p></blockquote><h4 id="Kahn算法"><a href="#Kahn算法" class="headerlink" title="Kahn算法"></a>Kahn算法</h4><blockquote><p>以入度（或出度）为零的顶点作为遍历的开始，不断排除入度为零的顶点的所有边，不断重复此过程。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">L ← 包含已排序的元素的空列表</span><br><span class="line">S ← 没有入边的顶点（入度为零的顶点）的集合</span><br><span class="line">G ← 统计所有顶点的出边顶点集合（记录顶点的下级顶点）</span><br><span class="line"></span><br><span class="line">while S 非空时：</span><br><span class="line">    从S取出顶点n</span><br><span class="line">    将点n从S移走</span><br><span class="line">    将n加到L尾</span><br><span class="line">    从G中获取顶点N的所有出边顶点集合T</span><br><span class="line">    for 顶点t in 遍历顶点集合T：</span><br><span class="line">        顶点t的入度减一</span><br><span class="line">        if 顶点t的入度为零：</span><br><span class="line">            把顶点t加入S集合</span><br><span class="line">            顶点t的入度减一（此时入度=-1，不会再处理）</span><br><span class="line"></span><br><span class="line">return L</span><br></pre></td></tr></table></figure><p>Kahn算法可以分为<code>无前趋的的顶点优先拓扑排序</code>和<code>无后继的的顶点优先拓扑排序</code>，区别在于使用<code>入度为零</code>还是<code>出度为零</code>的边作为起点。</p><h4 id="DFS深度遍历算法"><a href="#DFS深度遍历算法" class="headerlink" title="DFS深度遍历算法"></a>DFS深度遍历算法</h4><blockquote><p>DFS同样使用以入度为零的顶点作为遍历的开始，通过记录节点的访问状态不断遍历前置顶点。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">L ← 包含已排序的元素的空列表</span><br><span class="line">G ← 统计所有顶点的入边顶点集合（记录顶点的前置条件）</span><br><span class="line">S ← 没有进入边的节点（入度为零的节点）的集合</span><br><span class="line">V ← 所有顶点的访问记录（初始化为False）</span><br><span class="line"></span><br><span class="line">for n in S:</span><br><span class="line">    dfs(n)</span><br><span class="line">    </span><br><span class="line">function dfs(n)</span><br><span class="line">    if 已经访问过 n in V:</span><br><span class="line">        return</span><br><span class="line">    记录n的访问状态 V[n] = True</span><br><span class="line">    从G中找到顶点所有的出边集合T</span><br><span class="line">    for t in 出边集合T：</span><br><span class="line">        dfs(t)</span><br><span class="line">    将n加到L尾</span><br><span class="line">   </span><br><span class="line">return L</span><br></pre></td></tr></table></figure><p>在算法中，集合V是用来记录节点的访问记录，从而实现环的判断（如果已经访问的节点再次访问则一定存在环）。</p><h4 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h4><blockquote><p>在碰到该类问题，一般需要注意几点：</p><ul><li>是否存在环（循环依赖）；</li><li>顶点的入度和出度，不存在环的情况下，至少存在一个入度为0和一个出度为0的顶点；</li><li>遍历的起点一定是入度或出度为零的顶点；</li><li>入度和出度计算出的排序不同；</li><li>对于kahn算法，如果同时出现多个入度或出度为零的顶点则拓扑排序结果不唯一。</li></ul></blockquote><p> 在某校的选课系统中，存在这样的规则：</p><ul><li>每门课可能有若干门先修课，如果要修读某一门课，则必须要先修读此课程所要求的先修课后才能修读 （图的有向边）。</li><li>假设一个学生同时只能修读一门课程，那么，被选课系统允许的他修完他需要所有课程的顺序是一个拓扑序。</li></ul><p><a href="https://leetcode.com/problems/course-schedule/" target="_blank" rel="noopener">course-schedule</a><br><a href="https://leetcode.com/problems/course-schedule-ii/" target="_blank" rel="noopener">course-schedule-ii</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单介绍下图及拓扑排序。&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://simyy.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="排序" scheme="http://simyy.cn/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="算法" scheme="http://simyy.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Java 堆外内存</title>
    <link href="http://simyy.cn/2019/10/19/java-direct-memory/"/>
    <id>http://simyy.cn/2019/10/19/java-direct-memory/</id>
    <published>2019-10-19T13:26:37.000Z</published>
    <updated>2019-12-17T02:30:43.536Z</updated>
    
    <content type="html"><![CDATA[<p><code>堆外内存</code>是相对于堆内内存的一个概念。</p><a id="more"></a><h3 id="堆内内存"><a href="#堆内内存" class="headerlink" title="堆内内存"></a>堆内内存</h3><p><code>Java虚拟机</code>中运行时数据区中<code>堆</code>的内存，用于存储<code>Java实例对象</code>。</p><p><code>堆内内存</code>是受<code>Java虚拟机</code>的管控的，<code>内存的分配和释放</code>都是基于<code>Java虚拟机</code>的内存管理机制。</p><p>常用的垃圾回收方式：<code>分代回收</code>。</p><p>常用的垃圾回收算法：<code>CMS</code>、<code>G1</code>.</p><h3 id="堆外内存"><a href="#堆外内存" class="headerlink" title="堆外内存"></a>堆外内存</h3><p><code>堆外内存</code>就是把内存对象分配在<code>Java虚拟机的堆以外的内存</code>，直接使用系统内存，不受虚拟机内存管理的控制。</p><p><strong>优势</strong>：</p><ul><li><code>提高垃圾回收速度</code>：垃圾回收不会处理堆外内存；</li><li><code>加快了复制的速度</code>，与直接内存的复制相比，堆内数据同样需要复制到直接内存（堆外内存 -&gt; 堆外内存）。</li></ul><p><strong>缺点</strong></p><ul><li><code>堆外内存难以控制</code>：由于堆外内存不受虚拟机控制，内存的管理是开发者决定的，如果出现内存泄露不好排查；</li><li><code>对象存储效率低（序列化问题）</code>：对外内存要求必须以字节数组方式存储，因此对象必须在存储过程中进行序列化/反序列化操作，效率较低。</li></ul><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ul><li>生命周期较长的对象，例如，应用预加载的常驻内存的数据；</li><li>直接的文件拷贝或IO操作，例如，NIO框架中使用方式；</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;堆外内存&lt;/code&gt;是相对于堆内内存的一个概念。&lt;/p&gt;
    
    </summary>
    
      <category term="编程语言" scheme="http://simyy.cn/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="Java" scheme="http://simyy.cn/tags/Java/"/>
    
      <category term="编程语言" scheme="http://simyy.cn/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>计算机内存架构 &amp; JMM</title>
    <link href="http://simyy.cn/2019/09/02/memory-and-jmm/"/>
    <id>http://simyy.cn/2019/09/02/memory-and-jmm/</id>
    <published>2019-09-02T14:26:24.000Z</published>
    <updated>2019-12-17T02:30:49.657Z</updated>
    
    <content type="html"><![CDATA[<p>总结下计算机内存架构的基本原理以及JMM的不同之处。</p><a id="more"></a><h4 id="内存架构"><a href="#内存架构" class="headerlink" title="内存架构"></a>内存架构</h4><p><img src="/images/memory_and_jmm_1.jpg" alt="内存架构"></p><p>现代内存架构如上图所示。</p><blockquote><p><code>高速缓存</code>存在的意义？</p><p>计算机的<code>存储设备</code>与<code>处理器</code>的运算速度之间有着几个数量级的差距。</p></blockquote><p>由于处理器和内存之间的性能差距，当代所有计算机系统都加入了一层<code>高速缓存</code>来间接缓冲数据（可以理解为业务中使用的本地缓存、分布式缓存等）。</p><p><strong>访问速度比较</strong>：<code>寄存器</code> &gt; <code>高速缓存</code> &gt; <code>主内存</code>，有些计算机架构中存在多级缓存（例如，Linux多级缓存）。</p><h5 id="缓存一致性"><a href="#缓存一致性" class="headerlink" title="缓存一致性"></a>缓存一致性</h5><p><code>高速缓存</code>类似一种代理模式，在CPU和主内存质之间构建一条高速公路，但也会造成缓存一直性问题。</p><blockquote><p><code>缓存一致性问题</code>：当多个处理器同时共享同一块主内存时，将可能导致各自的高速缓存数据不一致的情况。</p></blockquote><p>为了解决这个问题，提出了<code>缓存一致性协议</code>，常见的协议包括MSI、MESI等。</p><h5 id="指令重排"><a href="#指令重排" class="headerlink" title="指令重排"></a>指令重排</h5><p>即使存在高速缓存也不能把CPU的性能充分利用，因此提出了<code>指令重排</code>。</p><blockquote><p><code>指令重排</code>：处理器会对输入的代码进行乱序优化，在保证结果不变的情况下，优化指令排序，从而实现CPU的充分利用。</p></blockquote><h4 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h4><p><code>JMM</code>的全程是<code>Java内存模型(Java Memory Model)</code>。</p><p><img src="/images/memory_and_jmm_2.jpg" alt="映射关系"></p><p><code>JMM</code>与硬件内存架构是不同的，区别在于：<strong>硬件内存架构未区分线程栈和堆</strong>。</p><p><code>JMM</code>中<code>工作内存（Working Memory）</code>是一个抽象概念，涵盖了CPU寄存器、高速缓存等。</p><p><img src="/images/memory_and_jmm_3.jpg" alt="Java内存模型"></p><h5 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h5><blockquote><p><code>可见性</code>：基于工作内存，在多线程的情况下，任意线程修改了共享变量的值，其他线程能够同步感知到变量的变化。</p></blockquote><p>Java提供了<code>volatile</code>来解决内存可见性问题。</p><p>当操作发生在<code>volatile</code>变量时，有如下规则：</p><ul><li><strong>写</strong>：<code>JMM</code>会把该线程对应的工作内存中的共享变量值刷新到主内存;</li><li><strong>读</strong>：<code>JMM</code>会把该线程对应的工作内存置为无效并从主内存中读取共享变量。</li></ul><blockquote><p>读写<code>volatile</code>变量会导致变量从主内存读写，这远比从CPU缓存读写更加耗时。</p></blockquote><h5 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h5><blockquote><p><code>内存屏障</code>：不仅可以保证屏障前后的指令顺序，也可以保证内存数据的可见性。</p></blockquote><p>为了保证内存可见性，Java编译器在生成指令序列的适当位置会插入<code>内存屏障指令</code>来禁止特定类型的处理器重排序。</p><p><code>volatile</code>也提供了禁止指令重排序的功能。</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://zhuanlan.zhihu.com/p/29881777" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/29881777</a><br><a href="https://blog.csdn.net/muxiqingyang/article/details/6615199" target="_blank" rel="noopener">https://blog.csdn.net/muxiqingyang/article/details/6615199</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总结下计算机内存架构的基本原理以及JMM的不同之处。&lt;/p&gt;
    
    </summary>
    
      <category term="计算机原理" scheme="http://simyy.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="Java" scheme="http://simyy.cn/tags/Java/"/>
    
      <category term="Linux" scheme="http://simyy.cn/tags/Linux/"/>
    
      <category term="计算机原理" scheme="http://simyy.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>线程模型及上下文切换</title>
    <link href="http://simyy.cn/2019/08/21/java-thread-1/"/>
    <id>http://simyy.cn/2019/08/21/java-thread-1/</id>
    <published>2019-08-21T09:20:33.000Z</published>
    <updated>2019-12-17T02:30:45.369Z</updated>
    
    <content type="html"><![CDATA[<p>记录下Java上下文切换的思考。</p><a id="more"></a><h3 id="线程实现"><a href="#线程实现" class="headerlink" title="线程实现"></a>线程实现</h3><p>线程的实现可分为三种方式<code>用户空间实现</code>、<code>内核空间实现</code>和<code>混合实现</code>。</p><p><code>用户空间实现</code>（N:1）：操作系统仅感知进程，而感知不到线程，线程是在用户空间实现（线程创建、销毁及调度）。</p><p><img src="/images/java_thread_1.jpg" alt="N:1"></p><blockquote><p><code>用户空间实现</code>其实类似于目前在<code>Python</code>、<code>Golang</code>中的<code>协程</code>的实现。</p><p><code>优点</code>：线程的调度只是在用户态，<code>减少了操作系统从内核态到用户态的切换开销</code>；<br><code>缺点</code>：操作系统不敢知线程，需要设计线程的调度算法和线程对CPU资源的抢占使用，难度较大。</p></blockquote><p><code>内核空间实现</code>（1:1）：操作系统感知进程和线程，线程是在内核空间实现（线程创建、销毁及调度）。</p><p><img src="/images/java_thread_2.jpg" alt="1:1"></p><blockquote><p><code>Linux</code>已经基于<code>NPTL</code>实现了更符合POSIX标准的线程。</p><p>在<code>Linux</code>中，线程被认为<code>轻量级进程(LWP)</code>，它是建立在内核之上并由内核支持的用户线程（内核线程的高度抽象），每一个轻量级进程都与一个特定的内核线程关联。内核线程只能由内核管理并像普通进程一样被调度。</p></blockquote><p><code>混合实现</code>（M:N）：通过使用<code>用户空间实现</code>、<code>内核空间实现</code>两种实现方式，即可以把线程管理交给内核，又可以利用内核态内切换开销小的特点。</p><p><img src="/images/java_thread_3.jpg" alt="M:N"></p><p><code>特点：</code></p><ul><li>轻量级进程作为用户态和内核态的桥梁;</li><li>尽量在用户态解决问题，避免内核态的切换；</li><li>轻量级进程负责用户态到内核态的切换。</li></ul><blockquote><p>Java中到底才用了哪种实现和具体虚拟机的实现有关（一般采用1:1的内核实现）。</p></blockquote><h3 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h3><p><code>Linux</code>是一个<code>多任务</code>操作系统，它支持远大于CPU数量的任务同时运行，通过将CPU轮流分配给它们，让用户感官上任务在同时运行。</p><p>多任务的分片执行必然会带来<code>CPU依赖环境的切换</code>，也就是<code>上下文切换</code>，其中包括<code>CPU寄存器</code>和<code>程序计数器</code>。</p><p><img src="/images/java_thread_4.png" alt="上下文切换"></p><blockquote><p><code>CPU寄存器</code>：CPU内置的容量小、但速度极快的内存；<br><code>程序计数器</code>：存储CPU正在执行的指令位置、或者即将执行的下一条指令位置；</p></blockquote><p><code>上下文切换</code>可以分为<code>线程上下文切换</code>、<code>进程上下文切换</code>、<code>中断上下文切换</code>。</p><p><code>线程</code>是调度的基本单位，<code>进程</code>则是资源拥有的基本单位。</p><p>内核调度的目标实际上对应的是<code>线程</code>，进程提供<code>虚拟内存</code>和<code>全局变量</code>。</p><p><strong>上下文切换的内容：</strong></p><ul><li><code>线程上下文切换</code>：<code>虚拟栈</code>、<code>寄存器</code>；</li><li><code>进程上下文切换</code>：<code>虚拟内存</code>、<code>全局变量</code>以及<code>虚拟栈</code>、<code>寄存器</code>。</li></ul><blockquote><p>一次系统调用实际上触发了<strong>两次</strong>上下文切换（用户态-&gt;内核态-&gt;用户态）。</p></blockquote><h3 id="Java线程模型"><a href="#Java线程模型" class="headerlink" title="Java线程模型"></a>Java线程模型</h3><p>如果按照<code>1:1模型</code>，Java中的线程就是<code>内核线程</code>，通过内核来调度线程的切换。</p><p>线程私有部有<code>程序计数器</code>和<code>虚拟机栈</code>，也是线程上下文切换时需要保存和加载的数据，其中，</p><ul><li><code>程序计数器</code>：字节码行号指示器；</li><li><code>虚拟机栈</code>：存放局部变量。</li></ul><blockquote><p><code>Java虚拟机</code>是一个独立的进程，在Java中其实不使用多进程编程，这里和其他语言不太一样。</p></blockquote><p><strong>那为什么Java中不使用多进程编程？</strong></p><p>资源的隔离性，一个虚拟机实例对应着一个进程，同一个虚拟机仅负责对应进程的内存管理，如果有一个进程发生异常，并不影响其它的子进程。</p><p>在<code>Python</code>中，存在GIL的原因导致多进程编程的存在。</p><p>一般来说么，多进程往往应用在隔离性很强的场景下，例如sandbox。</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://blog.csdn.net/CringKong/article/details/79994511#12__16" target="_blank" rel="noopener">https://blog.csdn.net/CringKong/article/details/79994511#12__16</a><br><a href="https://segmentfault.com/a/1190000000663472" target="_blank" rel="noopener">https://segmentfault.com/a/1190000000663472</a><br><a href="https://www.jianshu.com/p/2b27a5f30ce9" target="_blank" rel="noopener">https://www.jianshu.com/p/2b27a5f30ce9</a><br><a href="https://www.zhihu.com/question/23096638" target="_blank" rel="noopener">https://www.zhihu.com/question/23096638</a><br><a href="http://wanggaoliang.club/2018/11/30/cpu%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2/" target="_blank" rel="noopener">http://wanggaoliang.club/2018/11/30/cpu%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录下Java上下文切换的思考。&lt;/p&gt;
    
    </summary>
    
      <category term="计算机原理" scheme="http://simyy.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="Java" scheme="http://simyy.cn/tags/Java/"/>
    
      <category term="多线程" scheme="http://simyy.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="计算机原理" scheme="http://simyy.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>微服务浅谈</title>
    <link href="http://simyy.cn/2019/06/20/microservice/"/>
    <id>http://simyy.cn/2019/06/20/microservice/</id>
    <published>2019-06-20T12:57:21.000Z</published>
    <updated>2019-11-29T05:50:34.696Z</updated>
    
    <content type="html"><![CDATA[<p>大部分公司都会经历单体应用、SOA、微服务的各个架构演变的过程。</p><a id="more"></a><h3 id="单体应用"><a href="#单体应用" class="headerlink" title="单体应用"></a>单体应用</h3><p><strong>单体应用</strong> 是一个耦合了大量内部不可见的服务的独立系统，由于内部多个功能的耦合导致无法模块之间无法简单的拆分（牵一发而动全身）。</p><h5 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h5><blockquote><p><strong>优点：</strong></p><ul><li><code>易于开发/调试</code>，全部功能集中在一个项目</li><li><code>易于测试</code>，功能耦合在一起，没有分布式带来的诸多问题</li><li><code>易于部署</code>，只有一个应用</li></ul></blockquote><blockquote><p><strong>缺点：</strong></p><ul><li><code>不易于开发</code>，功能集中、内部依赖关系复杂导致系统难以开发和优化</li><li><code>不易于持续开发迭代</code>，整体开发、构建、部署都会影响整个迭代过程中的效率</li><li><code>技术受限</code>，整个应用使用相同的技术栈开发不同的功能，无法根据具体的场景做出其他选择</li><li><code>性能瓶颈</code>，部分功能出现瓶颈无法有针对性的优化，只能通过增加整个节点来临时解决问题（浪费资源）</li></ul></blockquote><p><img src="/images/microservice-1.png" alt="">@h=400</p><h5 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h5><p>个人博客、中小型论坛、小型门户咨询网站、个人电商系统都可以采用单体应用的方式来构建。</p><h3 id="SOA"><a href="#SOA" class="headerlink" title="SOA"></a>SOA</h3><p><strong>SOA</strong> 是一种分布式运算的软件设计方法<a href="https://zh.wikipedia.org/zh-hans/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84" target="_blank" rel="noopener">(来自维基百科)</a>，它将应用程序的不同功能单元（称为服务）通过这些服务之间定义的接口联系起来。</p><blockquote><p><code>SOA 是一种架构模式，是一种面向服务的思维方式</code>。</p></blockquote><ul><li>服务单独部署、易于系统优化</li><li>服务瓶颈单独维护和解决、易于伸缩</li><li>多应用部署运维要求较高</li><li>引入分布式问题：系统容错、网络延迟、分布式事务</li><li>接口调整引入的问题（依赖方需要感知接口的调整）</li></ul><h5 id="ESB架构"><a href="#ESB架构" class="headerlink" title="ESB架构"></a>ESB架构</h5><p><code>企业服务总线ESB(enterprise service bus)</code>是类似于通信模型中的通信总线的概念，所有服务应用将通过总线交互，而总线扮演着应用间的信息调度的角色，从而可以实现相互隔离的异构分布式服务系统。</p><p><img src="/images/microservice-2.png" alt="">@h=400</p><blockquote><p><strong>问题</strong></p><ul><li>ESB负责兼容和调度各个服务的异构接口（复杂均衡、流量控制等），内部实现很复杂</li><li>所有服务共用ESB的通道，直接影响了服务的通信速度</li></ul></blockquote><h5 id="ESB的替代品？"><a href="#ESB的替代品？" class="headerlink" title="ESB的替代品？"></a>ESB的替代品？</h5><p>在Java生态中，大家常用<code>grpc</code>、<code>thrift</code>、<code>dubbo</code>和<code>spring cloud</code>。</p><blockquote><p>这就是<code>第一代的微服务</code>的具体实现，特点在于：<code>注重服务发现、轻量链路通信。</code></p></blockquote><ul><li><code>服务注册、服务发现、负载均衡</code>均等功能都由具体的服务应用来控制</li><li><code>服务状态</code>信息由<code>分布式协调服务来维护</code>，例如<code>zookeeper</code>/<code>etcd</code></li><li>服务之间通信不再依赖一个单点总线，而是<code>点对点</code>的服务之间进行交互</li></ul><h5 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h5><p>中大型互联网公司都在使用SOA或者微服务架构，这种架构满足互联网的快速迭代、运维自由伸缩、资源独立运维的需求。</p><p>不同团队负责不同的业务，同一业务划分不同的功能模块独立部署，从而实现快速开发、快速构建、快速部署，快速上线的要求，而且也降低了不同团队之间的耦合，大家只需要根据API接口来沟通即可，不需要关心内部实现逻辑。</p><h3 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h3><p>从维基百科可以简单的了解一下什么是<a href="https://zh.wikipedia.org/wiki/%E5%BE%AE%E6%9C%8D%E5%8B%99" target="_blank" rel="noopener">微服务</a>。</p><blockquote><p><code>微服务</code> 是一种软件架构风格，它是以专注于<code>单一责任与功能的小型功能区块</code> (Small Building Blocks) 为基础，利用<code>模块化的方式组合</code>出复杂的大型应用程序，<code>各功能区块使用与语言无关</code> (Language-Independent/Language agnostic) 的 API 集相互通信。</p></blockquote><p><strong>单一职责与功能</strong>：功能独立，意味着应用可以独立部署，资源单独控制。<br><strong>模块化方式组合</strong>：功能可任意组合，组合方式通过任意通信方式（通信协议）来实现，不限于RPC/Restfull。<br><strong>功能区块与语言无关</strong>：应用独立部署、通信方式与语言无关，任意语言有自己的实现方式，所以应用可以采用更适合的语言来开发。</p><blockquote><p>其实这里看下来，微服务和SOA是不是一样的？</p><p>较早实践微服务的公司<code>Netflix</code>就曾经称他们构建的架构是<code>「细粒度的SOA」</code>。</p></blockquote><h4 id="SOA遇到kubernetes"><a href="#SOA遇到kubernetes" class="headerlink" title="SOA遇到kubernetes"></a>SOA遇到kubernetes</h4><p><code>细粒度的SOA</code>意味着服务拆分的更细，不仅是<code>服务拆分上的细</code>，也是<code>运维资源上的细</code>。</p><blockquote><p><code>运维资源上的细可以</code>通过<code>K8S</code>来实现，从而实现了<code>第二代微服务</code>。</p></blockquote><p><code>K8S或者说容器调度平台</code>的引入是比较<strong>革命性的</strong>。</p><p>容器使得我们的微服务对环境的依赖可以<code>打包整合进行随意分发</code>，从而实现<code>微服务节点任意调度</code>。</p><p>调度平台通过<code>服务的分类和抽象</code>，使得微服务本身的<code>部署和维护实现自动化</code>，以及实现更上一层楼的<code>自动伸缩</code>。</p><blockquote><p>自动化的难点就在于<code>服务的编排协调</code>。</p></blockquote><h6 id="虚拟化"><a href="#虚拟化" class="headerlink" title="虚拟化"></a>虚拟化</h6><p>虚拟化是指通过虚拟化技术将一台计算机虚拟为多台逻辑计算机。</p><p><code>VM（虚拟机）</code>是一个<code>物理硬件层抽象</code>，用于将一台服务器变成多台服务器，<code>每个VM都包含一整套操作系统</code>、 占用大量空间、启动慢。</p><p><code>Docker</code>是一个<code>应用层抽象</code>，用于将代码和依赖资源打包在一起。每个容器是<code>基于已有的公共基础设施中操作系统</code>的功能来运行的，<code>各自作为独立的进程在用户空间中运行</code>，占用空间极少，启动快。</p><blockquote><p><code>Docker</code>的轻量对于微服务来说是在适合不过了。</p></blockquote><h6 id="kubernetes"><a href="#kubernetes" class="headerlink" title="kubernetes"></a>kubernetes</h6><p><code>kubernetes（k8s）</code>是用于<code>自动部署</code>、<code>扩展和管理容器化（containerized）</code>应用程序的开源系统。</p><p><code>SOA</code>的思想出现后，系统拆分服务会变得越来越多，单靠原有的运维方式无法支撑管理，往往需要应用开发同事来帮忙查看到底那里出现了问题（配置发生了变更？目录权限有问题？）。</p><p>基于<code>kubernetes</code>，运维只负责<code>资源交付</code>，服务的启动注册、目录权限、配置都让服务的开发者来管理，从而降低了运维的压力，而运维更能把重点转移到基础运维工作中。</p><blockquote><p><code>kubernetes</code>解决了服务的编排协调及快速伸缩。</p></blockquote><p>虽然<code>kubernetes</code>为应用程序提供服务发现、负载均衡和外部路由的功能，但是大部分公司都是采用<code>dubbo/grpc</code>等框架来实现完整的服务发现。</p><h4 id="Service-Mesh"><a href="#Service-Mesh" class="headerlink" title="Service Mesh"></a>Service Mesh</h4><p><code>Service Mesh(服务网格)</code>是一个基础设施层，用于处理服务间通信。</p><p><img src="/images/microservice-3.png" alt="">@h=200</p><blockquote><p><code>Service Mesh</code>类似于在k8s的基础之上又封装了统一的服务发现功能。</p></blockquote><p><code>Service Mesh</code>会接管整个集群的网络，把所有请求在服务之间做转发。从而业务开发不再需要关注服务的注册和发现，只专注完成业务逻辑，服务之间的通讯环节就从应用层剥离出来。</p><p><code>Service Mesh（服务网格）</code>实际上是抽象出了一个基础设施层，独立于应用之外，所提供的功能就是实现请求的可靠路由，部署上体现为轻量级的网络代理，并对应用是透明的。</p><h5 id="服务治理"><a href="#服务治理" class="headerlink" title="服务治理"></a>服务治理</h5><blockquote><p><code>微服务</code>时代面临最大的挑战就是<code>服务治理</code>。</p></blockquote><p>在大型互联网公司都会有自研的一套服务治理框架，功能各不相同各有优势，但都有不足之处。</p><p>目前最火的<code>SpringCloud</code>提供了一系列的组件来实现微服务下的<code>服务治理</code>。</p><p><code>Service Mesh（服务网格）</code>利用<code>基础设施层</code>来解决<code>服务注册、服务路由、流量控制、服务降级、安全认证</code>等功能。</p><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><p>对于大规模部署微服务，内部服务异构程度高的场景，使用<code>Service Mesh（服务网格）</code>方案是一个不错的选择。</p><p><code>Service Mesh（服务网格）</code>实现了<code>业务逻辑和控制的解耦</code>。</p><p><code>网络中多了一跳</code>，增加了<code>性能的损耗和访问的延迟</code>。</p><p>每个服务都需要部署<code>Sidecar</code>, 这也会使本来就具有一定复杂度的分布式系统变得更加复杂。</p><p><img src="/images/microservice-4.png" alt="">@h=200</p><h5 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h5><p>第一代<code>Service Mesh</code>的代表为<code>Linkerd</code>和<code>Envoy</code>。</p><p>第二代<code>Service Mesh</code>主要改进集中在更加强大的控制面功能（<code>Sidecar</code>），典型代表有<code>Istio</code>和<code>Conduit</code>。</p><p>到目前为止，服务网格的概念已经被实现，也有投入生产的实例，但普及还是需要一定时间。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>从<code>单体应用、SOA、微服务、K8S、ServiceMesh</code>的发展中可以看到技术的层出不穷，技术分工越来越细。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://jinfei21.github.io/2018/11/15/%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E7%9C%8B%E5%A5%BD%E6%96%B0%E4%B8%80%E4%BB%A3%E5%BE%AE%E6%9C%8D%E5%8A%A1ServiceMesh/" target="_blank" rel="noopener">https://jinfei21.github.io/2018/11/15/%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E7%9C%8B%E5%A5%BD%E6%96%B0%E4%B8%80%E4%BB%A3%E5%BE%AE%E6%9C%8D%E5%8A%A1ServiceMesh/</a><br><a href="https://juejin.im/post/592f87feb123db0064e5ef7c#heading-1" target="_blank" rel="noopener">https://juejin.im/post/592f87feb123db0064e5ef7c#heading-1</a><br><a href="https://juejin.im/post/5ad4146ff265da238670592f" target="_blank" rel="noopener">https://juejin.im/post/5ad4146ff265da238670592f</a><br><a href="https://zhuanlan.zhihu.com/p/53260098" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/53260098</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大部分公司都会经历单体应用、SOA、微服务的各个架构演变的过程。&lt;/p&gt;
    
    </summary>
    
      <category term="架构" scheme="http://simyy.cn/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="架构" scheme="http://simyy.cn/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="微服务" scheme="http://simyy.cn/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>Java 锁与多线程协作</title>
    <link href="http://simyy.cn/2019/05/14/java-lock/"/>
    <id>http://simyy.cn/2019/05/14/java-lock/</id>
    <published>2019-05-14T11:14:15.000Z</published>
    <updated>2019-12-17T02:30:44.472Z</updated>
    
    <content type="html"><![CDATA[<p>一般谈到多线程都会谈到<code>锁</code>这个概念，通过限制并发控制来保证操作互斥的要求。</p><a id="more"></a><p><strong>锁</strong>：在执行多线程时用于强行限制资源访问的同步机制，即用于在并发控制中保证对互斥要求的满足（wikipedia）。</p><p><img src="/images/java_lock_1.png" alt=""></p><h3 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h3><p><code>Synchronized</code>是Java中提供的最基础的悲观锁。</p><blockquote><p><strong>悲观锁</strong>：它可以阻止一个事务以影响其他用户的方式来修改数据（wikipedia）。</p></blockquote><p><code>Synchronized</code>是通过<code>Monitor</code>来实现的，通过<code>javap</code>命令生成的字节码大体结构如下，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">method ...</span><br><span class="line">    ...</span><br><span class="line">    monitorenter // 加锁</span><br><span class="line">    ...</span><br><span class="line">    aload 0</span><br><span class="line">    moniterexit // 解锁</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>注意上面的<code>monitorenter</code>和<code>monitorexit</code>对应着加锁和解锁的操作。</p><blockquote><p><strong>Monitor</strong>：一种线程同步机制，每个Java对象都持有一个Monitor锁(再下面会仔细介绍)。<br><code>Key Point 1</code>: 每个线程都有一个<code>Monitor Record 列表</code>；<br><code>Key Point 2</code>: 每个被锁住的对象都会与当前线程的<code>Monitor Record 列表</code>关联;<br><code>Key Point 3</code>: <code>Monitor的Owner字段</code>存放持有锁的线程的唯一标识;</p></blockquote><blockquote><p><strong>对象头</strong>：每一个对象都包含了一个<code>Mark Word</code>字段，默认存储<code>对象的HashCode</code>，<code>分代年龄</code>和<code>锁标志位</code>信息。</p></blockquote><p>每当一个线程执行到<code>Synchronized</code>包裹的代码块时，都会先查询当前线程是否已经持有或可以持有当前对象的Monitor锁。</p><blockquote><p><strong>问题</strong>：线程切换耗时可能比用户代码执行的之间还要长，从而频繁线程切换会浪费大量的时间。</p></blockquote><p>在JDK 1.6开始，<code>HotSpot虚拟机</code>开发团队开始对Java中的锁进行优化，加入了<code>适应性自旋</code>、<code>锁消除</code>、<code>锁粗化</code>、<code>轻量级锁</code>和<code>偏向锁</code>等针对<code>Synchronized</code>的优化。</p><blockquote><p>推荐看一下这篇文章对锁优化的总结：<a href="https://tech.meituan.com/2018/11/15/java-lock.html" target="_blank" rel="noopener">不可不说的Java“锁”事</a></p></blockquote><h4 id="锁的膨胀"><a href="#锁的膨胀" class="headerlink" title="锁的膨胀"></a>锁的膨胀</h4><blockquote><p><code>偏向锁</code>和<code>轻量级锁</code>是乐观锁，基于CAS来实现的，而<code>重量级锁</code>是悲观锁，基于底层的操作系统的<code>Mutex Lock（互斥锁）</code>来实现的。</p></blockquote><p><code>偏向锁</code>：仅一个线程进入临界区，当前对象会持有<code>偏向锁</code>。</p><p><code>轻量级锁</code>：当两个线程交替进入临界区，会发生锁的升级，更新到<code>轻量级锁</code>。</p><p><code>重量级锁</code>：当多个线程同时进入临界区或者线程自旋的次数太大的时候，会发生锁的升级，更新到<code>重量级锁</code>。</p><h3 id="Object-wait-notify"><a href="#Object-wait-notify" class="headerlink" title="Object wait/notify"></a>Object wait/notify</h3><p>Object提供了<code>wait</code>和<code>notify</code>来实现多线程协作，而其底层实现也是基于<code>Monitor</code>来实现的。</p><p>对于每一个对象都存在一个<code>ObjectMonitor结构</code>,</p><blockquote><p><strong>Owner</strong>：当前持有锁的线程ID；<br><strong>WaitSet</strong>：存放处于wait状态的线程队列；<br><strong>EntryList</strong>：存放处于等待锁block状态的线程队列。</p></blockquote><p><strong>步骤：</strong></p><ol><li>当多个线程同时访问一段同步代码时，会进入<code>EntryList</code>队列中尝试获取锁。</li><li>当一个线程获取到锁的时候会更新对象的<code>Owner</code>字段中的线程ID为当前线程ID。</li><li>当线程调用<code>wait</code>方法时，释放当前对象的Monitor，<code>Owner</code>字段恢复为null，当前线程加入到<code>WaitSet</code>中等待被其他线程唤醒。</li><li>当线程调用<code>notify</code>方法时，释放当前对象得Monitor，<code>Owner</code>字段恢复为null，并唤醒处于<code>WaitSet</code>中的线程。</li></ol><h3 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h3><p><code>AQS</code>是一个用来构建锁和同步器的框架，例如<code>ReentrantLock</code>、<code>ReentrantReadWriteLock</code>等皆是基于AQS来实现的。</p><blockquote><p><strong>核心思想</strong>：</p><ol><li>如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。</li><li>如果被请求的共享资源被占用，那么就需要一套<code>线程阻塞等待</code>以及<code>被唤醒时锁分配</code>的机制(CLH队列锁)。</li></ol></blockquote><p><img src="/images/java_lock_3.png" alt=""></p><p><code>CLH(Craig,Landin,and Hagersten)队列</code>是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。</p><p><code>AQS</code>是将每条请求共享资源的线程封装成一个<code>CLH锁队列的一个结点（Node）</code>来实现锁的分配。</p><p><code>AQS</code>定义两种资源共享方式：<code>独占</code>和<code>共享</code>。</p><p><code>独占</code>是只有一个线程能执行（如如ReentrantLock等），而<code>共享</code>是允许多个线程同时执行（如Semaphore等）。</p><blockquote><p><code>独占</code>模式下又可分为<code>公平锁</code>和<code>非公平锁</code>。</p><p><code>公平锁</code>：按照线程在队列中的排队顺序，先到者先拿到锁；<br><code>非公平锁</code>：当线程要获取锁时，无视队列顺序直接去抢锁，谁抢到就是谁的。</p></blockquote><h3 id="重入"><a href="#重入" class="headerlink" title="重入"></a>重入</h3><p><code>Synchronized</code>与<code>JUC lock</code>都是<code>可重入</code>的。</p><p><code>可重入</code>是同一线程可以重复获得当前锁，也是为了<code>避免死锁问题</code>。</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://www.jianshu.com/p/f4454164c017" target="_blank" rel="noopener">https://www.jianshu.com/p/f4454164c017</a><br><a href="https://blog.csdn.net/kobejayandy/article/details/39975339" target="_blank" rel="noopener">https://blog.csdn.net/kobejayandy/article/details/39975339</a><br><a href="https://tech.meituan.com/2018/11/15/java-lock.html" target="_blank" rel="noopener">https://tech.meituan.com/2018/11/15/java-lock.html</a><br><a href="https://www.hollischuang.com/archives/2030" target="_blank" rel="noopener">https://www.hollischuang.com/archives/2030</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一般谈到多线程都会谈到&lt;code&gt;锁&lt;/code&gt;这个概念，通过限制并发控制来保证操作互斥的要求。&lt;/p&gt;
    
    </summary>
    
      <category term="编程语言" scheme="http://simyy.cn/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="Java" scheme="http://simyy.cn/tags/Java/"/>
    
      <category term="锁" scheme="http://simyy.cn/tags/%E9%94%81/"/>
    
      <category term="编程语言" scheme="http://simyy.cn/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Java 类的加载和多版本控制</title>
    <link href="http://simyy.cn/2019/03/20/java-classloader/"/>
    <id>http://simyy.cn/2019/03/20/java-classloader/</id>
    <published>2019-03-20T10:20:51.000Z</published>
    <updated>2019-12-17T02:30:43.078Z</updated>
    
    <content type="html"><![CDATA[<p><code>类加载器（ClassLoader）</code>是通过一个类的<code>全限定名</code>来获取定义此类的二进制字节流。<br><a id="more"></a></p><p>在类加载的第一阶段<code>“加载”</code>过程中，需要通过一个类的<code>全限定名</code>来获取定义此类的二进制字节流，完成这个动作的代码块就是<code>类加载器</code>。</p><h3 id="类的唯一性"><a href="#类的唯一性" class="headerlink" title="类的唯一性"></a>类的唯一性</h3><p>类加载器虽然只用于实现类的加载动作，但是对于任意一个类，都需要由<code>加载它的类加载器</code>和<code>这个类本身</code>共同确立其在Java虚拟机中的<code>唯一性</code>。</p><blockquote><p>通俗的说，JVM中两个类是否“相等”，首先就必须是同一个类加载器加载的，否则，即使这两个类来源于同一个Class文件，被同一个虚拟机加载，只要类加载器不同，那么这两个类必定是不相等的。</p></blockquote><h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><p>从<code>Java虚拟机角度</code>来说，只存在两种不同的类加载器：</p><ul><li><strong>启动类加载器（Bootstrap ClassLoader）</strong>，这个类加载器使用C++语言实现（HotSpot虚拟机中），是虚拟机自身的一部分；</li><li><strong>其他的类加载器</strong>，这些类加载器都有Java语言实现，<code>独立于虚拟机外部</code>，并且全部继承自<code>java.lang.ClassLoader</code>。</li></ul><p>从<code>开发者的角度</code>，类加载器可以细分为：</p><ul><li><strong>启动（Bootstrap）类加载器</strong>：负责将Java_Home/lib下面的类库加载到内存中（比如rt.jar）。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作。</li><li><strong>标准扩展（Extension）类加载器</strong>：是由Sun的ExtClassLoader（sun.misc.Launcher$ExtClassLoader）实现的。它负责将Java_Home/lib/ext或者由系统变量java.ext.dir指定位置中的类库加载到内存中。开发者可以直接使用标准扩展类加载器。</li><li><strong>应用程序（Application）类加载器</strong>：是由Sun的AppClassLoader（sun.misc.Launcher$AppClassLoader）实现的。它负责将系统类路径（CLASSPATH）中指定的类库加载到内存中。开发者可以直接使用系统类加载器。由于这个类加载器是ClassLoader中的getSystemClassLoader()方法的返回值，因此一般称为<code>系统（System）加载器</code>。</li></ul><p><img src="/images/java_classloader_1.png" alt=""></p><h3 id="破坏双亲委派模型"><a href="#破坏双亲委派模型" class="headerlink" title="破坏双亲委派模型"></a>破坏双亲委派模型</h3><p><code>Tomcat</code>、<code>JDBC</code>、<code>JNDI</code>、<code>Thread.currentThread().setContextClassLoader()</code>等都违反了双亲委托。</p><h4 id="Tomcat类加载"><a href="#Tomcat类加载" class="headerlink" title="Tomcat类加载"></a>Tomcat类加载</h4><p><code>Tomcat</code>作为一个web容器，需要保证web容器之间的互不影响。</p><blockquote><p><code>容器之间隔离性：</code></p><ul><li>保证每个应用的类库都是独立的，保证相互隔离；</li><li>部署在不同web容器中相同的类库相同的版本可以共享；</li><li>基于安全考虑，应该让容器的类库和程序的类库隔离开来。</li></ul></blockquote><p><code>Tomcat</code>为了上面的隔离性问题，没有遵守双亲委派这个约定，每个<code>webappClassLoader</code>加载自己的目录下的<code>class文件</code>，<code>不会传递给父类加载器</code>。</p><p><img src="/images/java_classloader_2.png" alt=""></p><p><strong>Tomcat的类加载过程：</strong></p><ol><li>在本地缓存中查找是否已经加载过该类；</li><li>委托Appication类加载器尝试加载该类（<code>为了防止一些基础类会被web中的类覆盖</code>）；</li><li>委托WebApp应用的类加载器将自行加载(违反了双亲委托机制)，如果加载到则返回；</li><li>委托父类Common类加载器（违反了双亲委托机制）去加载。</li></ol><h4 id="SPI"><a href="#SPI" class="headerlink" title="SPI"></a>SPI</h4><blockquote><p><code>双亲委派存在的问题？SPI为什么出现？</code></p><p>在实际开发场景中，存在一些组件或扩展的实现由应用来具体实现的。可以理解为，系统类提供了通用的接口，具体实现需要应用来实现并且加载。</p></blockquote><p><code>SPI(Service Provider Interface)</code>是Java提供的一套用来被第三方实现或者扩展的API，它可以用来启用框架扩展和替换组件。</p><blockquote><p><strong>JDBC违背了双亲委派模型？</strong></p><p>在<code>JDBC4.0</code>之前，连接数据库的时候，通常会用<code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;)</code>加载数据库相关的驱动，然后再进行获取连接等的操作。<br>而<code>JDBC4.0</code>之后不需要<code>Class.forName</code>来加载驱动，直接获取连接即可，这里使用了<code>Java的SPI扩展机制</code>来实现。</p></blockquote><h4 id="OSGI"><a href="#OSGI" class="headerlink" title="OSGI"></a>OSGI</h4><p><code>OSGi（Open Service Gateway Initiative）</code>是Java动态化模块化系统的一系列规范。</p><p><img src="/images/java_classloader_3_osgi.png" alt=""></p><p><code>bundle</code>是开发、部署 OSGi 应用的基本单元，可以认识一个功能模块，最重要的是每个<code>bundle</code>都有单独的类加载器(这也是解决多版本冲突的重点)。</p><blockquote><p><strong>为什么需要动态化模块？</strong><br><code>版本化</code>：<code>bundle</code>可以版本化，多版本能够共存而不会影响系统功能；<br><code>热插拔</code>：<code>bundle</code>能够进行即时的更新，服务可以根据需要动态增加或者删除；</p></blockquote><p><code>OSGI</code>可以通过仅暴露服务，不同<code>bundle</code>可以依赖各自版本的jar包来解决<code>java多版本冲突</code>的问题。</p><blockquote><p><code>在Java9中提供了模块化特性</code>。</p><p>阿里有一款未开源的<code>Pandora中间件</code>，同样利用了模块化思想。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;类加载器（ClassLoader）&lt;/code&gt;是通过一个类的&lt;code&gt;全限定名&lt;/code&gt;来获取定义此类的二进制字节流。&lt;br&gt;
    
    </summary>
    
      <category term="编程语言" scheme="http://simyy.cn/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="Java" scheme="http://simyy.cn/tags/Java/"/>
    
      <category term="编程语言" scheme="http://simyy.cn/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>电商架构</title>
    <link href="http://simyy.cn/2018/12/20/e-commerce-architecture/"/>
    <id>http://simyy.cn/2018/12/20/e-commerce-architecture/</id>
    <published>2018-12-20T06:37:04.000Z</published>
    <updated>2019-11-29T05:51:35.390Z</updated>
    
    <content type="html"><![CDATA[<p>记录下电商系统涉及到的一些系统的关联关系。<br><a id="more"></a><br><img src="/images/e-commerce-architecture.png" alt="业务架构"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录下电商系统涉及到的一些系统的关联关系。&lt;br&gt;
    
    </summary>
    
      <category term="架构" scheme="http://simyy.cn/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="架构" scheme="http://simyy.cn/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="微服务" scheme="http://simyy.cn/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>Git</title>
    <link href="http://simyy.cn/2018/04/12/git/"/>
    <id>http://simyy.cn/2018/04/12/git/</id>
    <published>2018-04-12T00:30:42.000Z</published>
    <updated>2019-12-17T02:33:09.729Z</updated>
    
    <content type="html"><![CDATA[<p>Git是一个开源的分布式版本控制系统。</p><a id="more"></a><h2 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h2><p>Git的作者是大名鼎鼎的<code>Linus（Linux的创始人</code>）。</p><blockquote><p><a href="http://geek.csdn.net/news/detail/30067" target="_blank" rel="noopener"><code>Linux创始人Linus Torvalds访谈，Git的十年之旅</code></a> <a href="https://www.linuxfoundation.org/blog/10-years-of-git-an-interview-with-git-creator-linus-torvalds/" target="_blank" rel="noopener">英文</a></p></blockquote><h3 id="为什么要创建Git？"><a href="#为什么要创建Git？" class="headerlink" title="为什么要创建Git？"></a>为什么要创建Git？</h3><p><strong>阶段一</strong>：起初参与Linux开源项目的代码是由Linus本人通过<code>diff和patch</code>命令来<code>手动</code>为别人整合代码的，但是代码库之大<code>很难</code>继续通过<code>手工方式管理</code>了。</p><p><strong>阶段二</strong>：为了解决上一个问题，开始使用版本控制工具<code>BitKeeper</code>，但注意它<code>并非开源的</code>。</p><p><strong>阶段三</strong>：开发Samba的Andrew试图破解BitKeeper的协议，被BitMover公司发现并收回Linux社区的免费使用权。</p><p><strong>阶段四</strong>：工具没了，咋整？Linus花了两周时间自己用C写了一个<code>分布式版本控制系统</code>，这就是<code>Git</code>！一个月之内，Linux系统的源码已经由Git管理了！</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><img src="/images/15240979976862.jpg" alt=""></p><h3 id="工作区-amp-版本库"><a href="#工作区-amp-版本库" class="headerlink" title="工作区&amp;版本库"></a>工作区&amp;版本库</h3><p>在初始化git版本库之后会生成一个隐藏的文件<code>.git</code> ，可以将该文件理解为git的<code>版本库</code>。</p><p>项目文件夹属于<code>工作区</code>，在<code>.git</code> 文件夹里面还有很多文件，其中有一个<code>index 文件</code>就是<code>暂存区（也可以叫做 stage）</code> 。</p><blockquote><p>每当编辑好一个或几个文件后，通过add操作把它加入到暂存区，然后接着修改其他文件，改好后放入暂存区，循环反复直到修改完毕，最后使用 commit 命令，将暂存区的内容永久保存到本地仓库。这个过程其实就是构建项目快照的过程，当我们提交时，git 会使用暂存区的这些信息生成tree对象，也就是项目快照，永久保存到数据库中，因此也可以说暂存区是用来构建项目快照的区域。</p></blockquote><p><img src="/images/15240980359546.jpg" alt=""></p><p>git还为我们自动生成了一个分支<code>master（默认分支）</code>以及指向该分支的<code>指针head</code>·。</p><h3 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h3><p><code>objects</code>是用来存储git数据，具体可以分为<code>blob</code>、<code>tree</code>和<code>commit</code>。</p><hr><p><code>blob</code>用来存放项目文件的内容，但是不包括文件的路径、名字、格式等其它描述信息。项目的任意文件的任意版本都是以blob的形式存放的。</p><p><code>tree</code>用来表示目录。项目就是一个目录，其中包括文件、子目录，因此 tree 中有 blob、子tree。</p><blockquote><p><code>blob</code>和<code>tree</code>是使用 sha-1值引用的（将文件中的内容通过通过计算生成一个 40 位长度的hash值，其特点：由文件内容计算出的hash值hash值相同，文件内容相同）。</p></blockquote><p><code>commit</code>表示一次提交，有parent字段，用来引用父提交。指向了一个顶层 tree，表示了项目的快照，还有一些其它的信息，比如上一个提交，committer、author、message 等信息。</p><hr><p><img src="/images/15240980465160.jpg" alt=""></p><blockquote><p>从顶层的 tree 纵览整个树状的结构，叶子结点就是blob，表示文件的内容，非叶子结点表示项目的目录，而<code>顶层的 tree 对象就代表了当前项目的快照</code>。</p></blockquote><h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><p><img src="/images/15240980763614.jpg" alt=""></p><p><code>分支的目的</code>是让我们可以并行的进行开发。</p><p>比如我们当前正在开发功能，但是需要修复一个紧急bug，我们不可能在这个项目正在修改的状态下修复 bug，因为这样会引入更多的bug。</p><p>分支的实现其实很简单，我们可以先看一下 .git/HEAD 文件，它保存了当前的分支，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~/work/communitycenter   features/0412 ●✚  cat .git/HEAD</span><br><span class="line">ref: refs/heads/features/0412</span><br></pre></td></tr></table></figure><p><code>Git 的分支</code>本质上仅仅是指向提交<code>对象的可变指针</code>。 Git 的默认分支名字是<code>master</code>。 在多次提交操作之后，你其实已经有一个指向最后那个提交对象的 commit。 它会在每次的提交操作中自动向前移动。</p><blockquote><p>Git 的 “master” 分支并不是一个特殊分支。 它就跟其它分支完全没有区别。 之所以几乎每一个仓库都有 master 分支，是因为 git init 命令默认创建它，并且大多数人都懒得去改动它。</p></blockquote><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="Config"><a href="#Config" class="headerlink" title="Config"></a>Config</h3><p>修改分支之前应该需要修改好用户名和邮箱，这样才知道当前的修改属于谁。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config user.email xxxx 设置邮箱</span><br><span class="line">git config user.name yyyy 设置用户名</span><br></pre></td></tr></table></figure><h3 id="Merge-amp-Rebase"><a href="#Merge-amp-Rebase" class="headerlink" title="Merge &amp; Rebase"></a>Merge &amp; Rebase</h3><p>在 git 中合并分支有两种选择：<code>merge</code>和<code>rebase</code>，但是无论哪一种，都有可能产生冲突。</p><blockquote><p>冲突的产生：两个已经提交的分支的<code>相同文件相同位置的的不同操作进行了合并</code>。</p></blockquote><p><img src="/images/15240981123981.jpg" alt=""></p><p>由于并行开发，<code>master</code>分支和<code>feature</code>分支出现了并行情况，并且同时更改了相同文件的相同位置，造成了冲突。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;HEAD</span><br><span class="line">other code</span><br><span class="line"></span><br><span class="line">========</span><br><span class="line"></span><br><span class="line">your code</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;your branch name</span><br></pre></td></tr></table></figure><h3 id="Merge"><a href="#Merge" class="headerlink" title="Merge"></a>Merge</h3><p><code>Merge</code>会把不同分支的commit合并（<code>保留commit的时间线</code>）起来，通过新增一个新的commit来实现冲突的解决。</p><p>在没有冲突的情况下，<code>Merge</code>合并情况如下，其中<code>7</code>为合并的<code>commit</code>，</p><p><img src="/images/15240981214130.jpg" alt=""></p><blockquote><p>如果发生冲突的话，<code>Merge</code>命令会自动合并，否则需要人工解决这些冲突。</p></blockquote><p>如果提示<code>Automatic merge failed; fix conflicts and then commit the result.</code>，说明自动合并失败。</p><p>此时可以通过<code>git status</code>来查看冲突情况，一般会有这样的提示<code>both modified:   xxxxx</code>。</p><hr><p> <code>merge</code>是一种<code>不修改分支历史提交记录</code>的方式，这也是我们常用的方式。</p><hr><h3 id="Rebase"><a href="#Rebase" class="headerlink" title="Rebase"></a>Rebase</h3><p><code>Rebase</code>会把从<code>Merge Base</code>以来的所有提交以补丁的形式一个一个重新达到目标分支上。</p><p><img src="/images/15240981289836.jpg" alt=""></p><hr><p>与<code>Merge</code>不同，<code>Rebase</code>会重新修改基于远程分支的commit，使得目标分支合并该分支的时候会直接<code>Fast Forward</code>，即不会产生任何冲突，提交历史是一条线，这对强迫症患者可谓是一大福音。</p><p>由于一条线提交历史也可以保证分支功能在master分支上是<code>有序的</code>。</p><hr><p><code>Rebase</code>还可以用来修改历史commit，一般在写代码的时候经常会提交一些无效的commit，这些commit不利于代码review，从commit中不能获得此次的改动点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">commit af6922a5d3d31a4f3816a27a14476f62a533579e</span><br><span class="line">Author: xxxx</span><br><span class="line">Date:   Fri Mar 16 10:17:50 2018 +0800</span><br><span class="line">    fix bug</span><br><span class="line">...</span><br><span class="line">commit 71966c45a79dcf7ae13842feea61d61ba77fa120</span><br><span class="line">Author: xxxx</span><br><span class="line">Date:   Thu Mar 15 19:58:03 2018 +0800</span><br><span class="line">    fix bg</span><br></pre></td></tr></table></figure><p>可使用<code>Rebase</code>命令如下，其中xxx代表base为xxx的commit。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i &lt;comment-id&gt;</span><br></pre></td></tr></table></figure></p><p>执行结果如下，其中可以通过修改<code>pick</code>来实现修改commit操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pick e0f56d9 fix bug</span><br><span class="line">s f3s0281 fix bug</span><br><span class="line">s a310682 fix bug</span><br><span class="line">s 1902931 fix bug</span><br><span class="line"></span><br><span class="line"># Commands:</span><br><span class="line"># p, pick = use commit</span><br><span class="line"># r, reword = use commit, but edit the commit message</span><br><span class="line"># e, edit = use commit, but stop for amending</span><br><span class="line"># s, squash = use commit, but meld into previous commit</span><br><span class="line"># f, fixup = like &quot;squash&quot;, but discard this commit&apos;s log message</span><br><span class="line"># x, exec = run command (the rest of the line) using shell</span><br><span class="line"># d, drop = remove commit</span><br></pre></td></tr></table></figure></p><p><strong>一般使用的姿势如下：</strong></p><p>通过<code>edit</code>来修改目标commit的内容</p><p><img src="/images/15240981389227.jpg" alt=""></p><p>通过<code>squash</code>来合并多个commit的内容</p><p><img src="/images/15240981445332.jpg" alt=""></p><hr><h3 id="Branch、Checkout、Revert、Reset"><a href="#Branch、Checkout、Revert、Reset" class="headerlink" title="Branch、Checkout、Revert、Reset"></a>Branch、Checkout、Revert、Reset</h3><p>创建分支的两种方式：</p><p><code>git branch new_branch</code> =&gt; 创建新分支</p><p><code>git checkout -b new_branch</code> =&gt; 创建并切换到新分支</p><hr><p><code>Revert</code>一般被称为反向提交。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git revert &lt;comment-id&gt;</span><br></pre></td></tr></table></figure><blockquote><p>什么是反向提交呢，就是旧版本添加了的内容，要在新版本中删除，旧版本中删除了的内容，要在新版本中添加。这在分支已经推送到远程仓库的情境下非常有用。</p></blockquote><p><code>Revert也不会修改历史提交记录</code>，实际的操作相当于是检出目标提交的项目快照到工作区与暂存区，然后用一个新的提交完成版本的<code>回退</code>。</p><hr><p>与<code>Revert</code>很像，<code>Reset</code>用来在当前分支进行版本的“回退”，不同的是，<code>Reset 是会修改历史提交记录的</code>。</p><p><code>Reset</code>常用的选项有三个，分别是<code>soft</code>,  <code>mixed</code>, <code>hard</code>，他们的作用域依次增大。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --&lt;option&gt; &lt;comment-id&gt;</span><br></pre></td></tr></table></figure><p><code>soft</code>选项仅会修改分支指向，而不修改工作区与暂存区的内容，可以重新做一次提交，形成一个新的 commit，常用与撤销临时提交的场景。</p><blockquote><p><code>soft</code>可用于上面多个无效commit的合并（只使用于合并当前commit之前的连续commit）。</p></blockquote><p><code>mixed</code>比<code>soft</code>的作用域多了一个 暂存区，实际上<code>mixed 选项与 soft 只差了一个 add 操作</code>。</p><p><code>hard</code>选项会导致工作区内容“丢失”，因此在使用 <code>hard</code> 选项时，一定要确保知道自己在做什么，避免丢失分支内容。</p><blockquote><p>如果真的误用了<code>hard</code>，造成了数据丢失怎么办？<br>如果真的误操作了，也不要慌，因为只要 git 一般不会主动删除本地仓库中的内容，根据你丢失的情况，可以进行找回，解决方法有两种：<br>一、使用 <code>git reset --hard ORIG_HEAD</code>立即恢复<br>二、使用 <code>reflog</code>命令查看之前分支的引用</p></blockquote><h3 id="Stash"><a href="#Stash" class="headerlink" title="Stash"></a>Stash</h3><p><code>stash</code>将工作区与暂存区中的内容做一个提交并保存起来，然后使用<code>reset hard</code>选项恢复工作区与暂存区内容。我们可以随时使用 <code>stash apply</code> 将修改应用回来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git stash</span><br><span class="line">git stash apply</span><br></pre></td></tr></table></figure><blockquote><p>使用场景：有时，我们在一个分支上做了一些工作，修改了很多代码，而这时需要切换到另一个分支干点别的事。但又不想将只做了一半的工作提交。在曾经这样做过，将当前的修改做一次提交，message 填写 half of work，然后切换另一个分支去做工作，完成工作后，切换回来使用 <code>reset —soft</code>（重新提交commit）或者是 <code>commit amend</code>（修改commit）。</p></blockquote><h3 id="cherry-pick"><a href="#cherry-pick" class="headerlink" title="cherry-pick"></a>cherry-pick</h3><p><code>cherry-pick</code>用于把另一个本地分支的commit修改应用到当前分支。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git cherry-pick &lt;comment-id&gt;</span><br></pre></td></tr></table></figure><blockquote><p>如果在cherry-pick 的过程中出现了冲突？和rebase和merge一样，都需要手动解决冲突再提交。</p></blockquote><h3 id="set-upstream"><a href="#set-upstream" class="headerlink" title="set-upstream"></a>set-upstream</h3><p><code>set-upstream</code>用于设置分支跟踪关系。</p><p>一般本地新建一个分支再往远程仓库推送的时候，需要指定远程仓库的目标分支。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git push --set-upstream origin &lt;new_branch&gt;</span><br><span class="line">git branch --set-upstream-to=&lt;target branch&gt; &lt;new_branch&gt;</span><br></pre></td></tr></table></figure></p><h3 id="pull-amp-fetch"><a href="#pull-amp-fetch" class="headerlink" title="pull &amp; fetch"></a>pull &amp; fetch</h3><p><code>pull</code>=<code>fetch</code>+<code>merge</code>。</p><p><code>pull</code>是下拉远程分支并与本地分支合并。<code>fetch</code>只是下拉远程分支，并不会发生合并需要手动执行合并。</p><p>也可以采用<code>rebase</code>模式，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull --rebase</span><br></pre></td></tr></table></figure></p><p>该命令做了以下内容：<br>一、把你 commit 到本地仓库的内容，取出来放到暂存区(<code>stash</code>)（这时你的工作区是干净的）<br>二、然后从远端拉取代码到本地，由于工作区是干净的，所以不会有冲突<br>三、从暂存区把你之前提交的内容取出来，跟拉下来的代码合并</p><blockquote><p><code>rebase</code>在拉代码前要确保你本地工作区是干净的，如果你本地修改的内容没完全 commit 或者 stash，就会 rebase 失败。</p></blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.coding.net/blog/principle-of-Git" target="_blank" rel="noopener">https://blog.coding.net/blog/principle-of-Git</a><br><a href="http://www.bootcss.com/p/git-guide/" target="_blank" rel="noopener">http://www.bootcss.com/p/git-guide/</a><br><a href="https://www.cnblogs.com/dogdogwang/p/7072931.html" target="_blank" rel="noopener">https://www.cnblogs.com/dogdogwang/p/7072931.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Git是一个开源的分布式版本控制系统。&lt;/p&gt;
    
    </summary>
    
      <category term="计算机原理" scheme="http://simyy.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="Git" scheme="http://simyy.cn/tags/Git/"/>
    
      <category term="计算机原理" scheme="http://simyy.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>区块链</title>
    <link href="http://simyy.cn/2017/12/21/block-chain/"/>
    <id>http://simyy.cn/2017/12/21/block-chain/</id>
    <published>2017-12-21T12:53:55.000Z</published>
    <updated>2019-12-17T02:34:04.719Z</updated>
    
    <content type="html"><![CDATA[<p>简单介绍区块链技术。</p><a id="more"></a><h3 id="什么是区块链"><a href="#什么是区块链" class="headerlink" title="什么是区块链"></a>什么是区块链</h3><p>区块链实际是一种去中心化的分布式数据库（记账系统）。</p><p>区块链的主要特点：</p><ul><li>去中心化：无中心节点，系统内节点的权利和义务是均等的</li><li>集体维护：系统中数据块由整个系统中所有节点共同维护</li><li>高度透明：源代码开源，保证了记账和规则的公开透明</li><li>去信任：从技术上保证在没有第三方机构的情况交易的信任问题</li><li>匿名：由于信任问题不需要考虑，所以交易可以在匿名下进行</li></ul><h2 id="中心化"><a href="#中心化" class="headerlink" title="中心化"></a>中心化</h2><p>区块链本质上是一个去中心化的巨大账本数据库。作为比特币的底层技术，区块链是由一串使用密码学相关联所产生的数据块组成，每一个数据块中包含了多次比特币网络有效确认（一次有效交易检验被称为一次确认）的信息。</p><h2 id="集体维护"><a href="#集体维护" class="headerlink" title="集体维护"></a>集体维护</h2><p>随着交易不断产生，矿工需要不断创造新的区块来记录最新的交易，因此会导致这个帐本会一直增长延长。</p><p>每一个节点（每台连击到区块链网络上的电脑）都有一份完整的已有区块链备份记录，而且区块链上保留有所有关于每个节点的比特币交易信息，这些信息也被记录在完整的区块链上。</p><p>区块链帐本完全对外公开，这意味着区块链的区块生成和交易都可以自行查询。</p><p>新区块的生成将奖励给首次挖取次区块的矿工，这使得矿工有利可图，从而成为了矿工挖矿的主要动机。</p><blockquote><p>值得注意是：矿工挖矿会得到奖励，从而激励矿工不断挖矿，挖矿的过程中会记录交易信息从而不断重复这个过程。</p></blockquote><h2 id="去信任"><a href="#去信任" class="headerlink" title="去信任"></a>去信任</h2><p>首先，交易信息要写入到当前最先产生的区块中。</p><p>有了区块链之后，当一个用户想要进行历史交易的验证时，可以通过一系列基于密码学与数据结构学的运算追踪交易所属的区块，从而完成验证。</p><p>此外，对于随机数答案难度的调整可以控制新区块的生成速度；私钥的保密性可以保证和实现匿名交易；对于历史交易数据的剪枝可以实现硬盘空间的回收：经过中本聪的测算，经过完全剪枝的区块链数据一年只生成4.2MB的数据量。</p><p>区块链系统同任何一个数字系统一样，都离不开计算机硬件的支持。区块链集体记账的特点要求每个支持交易的节点都能够为系统提供计算能力，由此提出了一种鼓励节点竞相提供计算能力的机制<code>挖矿</code>。</p><p>每个节点接收到交易信息以后，生成新的区块并计算该区块的随机数答案，最快得到答案的节点将促成这笔交易的实现，完成交易的区块记录，并将该区块广播至所有节点。同时该节点将有可能获得一枚新的电子货币作为奖励。由于其过程很像矿工挖矿，因此节点提供算力的过程也叫作挖矿。通过挖矿，可以强制性保证块链中的数据按时间顺序存储，保持比特币网络的中立性，且允许比特币网络上不同的计算机对系统状态达成一致。</p><h2 id="区块链原理"><a href="#区块链原理" class="headerlink" title="区块链原理"></a>区块链原理</h2><p>区块链是由多个区块构成的一个链式结构。</p><h3 id="区块计算方式"><a href="#区块计算方式" class="headerlink" title="区块计算方式"></a>区块计算方式</h3><p>哈希值是固定长度的数值，用来标识唯一数据。</p><p>哈希通过将索引、前个哈希、时间戳、数据、随机数作为输入后计算得出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CryptoJS.SHA256(index + previousHash + timestamp + data + nonce)</span><br></pre></td></tr></table></figure><p>哈希值类似于：0000018035a828da0…</p><p>开头的四个 0 是有效哈希的基本要求，开头 0 的个数被称为难度值（difficulty），这就是众所周知的工作量证明系统（Proof-of-Work）。</p><h3 id="如何避免区块修改"><a href="#如何避免区块修改" class="headerlink" title="如何避免区块修改"></a>如何避免区块修改</h3><p>由于每一个块的哈希值都是根据前一个块来计算的，而且</p><p>如果我们有一个这样的区块链 A → B → C，有人想修改区块 A 上的数据。会发生下面情况：</p><p>修改区块 A 上的数据。<br>区块 A 的哈希变动，因为计算哈希所用的数据变化了。<br>区块 A 无效，因为它的哈希不是四个 0 开头。<br>区块 B 的哈希变动，因为计算区块 B 的哈希所用到的区块 A 的哈希值变化了。<br>区块 B 无效，因为它的哈希不是四个 0 开头。<br>区块 C 的哈希变动，因为计算区块 C 的哈希所用到的区块 B 的哈希值变化了。<br>区块 C 无效，因为它的哈希不是四个 0 开头。<br>修改一个区块的唯一方式就是重新开采这个区块以及它之后的所有区块。因为新的区块不断增加，基本不可能修改区块链。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><blockquote><p>比特币是有限的?</p></blockquote><p>由于比特币总值是有限的，所以不能允许无穷无尽的通过挖矿来新增比特币，所以协议设定的挖矿所得新币数目会逐渐减少，而且该设计也使得新币是按照约定速率而产生的。</p><p>那么问题来了，如果当所有块都被挖出后，比特币将无法进行交易，那剩下的比特币改怎样？</p><blockquote><p>怎么确保一份交易账单真实有效？</p></blockquote><p>如何在一个没有信任中心的系统中认证一个事情的真假？这里有个假定，就是好人比坏人多，即整个系统内百分之五十以上的人会严格遵守比特币协议的规则。比特币对交易是由矿工来确认的，也就是说我们认为好矿工比坏矿工多，对于错误的账单，好矿工都是会拒绝的。那么坏人就无法进行伪造、篡改。</p><p>比特币的交易认证包含两个事情：一是各路矿工对新区块数学难题的求解，一是全体同志对求解出答案的矿工的答案进行验证。</p><p>挖矿的难度设计出了一个基本固定的十分钟时间，当你提出一笔交易，接下来这十分钟时间内比特币系统对你的这笔交易申请进行验证，看看你是不是有这笔钱。矿工们会努力进行求解，第一个算得结果的人会把结果广播出去，让大家来评判对错，如果对的话，大家就会认可这笔交易。</p><p>账单的确认实际上是在试图向区块链添加新的区块，也就是要计算出新的区块。</p><blockquote><p>比特币的神秘发明人</p></blockquote><p>比特币的发明人一直是个迷。2009年一个网名叫中本聪的人在密码学邮件列表里发了一篇论文，讲述了这种不依赖于信任关系的金融交易系统，随后中本聪开发了第一款比特币系统。可是没人知道他的真实身份，他有意隐藏自己的一切身份信息。无数技术牛人试图通过各种方式寻找这个天才黑客数学家的线索，都没能如愿。</p><p>目前来讲，我们不知道他是一个人还是一个团队，不知道他所在的地区和时区，只知道他精通英语、数学、计算机。</p><blockquote><p>如何看点比特币的疯狂？</p></blockquote><p>荷兰郁金香也不过如此，都是人性的贪婪造成的现象。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://blog.jobbole.com/112551/" target="_blank" rel="noopener">http://blog.jobbole.com/112551/</a><br><a href="http://blog.jobbole.com/110860/" target="_blank" rel="noopener">http://blog.jobbole.com/110860/</a><br><a href="https://www.jianshu.com/p/214acff6c9bd" target="_blank" rel="noopener">https://www.jianshu.com/p/214acff6c9bd</a><br><a href="http://bitcoin-on-nodejs.ebookchain.org/1-%E4%BA%86%E8%A7%A3%E5%8A%A0%E5%AF%86%E8%B4%A7%E5%B8%81/5-%E5%8A%A0%E5%AF%86%E8%B4%A7%E5%B8%81%E5%B0%B1%E6%98%AF%E8%B4%A7%E5%B8%81.html" target="_blank" rel="noopener">http://bitcoin-on-nodejs.ebookchain.org/1-%E4%BA%86%E8%A7%A3%E5%8A%A0%E5%AF%86%E8%B4%A7%E5%B8%81/5-%E5%8A%A0%E5%AF%86%E8%B4%A7%E5%B8%81%E5%B0%B1%E6%98%AF%E8%B4%A7%E5%B8%81.html</a><br><a href="http://www.ruanyifeng.com/blog/2017/12/blockchain-tutorial.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2017/12/blockchain-tutorial.html</a><br><a href="http://lucky521.github.io/blog/design/2015/12/26/bitcoin.html#%E6%AF%94%E7%89%B9%E5%B8%81%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener">http://lucky521.github.io/blog/design/2015/12/26/bitcoin.html#%E6%AF%94%E7%89%B9%E5%B8%81%E5%8D%8F%E8%AE%AE</a><br><a href="https://www.jianshu.com/p/e710a389a3f1" target="_blank" rel="noopener">https://www.jianshu.com/p/e710a389a3f1</a><br><a href="https://program-think.blogspot.com/2017/08/GFW-Resilio-Sync.html" target="_blank" rel="noopener">https://program-think.blogspot.com/2017/08/GFW-Resilio-Sync.html</a><br><a href="https://program-think.blogspot.com/2017/09/Introduction-DHT-Kademlia-Chord.html" target="_blank" rel="noopener">https://program-think.blogspot.com/2017/09/Introduction-DHT-Kademlia-Chord.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单介绍区块链技术。&lt;/p&gt;
    
    </summary>
    
      <category term="计算机原理" scheme="http://simyy.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="区块链" scheme="http://simyy.cn/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="计算机原理" scheme="http://simyy.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 事务和索引</title>
    <link href="http://simyy.cn/2017/12/07/db-lock-index/"/>
    <id>http://simyy.cn/2017/12/07/db-lock-index/</id>
    <published>2017-12-07T10:03:48.000Z</published>
    <updated>2019-12-17T02:24:47.146Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录下对事务隔离的理解。</p><a id="more"></a><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>存储引擎<code>InnoDB</code>支持<code>事务</code>、<code>行级锁</code>。</p><h2 id="并发问题"><a href="#并发问题" class="headerlink" title="并发问题"></a>并发问题</h2><p>当两个事务同时进行的时候，两者之间互相不知道对方的存在，对自身所处的环境过分乐观，从而没有对操作的数据做一定的保护处理，导致出现以下问题：</p><p><code>更新丢失</code>：两个事务同时读取某一数据，但不同时进行更新操作，导致数据被覆盖的问题（重点在于<code>覆盖更新</code>）。</p><p><code>脏读</code>：一个事务修改了数据但是没有提交，另外一个事务会读取到这些未被提交的数据（重点在于<code>读取未提交的数据</code>）。</p><p><code>不可重复读</code>：一个事务在执行的过程中由于其他事务提交了新数据导致前后两次读取的内容不同（重点在于<code>两次读取内容的不同</code>）。</p><p><code>幻读</code>：一个事务由于其他事务同时的插入或删除造成按照相同条件的两次检索结果不同（重点在于<code>读取条数的不同</code>）。</p><h2 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h2><p><code>InnoDB</code>支持四种隔离级别：</p><ul><li><code>未提交读（read uncommited）</code></li><li><code>提交读（read commited）</code></li><li><code>可重复读（repeatable read）</code></li><li><code>串行化（serializable）</code></li></ul><blockquote><p>默认隔离级别为<code>可重复读</code>。</p></blockquote><p>四个隔离级别逐渐增强。</p><p><code>更新丢失</code>：可以通过CAS（对数据添加对应的版本）来实现数据的更新，当发现数据版本发生变化，则可触发回滚操作。</p><p><code>提交读</code>及以上隔离级别设定，一个事务只能读取另一个事务已经提交的数据，就避免了上面的脏读现象。</p><blockquote><p><code>提交读</code>是通过只读取提交后的数据来避免脏读问题。</p></blockquote><p><code>InnoDB</code>的<code>可重复读</code>并<code>不保证</code>避免<code>幻读</code>，需要应用使用<code>加锁读</code>来保证。而这个加锁度使用到的机制就是<code>next-keylocks</code>,<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM t_bitfly LOCK IN SHARE MODE;</span><br></pre></td></tr></table></figure></p><h2 id="next-key-lock"><a href="#next-key-lock" class="headerlink" title="next-key lock"></a>next-key lock</h2><p><code>InnoDB</code>支持的锁的类型包括：<code>共享锁S</code>、<code>排他锁X</code>、<code>意向共享IS</code>、<code>意向排他IX</code>。</p><blockquote><p>为了方便检查表级锁和行级锁之间的冲突，引入了意向锁。<br>意向锁是表锁，仅仅代表要对某行记录进行操作，只有在对行加锁时，才会判断是否冲突。</p></blockquote><p><code>InnoDB</code>中行锁的算法包括：</p><ul><li><code>record lock</code>：当个行记录上的锁；</li><li><code>gap lock</code>：间隙锁，锁定一个范围（<code>不包括记录本身</code>），为了避免幻读现象（保证同一事物两次读取内容系那个痛）；</li><li><code>next-key lock</code>：锁定一个范围，并且<code>锁定记录本身</code>，解决幻读问题。</li></ul><blockquote><p>间隙锁的区间是右闭区间，例如[1, 5)。</p></blockquote><p>具体例子可以<a href="http://www.cnblogs.com/zhoujinyi/p/3435982.html" target="_blank" rel="noopener">查看</a>。</p><h3 id="普通索引"><a href="#普通索引" class="headerlink" title="普通索引"></a>普通索引</h3><p>对于普通的索引(a)来说，<code>InnoDB</code>的行查询都采用了<code>next-key lock</code>算法，锁定不是单个值，而是一个范围（间隙）。</p><p>例如，如果表中已有[1, 3, 5, 8, 11]，那么所有的间隙如下，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(-无穷, 1] (1, 3] (3, 5] (5, 8] (8, 11] (11, +无穷]</span><br></pre></td></tr></table></figure></p><p>当执行三个事务如下，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">事务A：会锁住8的上下间隙，(5, 8] (8, 11]</span><br><span class="line">select * from t where a = 8 for update;</span><br><span class="line"></span><br><span class="line">事务B： 正常运行</span><br><span class="line">insert into t values(2);</span><br><span class="line"></span><br><span class="line">事务C：由于该范围被锁住，阻塞</span><br><span class="line">insert into t values(11);</span><br></pre></td></tr></table></figure></p><h3 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h3><p>对于唯一索引，<code>next-key lock</code>会做优化，将锁降级为<code>record lock</code>，也就是行锁，仅仅锁定行本身而不是范围。</p><p>因此，如果a为唯一索引(primary or unique)时，事务B和事务C将正常运行。</p><p>对于主键或唯一索引来说，如果锁定的是不存在的值，也会产品间隙锁。</p><h3 id="索引实现"><a href="#索引实现" class="headerlink" title="索引实现"></a>索引实现</h3><p>Btree（B+Tree）</p><p>参考：<a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html" target="_blank" rel="noopener">http://blog.codinglabs.org/articles/theory-of-mysql-index.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文记录下对事务隔离的理解。&lt;/p&gt;
    
    </summary>
    
      <category term="中间件" scheme="http://simyy.cn/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
      <category term="MySQL" scheme="http://simyy.cn/tags/MySQL/"/>
    
      <category term="数据库" scheme="http://simyy.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="中间件" scheme="http://simyy.cn/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>分布式事务</title>
    <link href="http://simyy.cn/2017/05/20/distributed-transaction/"/>
    <id>http://simyy.cn/2017/05/20/distributed-transaction/</id>
    <published>2017-05-20T09:40:21.000Z</published>
    <updated>2019-12-17T02:24:48.248Z</updated>
    
    <content type="html"><![CDATA[<p>简单总结下分布式事务相关二段式、三段式提交以及Paxos算法。<br><a id="more"></a></p><h2 id="分布式系统的一致性"><a href="#分布式系统的一致性" class="headerlink" title="分布式系统的一致性"></a>分布式系统的一致性</h2><p>在分布式领域中，任何一个分布式系统都无法同时满足<code>一致性</code>、<code>可用性</code>和<code>容错性</code>（也就是CAP理论）。</p><p>一般来说系统权衡的结果是达到系统的<code>最终一致</code>，而非强一致性。</p><blockquote><p>分布式系统中数据不一致的问题？</p></blockquote><p>为了提高系统的整体性能，往往采用多机进行分布式部署，为了达到数据的同步必然存在着<code>数据复制</code>。但是数据复制在不同的数据节点之间由于网络等异常原因很容易造成数据不一致的情况。</p><h3 id="一致性模型"><a href="#一致性模型" class="headerlink" title="一致性模型"></a>一致性模型</h3><p>一致性模型可以分为三种：</p><ul><li><code>强一致性</code>：当更新操作完成后，任何后续操作访问的结果都是最新更新的值；</li><li><code>弱一致性</code>：当更新操作完成后，系统不保证后续操作访问的结构都一致，但会尽可能保证在某个时间点可以让数据达到一致；</li><li><code>最终一致性</code>：可以保证最终数据会达到一致。</li></ul><h2 id="二段式提交"><a href="#二段式提交" class="headerlink" title="二段式提交"></a>二段式提交</h2><p>二段式提交协议主要保证分布式事务的<code>原子性</code>（保证所有节点的操作一致），为了达到操作的一致引入了一个协调者来掌管所有节点。</p><p>二段式提交可以分为两个阶段：<code>准备阶段</code>和<code>提交阶段</code>。</p><p><code>准备阶段</code>：是一个投票的过程，步骤如下，</p><ul><li>协调者向所有节点询问是否提交操作，等带所有参与节点响应；</li><li>参与者执行询问发起为止的所有事务操作（已经执行了事务），并把是否执行信息写入日志；</li><li>各个参与者向协调者回复询问结果（如果执行成功返回同意，否则返回终止）。</li></ul><p><code>提交阶段</code>：是一个确认的过程，步骤如下，</p><ul><li>协调者接收到参与者的询问结果，如果包含终止结果，则需要对所有参与者发送回滚操作，否则向所有参与者发送提交命令；</li><li>参与者接受者接收到完成操作，释放整个事务期间占用的资源；</li><li>协调者接受到所有参与者完成操作，完成事务。</li></ul><blockquote><p>缺点？</p></blockquote><ul><li><code>同步阻塞</code>：所有参与者都是事务阻塞型的，当参与者占用公共资源时，其他节点在访问该公共资源的时候不得不阻塞等待。</li><li><code>单点故障</code>：协调者管理所有参与节点，如果协调者异常，参与者都会一直阻塞下去。</li><li><code>数据不一致</code>：对于提交阶段，如果协调者和参与者出现网络问题，参与者无法正常完成事务。</li></ul><h2 id="三段式提交"><a href="#三段式提交" class="headerlink" title="三段式提交"></a>三段式提交</h2><p><code>三段式提交</code>是二段式提交的改进版，主要不同在于：</p><ul><li>引入超时机制（协调者和参与者）</li><li>增加了一个询问阶段（但不会执行）</li></ul><p>三个阶段：</p><ul><li><code>can commit</code>：协调者询问参与者是否可以执行事务(投票)</li><li><code>pre commit</code>：执行事务，并返回执行结果</li><li><code>do commit</code>：提交事务，完成</li></ul><p>为了避免阻塞，在提交阶段，如果协调者没有接收到参与者的回应，会执行<code>终止事务</code>，另外，如果参与者一直没有接收到协调者的操作命令，那么就会直接提交事务，但是这并不会避免<code>数据不一致</code>的问题。</p><h2 id="Paxos算法"><a href="#Paxos算法" class="headerlink" title="Paxos算法"></a>Paxos算法</h2><p><a href="http://www.csdn.net/article/2014-01-20/2818197-distributed-system/2" target="_blank" rel="noopener">http://www.csdn.net/article/2014-01-20/2818197-distributed-system/2</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单总结下分布式事务相关二段式、三段式提交以及Paxos算法。&lt;br&gt;
    
    </summary>
    
      <category term="架构" scheme="http://simyy.cn/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="分布式" scheme="http://simyy.cn/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="架构" scheme="http://simyy.cn/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Java threadlocal</title>
    <link href="http://simyy.cn/2017/04/16/java-threadlocal/"/>
    <id>http://simyy.cn/2017/04/16/java-threadlocal/</id>
    <published>2017-04-16T07:19:20.000Z</published>
    <updated>2019-12-17T02:30:46.235Z</updated>
    
    <content type="html"><![CDATA[<p>介绍Java中<code>threadlocal</code>的使用方法。<br><a id="more"></a></p><h3 id="threadlocal"><a href="#threadlocal" class="headerlink" title="threadlocal"></a>threadlocal</h3><p><code>threadlocal</code>主要解决的是每个线程绑定自己的值，也就是说保证相同变量在不同线程的<code>隔离性</code>。</p><p><code>threadlocal</code>保证每一个使用该变量的线程都提供一个变量值得副本，每一个副本的改动不会影响其他副本的值。</p><h3 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h3><p>默认情况下，初始化的<code>threadlocal</code>值为<code>null</code>，通过继承<code>threadlocal</code>并重写<code>initialValue</code>实现覆盖初始值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadLocal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal1</span> <span class="keyword">extends</span> <span class="title">ThreadLocal</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Object <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"default value"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ThreadLocal1 t1 = <span class="keyword">new</span> ThreadLocal1();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SimpleDateFormat安全格式化"><a href="#SimpleDateFormat安全格式化" class="headerlink" title="SimpleDateFormat安全格式化"></a>SimpleDateFormat安全格式化</h3><p><code>SimpleDateFormat</code>类是用来对日期字符串进行解析和格式化输出。</p><p><code>DateFormat</code>和<code>SimpleDateFormat</code>类不都是线程安全的，在多线程环境下调用<code>format</code>和<code>parse</code>方法应该使用同步代码来避免问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DateUtil</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用静态变量来存储SimpleDateFormat</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  String <span class="title">formatDate</span><span class="params">(Date date)</span> <span class="keyword">throws</span> ParseException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sdf.format(date);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Date <span class="title">parse</span><span class="params">(String strDate)</span> <span class="keyword">throws</span> ParseException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sdf.parse(strDate);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSimpleDateFormatThreadSafe</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.join(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e1) &#123;</span><br><span class="line">                e1.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="keyword">this</span>.getName()+<span class="string">":"</span>+DateUtil.parse(<span class="string">"2013-05-24 06:02:20"</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">new</span> TestSimpleDateFormatThreadSafe().start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;Thread-1&quot; Exception in thread &quot;Thread-2&quot; java.lang.NumberFormatException: multiple points</span><br><span class="line">at sun.misc.FloatingDecimal.readJavaFormatString(FloatingDecimal.java:1890)</span><br><span class="line">Thread-0:Fri May 24 06:02:20 CST 2013</span><br><span class="line">at sun.misc.FloatingDecimal.parseDouble(FloatingDecimal.java:110)</span><br><span class="line">at java.lang.Double.parseDouble(Double.java:538)</span><br><span class="line">at java.text.DigitList.getDouble(DigitList.java:169)</span><br><span class="line">at java.text.DecimalFormat.parse(DecimalFormat.java:2056)</span><br><span class="line">at java.text.SimpleDateFormat.subParse(SimpleDateFormat.java:1869)</span><br><span class="line">at java.text.SimpleDateFormat.parse(SimpleDateFormat.java:1514)</span><br><span class="line">at java.text.DateFormat.parse(DateFormat.java:364)</span><br><span class="line">at MyThreadLocal$DateUtil.parse(MyThreadLocal.java:28)</span><br><span class="line">at MyThreadLocal$TestSimpleDateFormatThreadSafe.run(MyThreadLocal.java:42)</span><br></pre></td></tr></table></figure></p><p>这正是由于<code>非线程安全的SimpleDateFormat</code>造成的（<a href="http://www.cnblogs.com/peida/archive/2013/05/31/3070790.html" target="_blank" rel="noopener">详情</a>）。</p><p><strong>推荐方法</strong>：使用<code>threadlocal</code>对不同线程使用不同的<code>SimpleDateFormat</code>对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalDateUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String date_format = <span class="string">"yyyy-MM-dd HH:mm:ss"</span>;</span><br><span class="line">    <span class="comment">// 使用threadlocal来为不同线程生成相同参数的不同副本</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;DateFormat&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;DateFormat&gt;(); </span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DateFormat <span class="title">getDateFormat</span><span class="params">()</span>   </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        DateFormat df = threadLocal.get();  </span><br><span class="line">        <span class="comment">// 默认值为null, 可以继承threadlocal重写initialValue来实现默认值</span></span><br><span class="line">        <span class="keyword">if</span>(df==<span class="keyword">null</span>)&#123;  </span><br><span class="line">            df = <span class="keyword">new</span> SimpleDateFormat(date_format);  </span><br><span class="line">            threadLocal.set(df);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> df;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">formatDate</span><span class="params">(Date date)</span> <span class="keyword">throws</span> ParseException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getDateFormat().format(date);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Date <span class="title">parse</span><span class="params">(String strDate)</span> <span class="keyword">throws</span> ParseException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getDateFormat().parse(strDate);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p><code>ThreadLocal</code>有一个<code>ThreadLocalMap</code>静态内部类，这个<code>Map</code>为每个线程复制一个变量的<code>拷贝</code>，每一个内部线程都有一个<code>ThreadLocalMap</code>对象。</p><p>当线程调用<code>ThreadLocal.set(T object)</code>方法设置变量时，</p><ul><li>获取当前<code>线程引用</code>，</li><li>获取线程内部的<code>ThreadLocalMap</code>对象</li><li>设置<code>map</code>的<code>key</code>值为<code>threadLocal</code>对象，<code>value</code>为参数中的<code>object</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当线程调用<code>ThreadLocal.get()</code>方法获取变量时，</p><ul><li>获取当前<code>线程引用</code></li><li>以<code>threadLocal</code>对象为<code>key</code>去获取响应的<code>ThreadLocalMap</code>，</li><li>如果此<code>Map</code>不存在则初始化一个，否则返回其中的变量</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个线程内部的<code>ThreadLocalMap</code>对象中的<code>key</code>保存的<code>threadLocal</code>对象的引用，但对<code>threadLocal</code>的对象的引用是<code>WeakReference弱引用</code>。</p><blockquote><p><code>ThreadLocalMap</code>是使用<code>ThreadLocal的弱引用</code>作为<code>Key</code>的，弱引用的对象在 <code>GC</code> 时会被回收。</p></blockquote><p>对于一个正常的<code>Map</code>来说，调用<code>Map.clear</code>方法来清空<code>map</code>，所有对象就会释放。调用<code>map.remove(key)</code>方法，会移除<code>key</code>对应的对象整个<code>entry</code>，这样key和value 就不会任何对象引用，被<code>java</code>虚拟机回收。</p><h3 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h3><blockquote><p>如何产生</p></blockquote><p><code>Thread</code>对象里面的<code>ThreadLocalMap</code>中的<code>key</code>是<code>ThreadLocal</code>的对象的<code>弱引用</code>，如果<code>ThreadLocal</code>对象会回收，那个这个对象对应的<code>key</code>就会变为<code>null</code>，那么<code>ThreadLocalMap</code>就无法移除其对应的<code>value</code>，那么<code>value</code>对象就无法被回收，导致<code>内存泄露</code>。</p><p>但是如果<code>Thread</code>运行结束，整个线程对象被回收，那么<code>value</code>所引用的对象也就会被垃圾回收。</p><p>对于没有使用<code>线程池</code>的方法来说，因为每次线程运行完就退出了，<code>Map</code>里面引用的所有对象都会被垃圾回收，所以没有关系。</p><blockquote><p>如何避免？</p></blockquote><p><code>ThreadLocalMap</code>的设计中已经考虑到这种情况，也加上了一些防护措施：在<code>ThreadLocal</code>的<code>get()</code>,<code>set()</code>,<code>remove()</code>的时候都会清除线程<code>ThreadLocalMap</code>里所有<code>key</code>为<code>null</code>的<code>value</code>。</p><hr><h2 id="2019-11-23-Update"><a href="#2019-11-23-Update" class="headerlink" title="2019/11/23 Update"></a>2019/11/23 Update</h2><h3 id="ThreadLocal存在的意义"><a href="#ThreadLocal存在的意义" class="headerlink" title="ThreadLocal存在的意义"></a>ThreadLocal存在的意义</h3><blockquote><p>首先，<code>ThreadLocal</code>可以解决哪些问题？</p></blockquote><ul><li>线程内部<code>上下文的传递</code>（替代参数传递）</li><li>多线程并发的<code>资源隔离</code>（临界资源）</li></ul><p><code>上下文的传递</code>看起来是没有太多的问题，但是在实际的应用场景下又很难确定<code>变量的作用域</code>，变量是何时赋值的、何时移除的，都是不能确定的，所以在使用过程中会带来很多不确定性。</p><blockquote><p><code>ThreadLocal</code>为线程提供了一套管理线程状态机制。</p></blockquote><p><code>ThreadLocal</code>拥有与线程同样的<code>生命周期</code>，从而拥有提供线程状态的能力。</p><p>常见的项目应用都是采用<code>贫血模型</code>，<code>贫血模型</code>是<code>无状态</code>的，实际上是一种过程化的设计。</p><hr><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.cnblogs.com/peida/archive/2013/05/31/3070790.html" target="_blank" rel="noopener">http://www.cnblogs.com/peida/archive/2013/05/31/3070790.html</a><br><a href="http://blog.xiaohansong.com/2016/08/06/ThreadLocal-memory-leak/?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="noopener">http://blog.xiaohansong.com/2016/08/06/ThreadLocal-memory-leak/?utm_source=tuicool&amp;utm_medium=referral</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍Java中&lt;code&gt;threadlocal&lt;/code&gt;的使用方法。&lt;br&gt;
    
    </summary>
    
      <category term="编程语言" scheme="http://simyy.cn/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="Java" scheme="http://simyy.cn/tags/Java/"/>
    
      <category term="编程语言" scheme="http://simyy.cn/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Java 多线程</title>
    <link href="http://simyy.cn/2017/04/12/java-thread/"/>
    <id>http://simyy.cn/2017/04/12/java-thread/</id>
    <published>2017-04-11T16:46:09.000Z</published>
    <updated>2019-12-17T02:30:45.795Z</updated>
    
    <content type="html"><![CDATA[<p>介绍Java中多线程。<br><a id="more"></a></p><h2 id="Runnable-amp-Thread"><a href="#Runnable-amp-Thread" class="headerlink" title="Runnable &amp; Thread"></a>Runnable &amp; Thread</h2><p><code>Thread</code>类中的<code>start</code>方法通知<code>线程规划器</code>此线程已经就绪，等待调用线程对象的<code>run</code>方法。</p><p>使用<code>run</code>方法是同步的，此线程对象并不会交给<code>线程规划器</code>来进行处理，而是由当前主线程来同步执行。</p><p>使用<code>start</code>方法是同步的，但系统调用<code>run</code>方法的过程是异步执行，因此线程执行与<code>start</code>的顺序是不一致的。</p><p><code>java</code>不支持多继承，对于已有父类的继承类来说，需要实现<code>Runnable</code>接口来实现线程类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableHello</span> <span class="keyword">extends</span> <span class="title">MyHello</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    RunnableHello runnableHello = <span class="keyword">new</span> RunnableHello();</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(runnableHello);</span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><p><code>synchronized</code>关键字能够保证在同一时刻最多只有一个线程执行该段代码。</p><p><code>synchronized</code>可用于标记<code>对象</code>、<code>代码块</code>、<code>函数</code>等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">synchronized(someObj) &#123; // dosomething &#125;</span><br><span class="line">sychronized(this) &#123; // dosomething&#125;</span><br><span class="line">synchronized public void method() &#123; // dosomething &#125;</span><br></pre></td></tr></table></figure><h2 id="interrupt"><a href="#interrupt" class="headerlink" title="interrupt"></a>interrupt</h2><p><code>interrupt</code>：用于停止当前线程，不会立刻停止，而是先给当前线程打一个中断标记。</p><p><code>interrupted</code>：测试当前线程是否已经中断状态，执行后清除状态标识为<code>false</code>。</p><p><code>isInterrupted</code>：测试当前线程是否已经中断状态，不清除状态标识。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 观察打印结果</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtendsThread1</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.isInterrupted()) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"interrupted"</span>);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ExtendsThread1 thread1 = <span class="keyword">new</span> ExtendsThread1();</span><br><span class="line">    thread1.start();</span><br><span class="line">    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    thread1.interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="suspend"><a href="#suspend" class="headerlink" title="suspend"></a>suspend</h2><p><code>suspend</code>用于暂停线程，但已经<code>废弃</code>了。</p><blockquote><p><code>废弃原因</code>：使用suspend和resume方法容易因为线程暂定导致数据不同步的情况，会造成死锁。</p></blockquote><h2 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h2><p><code>yeild</code>用于放弃当前占用的<code>CPU</code>资源，但放弃的时间不确定，下一次获得<code>CPU</code>的占用权的时间同样不能确定。</p><p><code>yeild</code>特性：</p><ul><li>静态的原生(<code>native</code>)方法；</li><li>状态切换的<code>非实时性</code>；</li><li>当前正在执行的线程把运行机会交给线程池中拥有<code>相同优先级</code>的线程；</li><li>它仅能使一个线程从运行状态转到<code>可运行状态</code>，而不是等待或阻塞状态。</li></ul><h2 id="priority"><a href="#priority" class="headerlink" title="priority"></a>priority</h2><p><code>setPriority</code>方法可以用来设置线程的优先级，优先级高的线程更容易获得<code>CPU的执行权</code>。</p><p><code>java</code>中线程优先级分为1~10，默认定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public final static int MIN_PRIORITY = 1;</span><br><span class="line">public final static int NORM_PRIORITY = 5;</span><br><span class="line">public final static int MAX_PRIORITY = 10;</span><br></pre></td></tr></table></figure></p><p>线程的优先级是<code>可继承的</code>。</p><h2 id="daemon"><a href="#daemon" class="headerlink" title="daemon"></a>daemon</h2><p><code>java</code>中可以通过<code>setDaemon</code>方法设置<code>守护线程</code>。</p><blockquote><p><code>守护线程</code>是一种特殊的线程，只有当JVM停止运行时，该线程才会被结束。例如，垃圾回收器就是一个用于回收内存对象的<code>守护线程</code>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍Java中多线程。&lt;br&gt;
    
    </summary>
    
      <category term="编程语言" scheme="http://simyy.cn/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="Java" scheme="http://simyy.cn/tags/Java/"/>
    
      <category term="多线程" scheme="http://simyy.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="编程语言" scheme="http://simyy.cn/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Java 异常</title>
    <link href="http://simyy.cn/2017/04/08/java-exception/"/>
    <id>http://simyy.cn/2017/04/08/java-exception/</id>
    <published>2017-04-08T14:30:12.000Z</published>
    <updated>2019-12-17T02:30:44.002Z</updated>
    
    <content type="html"><![CDATA[<p>介绍Java中的异常处理。<br><a id="more"></a></p><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p><code>java</code>中的异常可分为<code>检查的异常</code>和<code>非检查异常</code>。</p><p>在<code>java</code>中，异常的类层次结构如下，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">           Throwable</span><br><span class="line">         /          \</span><br><span class="line">    Error            Exception</span><br><span class="line">    /   \           /         \</span><br><span class="line">VMError AWTError  IOException  RuntimeException</span><br></pre></td></tr></table></figure></p><p>所有异常都是继承自<code>Throwable</code>，分为<code>Error</code>和<code>Exception</code>。</p><p><code>Error</code>一般是<code>JVM</code>问题导致，也就是说在应用程序控制和处理之外产生的，因此此类异常是<code>不可检查的</code>。</p><p><code>Exception</code>是程序自身产生的异常，是可以通过<code>try-catch</code>和<code>throws</code>来控制。</p><p><code>Exception</code>可被划分为非检查的<code>RuntimeException</code>和检查的<code>IOException</code>。</p><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><h3 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h3><p>在<code>java</code>中可以用<code>try-catch</code>语句来捕获异常（可捕获检查和非检查异常），<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">try &#123;  </span><br><span class="line">    // 可能会发生异常的程序代码  </span><br><span class="line">&#125; catch (Type1 id1)&#123;  </span><br><span class="line">    // 捕获并处置try抛出的异常类型Type1  </span><br><span class="line">&#125; catch (Type2 id2)&#123;  </span><br><span class="line">    // 捕获并处置try抛出的异常类型Type2  </span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    // 无论是否发生异常需要处理</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>异常是按照<code>catch</code>的顺序依次捕获的，所以需要按照继承关系来决定捕获顺序。</p><blockquote><p><code>finally</code>一般用来关闭一下IO操作，例如文件、网络连接。</p></blockquote><h2 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h2><p>在<code>java</code>中可以使用<code>throws</code>来抛出异常，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void method() throws Exception1, Exception2, ... &#123;</span><br><span class="line">    // 执行</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="throwable"><a href="#throwable" class="headerlink" title="throwable"></a>throwable</h2><p><code>throwable</code>作为异常处理的基类，常用的功能函数有,<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">getCause(); <span class="comment">// 获取异常原因</span></span><br><span class="line">getMessage(); <span class="comment">// 异常信息</span></span><br><span class="line">printStackTrace(); <span class="comment">// 堆栈跟踪异常信息</span></span><br></pre></td></tr></table></figure></p><blockquote><p>注意：<code>RuntimeException</code>不需要抛出，并不会造成编译错误。</p></blockquote><h2 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h2><p>通过继承<code>Exception</code>以及其子类可以实现自定义异常，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class MyException extends Exception &#123;</span><br><span class="line">    public MyException() &#123;&#125;</span><br><span class="line">    public MyException(String message) &#123;</span><br><span class="line">        super(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由于继承<code>Exception</code>，则需要接口处理该异常时添加<code>throws</code>指明抛出检查异常，否则无法编译通过。</p><p>如果是继承<code>RuntimeException</code>，则不需要指定<code>throws</code>抛出异常，但是需要注意外层对于该异常的处理方法，这种异常会被隐藏起来。</p><blockquote><p>如何选择异常类型，<code>检查</code> or <code>非检查</code>？</p></blockquote><p>设计异常一般有两种，内部使用和外部使用。</p><p>对于外部使用，也就是提供给调用方来处理的异常，一般是由于服务中依赖某不稳定的服务，提供服务方不能处理该异常，需要调用方自行处理该异常情况。</p><p>对于内部使用，也就是程序内部自定义的异常，一般是由于跳出当前逻辑处理，直接返回，那么，就需要在逻辑的最外层来统一处理该自定义异常。</p><h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><p>在使用异常来做控制流程处理的时候，一般有两种方式：<code>自定义异常</code>和<code>自定义返回结果</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 自定义异常</span><br><span class="line">class BizException extends RuntimeException &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">// 自定义返回结果</span><br><span class="line">class BizResult&lt;T&gt; extends ObjectInfo &#123; ... &#125;</span><br></pre></td></tr></table></figure></p><p>如果使用<code>自定义返回结果</code>，需要在每次调用函数时使用<code>if-else</code>来做判断，这样性能必然是<code>最好的</code>，但是在写业务逻辑的时候就会非常繁琐，每次调用都会添加一次<code>if-else</code>逻辑。</p><p>如果使用<code>自定义异常</code>，需要在调用服务的最外层都添加一个针对<code>自定义异常</code>的异常处理，业务逻辑看起来好一点，但是这样性能就会差一点。</p><blockquote><p>如何提高异常性能？</p></blockquote><p>在参考中的一篇文章中，有提到通过重写<code>fillInStackTrace</code>来提高性能，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public synchronized Throwable fillInStackTrace() &#123;</span><br><span class="line">    if (stackTrace != null ||</span><br><span class="line">        backtrace != null /* Out of protocol state */ ) &#123;</span><br><span class="line">        fillInStackTrace(0);</span><br><span class="line">        stackTrace = UNASSIGNED_STACK;</span><br><span class="line">    &#125;</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>fillInStackTrace</code>函数是一个同步的方法，在多线程的情况下必然会造成性能下降。在测试过程中发现，即使在单线程的情况下，仍然可以提升很大性能。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://niehan.blog.techweb.com.cn/archives/259.html" target="_blank" rel="noopener">http://niehan.blog.techweb.com.cn/archives/259.html</a><br><a href="http://blog.csdn.net/beijiguangyong/article/details/9080727" target="_blank" rel="noopener">http://blog.csdn.net/beijiguangyong/article/details/9080727</a><br><a href="http://www.blogjava.net/stone2083/archive/2010/07/09/325649.html" target="_blank" rel="noopener">http://www.blogjava.net/stone2083/archive/2010/07/09/325649.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍Java中的异常处理。&lt;br&gt;
    
    </summary>
    
      <category term="编程语言" scheme="http://simyy.cn/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="Java" scheme="http://simyy.cn/tags/Java/"/>
    
      <category term="编程语言" scheme="http://simyy.cn/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Python 序列</title>
    <link href="http://simyy.cn/2017/04/08/python-list/"/>
    <id>http://simyy.cn/2017/04/08/python-list/</id>
    <published>2017-04-08T09:27:46.000Z</published>
    <updated>2019-12-17T02:27:40.143Z</updated>
    
    <content type="html"><![CDATA[<p>序列<code>list</code>是python中最基本的数据结构，序列都可以进行的操作包括索引，切片，加，乘，检查成员。<br><a id="more"></a><br>列表生成式即List Comprehensions，是Python内置的非常简单却强大的可以用来创建list的生成式。</p><h2 id="一个循环"><a href="#一个循环" class="headerlink" title="一个循环"></a>一个循环</h2><p>在C语言等其他语言中，for循环一般是这样的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">x = list()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>)</span><br><span class="line">    x.append(x)</span><br><span class="line">```　　</span><br><span class="line"></span><br><span class="line">如果python也这么写，那么真该看下python的基础教程了~</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">x = [x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br></pre></td></tr></table></figure><p>　　<br>在上面的例子中，不仅可以嵌套for，甚至可以嵌套if语句</p><p>再看看，原来是什么样子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = [x for x in range(10) if x &gt; 5]</span><br></pre></td></tr></table></figure></p><p>　　</p><h2 id="两个循环呢？"><a href="#两个循环呢？" class="headerlink" title="两个循环呢？"></a>两个循环呢？</h2><p>原来可能是这样的？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x = list()</span><br><span class="line">for i in range(10):</span><br><span class="line">    for j in range(10):</span><br><span class="line">    x.append(i + j)</span><br><span class="line">```　　</span><br><span class="line"></span><br><span class="line">现在可以这样了！！！</span><br></pre></td></tr></table></figure><p>x = [x + y for x in range(10) for y in range(10)]<br><code>`</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;序列&lt;code&gt;list&lt;/code&gt;是python中最基本的数据结构，序列都可以进行的操作包括索引，切片，加，乘，检查成员。&lt;br&gt;
    
    </summary>
    
      <category term="编程语言" scheme="http://simyy.cn/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="Python" scheme="http://simyy.cn/tags/Python/"/>
    
      <category term="编程语言" scheme="http://simyy.cn/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Java 日志注解</title>
    <link href="http://simyy.cn/2017/04/08/java-anotion-log/"/>
    <id>http://simyy.cn/2017/04/08/java-anotion-log/</id>
    <published>2017-04-08T09:15:38.000Z</published>
    <updated>2019-12-17T02:30:42.609Z</updated>
    
    <content type="html"><![CDATA[<p>介绍如何使用Java注解来添加日志。<br><a id="more"></a></p><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><p><code>元注解</code>的作用是注解其他注解，</p><ul><li><p><code>@Target</code>用于描述注解范围。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CONSTRUCTOR:用于描述构造器</span><br><span class="line">FIELD:用于描述域</span><br><span class="line">LOCAL_VARIABLE:用于描述局部变量</span><br><span class="line">METHOD:用于描述方法</span><br><span class="line">PACKAGE:用于描述包</span><br><span class="line">PARAMETER:用于描述参数</span><br><span class="line">TYPE:用于描述类、接口(包括注解类型) 或enum声明</span><br></pre></td></tr></table></figure></li><li><p><code>@Retention</code>用于描述注解生命周期。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SOURCE:在源文件中有效（即源文件保留）</span><br><span class="line">CLASS:在class文件中有效（即class保留）</span><br><span class="line">RUNTIME:在运行时有效（即运行时保留），可以通过反射获取该注解的属性值</span><br></pre></td></tr></table></figure></li><li><p><code>@Documented</code>用于生命构建注解文档。</p></li><li><code>@Inherited</code>用于描述该注解是可被子类继承的。</li></ul><h3 id="注解格式"><a href="#注解格式" class="headerlink" title="注解格式"></a>注解格式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public @interface 注解名 &#123;定义体&#125;</span><br></pre></td></tr></table></figure><h2 id="日志注解"><a href="#日志注解" class="headerlink" title="日志注解"></a>日志注解</h2><p><code>Log</code>注解定义，参数包含<code>type</code>日志类型、<code>desc</code>日志描述、<code>throwable</code>是否catch异常、<code>withResult</code>是否记录打印结果。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(&#123; ElementType.METHOD, ElementType.PARAMETER &#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Log &#123;</span><br><span class="line">    <span class="function">String <span class="title">type</span><span class="params">()</span> <span class="keyword">default</span> LogConst.RUN_LOG</span>; </span><br><span class="line">    <span class="function">String <span class="title">desc</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">throwable</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">withResult</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>需要注意，注解的默认值必须是常量（不可以设置为枚举）</p></blockquote><p>那么常量如何定义？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogConst</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 日志类型</span></span><br><span class="line">    <span class="comment">/* 访问日志 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String ACCESS_LOG = <span class="string">"ACCESS"</span>;</span><br><span class="line">    <span class="comment">/* 事件日志 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String EVENT_LOG = <span class="string">"EVENT"</span>;</span><br><span class="line">    <span class="comment">/* 运行日志 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String RUN_LOG = <span class="string">"RUN"</span>;</span><br><span class="line">    <span class="comment">/* 异常日志 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String EXCP_LOG = <span class="string">"EXCEPTION"</span>;</span><br></pre></td></tr></table></figure></p><p>开启注解和<code>AOP配置</code>，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;context:annotation-config/&gt;</span><br><span class="line">&lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot;/&gt;</span><br></pre></td></tr></table></figure></p><blockquote><p>在注解中其实还可以做更多的事？在注解中我们可以增加异常监控，增加事件数量监控等等。</p></blockquote><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p>通过切片来获取当前获取被注释执行的函数情况，这里使用<code>aroundExec</code>来实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Aspect</span><br><span class="line">@Component</span><br><span class="line">public class LogAop &#123;</span><br><span class="line">@Around(value = &quot;@annotation(com.simyy.web.aop.Log)&quot;)</span><br><span class="line">public Object aroundExec(ProceedingJoinPoint pjp) throws Throwable &#123;</span><br><span class="line">    Method method = ((MethodSignature) pjp.getSignature()).getMethod();</span><br><span class="line">    String logType = method.getAnnotation(Log.class).type();</span><br><span class="line">    boolean throwable = method.getAnnotation(Log.class).throwable();</span><br><span class="line">    boolean withResult = method.getAnnotation(Log.class).withResult();</span><br><span class="line">    // 设置过无允许抛出异常或设置日志类型为异常日志</span><br><span class="line">    if (throwable == false || logType.equals(LogConst.EXCP_LOG)) &#123;</span><br><span class="line">        return withoutExpProcess(pjp, logType , withResult);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return withExpProcess(pjp, logType , withResult);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对于异常日志处理方式就是通过增加<code>try-catch</code>来捕获并记录日常情况。<br>其中，<code>getEmptyObjectByClassType</code>是用于在捕获异常后返回空对象或失败对象，<code>getContentByType</code>是用于按固定格式打印日志记录的函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">private Object withoutExpProcess(ProceedingJoinPoint pjp, String logType, boolean withResult) throws Throwable &#123;</span><br><span class="line">    Object[] args = pjp.getArgs();</span><br><span class="line">    Method method = ((MethodSignature) pjp.getSignature()).getMethod();</span><br><span class="line">    Class returnType = ((MethodSignature) pjp.getSignature()).getReturnType();</span><br><span class="line"></span><br><span class="line">    Long start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    Object retVal;</span><br><span class="line">    Exception exp = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        retVal = pjp.proceed();</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        retVal = getEmptyObjectByClassType(returnType);</span><br><span class="line">        exp = e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (exp == null) &#123;</span><br><span class="line">        // 异常日志类型不需要捕获正常运行记录，因此直接返回</span><br><span class="line">        if (logType.equals(LogConst.EXCP_LOG)) &#123;</span><br><span class="line">            return retVal;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Long useTime = System.currentTimeMillis() - start;</span><br><span class="line">        String afterLog;</span><br><span class="line">        if (withResult == true) &#123;</span><br><span class="line">            afterLog = getContentByType(AFTER_WITH_RESULT, method, args, useTime, retVal);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            afterLog = getContentByType(AFTER, method, args, useTime, retVal);</span><br><span class="line">        &#125;</span><br><span class="line">        LOGGER.info(afterLog);</span><br><span class="line"></span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        String errorLog = getContentByType(ERROR, method, args, null, null);</span><br><span class="line">        LOGGER.error(errorLog, exp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return retVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>相反，对于不需要捕获异常的运行日志，只需要记录访问情况，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private Object withExpProcess(ProceedingJoinPoint pjp, String logType, boolean withResult) throws Throwable &#123;</span><br><span class="line">    Object[] args = pjp.getArgs();</span><br><span class="line">    Method method = ((MethodSignature) pjp.getSignature()).getMethod();</span><br><span class="line">    Class returnType = ((MethodSignature) pjp.getSignature()).getReturnType();</span><br><span class="line"></span><br><span class="line">    Long start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    String beforeLog = getContentByType(BEFORE, method, args, null, null);</span><br><span class="line">    LOGGER.info(beforeLog);</span><br><span class="line"></span><br><span class="line">    Object retVal = pjp.proceed();</span><br><span class="line"></span><br><span class="line">    Long useTime = System.currentTimeMillis() - start;</span><br><span class="line">    if (withResult == true) &#123;</span><br><span class="line">        String afterLog = getContentByType(AFTER_WITH_RESULT, method, args, useTime, retVal);</span><br><span class="line">        LOGGER.info(afterLog);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return retVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>用于返回空对象的函数,<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">private Object getEmptyObjectByClassType(Class classType) &#123;</span><br><span class="line">    if (classType.equals(List.class)) &#123;</span><br><span class="line">        return Collections.EMPTY_LIST;</span><br><span class="line">    &#125;</span><br><span class="line">    if (classType.equals(Map.class)) &#123;</span><br><span class="line">        return Collections.EMPTY_MAP;</span><br><span class="line">    &#125;</span><br><span class="line">    if (classType.equals(Set.class)) &#123;</span><br><span class="line">        return Collections.EMPTY_SET;</span><br><span class="line">    &#125;</span><br><span class="line">    if (classType.equals(boolean.class) || classType.equals(Boolean.class)) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    // 对于特殊的执行result对象需要特殊处理</span><br><span class="line">    // do somethind</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>定义日志打印格式用于<code>getContentByType</code>函数，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private final String BEFORE_TMPL = &quot;TYPE=[%s] DESC=[%s] METHOD=[%s] PARAMS=[%s]&quot;;</span><br><span class="line">private final String AFTER_TMPL = &quot;TYPE=[%s] DESC=[%s] METHOD=[%s] PARAMS=[%s] TIME=[%d ms]&quot;;</span><br><span class="line">private final String AFTER_TMPL_WITH_RESULT = &quot;TYPE=[%s] DESC=[%s] METHOD=[%s] PARAMS=[%s] TIME=[%d ms] RESULT=[%s]&quot;;</span><br><span class="line">private final String ERROR_TMPL = BEFORE_TMPL;</span><br><span class="line"></span><br><span class="line">// 获取当前类名+函数名称</span><br><span class="line">private String getClassAndMethodName(Method method) &#123;</span><br><span class="line">    String methodName = method.getName();</span><br><span class="line">    String className = method.getDeclaringClass().getSimpleName();</span><br><span class="line">    return className + &quot;.&quot; + methodName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="More"><a href="#More" class="headerlink" title="More"></a>More</h2><p>日志采用<code>异步</code>打印提高性能；<br>增加异常监控或重要事件处理<code>监控方案</code>；<br>毕竟反射还是带来一定的<code>性能损耗</code>。<br>对于异常error的代码行这样会丢失，那可以通过<code>Throable.getStackTrace()</code>方法获取运行栈进行分析获取需要的错误行和错误原因。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍如何使用Java注解来添加日志。&lt;br&gt;
    
    </summary>
    
      <category term="编程语言" scheme="http://simyy.cn/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="Java" scheme="http://simyy.cn/tags/Java/"/>
    
      <category term="编程语言" scheme="http://simyy.cn/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
</feed>
