<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>InnoDB Locking | simyy</title>
  <meta name="viewport" content="width=device-width">
  <meta name="description" content="翻译 &amp;amp; 理解。">
<meta name="keywords" content="MySQL,数据库,中间件,锁">
<meta property="og:type" content="article">
<meta property="og:title" content="InnoDB Locking">
<meta property="og:url" content="http://simyy.cn/2020/08/08/mysql-innodb-lock/index.html">
<meta property="og:site_name" content="simyy">
<meta property="og:description" content="翻译 &amp;amp; 理解。">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2020-08-12T09:04:32.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="InnoDB Locking">
<meta name="twitter:description" content="翻译 &amp;amp; 理解。">
  
    <link rel="alternative" href="/atom.xml" title="simyy" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
</head></html>
<script src="/js/hexo_resize_image.js"></script>
<body>
  <div id="container">
    <div class="mobile-nav-panel">
	<i class="icon-reorder icon-large"></i>
</div>
<header id="header">
	<h1 class="blog-title">
		<a href="/">simyy</a>
	</h1>
	<nav class="nav">
		<ul>
			<li><a href="/">主页</a></li><li><a href="/2014/07/07/book-list">书单</a></li><li><a href="/archives">归档</a></li><li><a href="/tags">标签</a></li>
			<li><a id="nav-search-btn" class="nav-icon" title="Search"></a></li>
			<li><a href="/atom.xml" id="nav-rss-link" class="nav-icon" title="RSS Feed"></a></li>
		</ul>
	</nav>
	<div id="search-form-wrap">
		<form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://simyy.cn"></form>
	</div>
</header>
    <!--div id="main"-->
      <div id="main">


<article id="post-mysql-innodb-lock" class="post">
	<footer class="entry-meta-header">
		<span class="meta-elements date">
			<a href="/2020/08/08/mysql-innodb-lock/" class="article-date">
  <time datetime="2020-08-08T09:44:57.000Z" itemprop="datePublished">2020-08-08</time>
</a>

		</span>
        <span class="tags">
	       	
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL/">MySQL</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/中间件/">中间件</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据库/">数据库</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/锁/">锁</a></li></ul>

		</span>
		<!--span class="meta-elements author">simyy</span-->
		<div class="commentscount">
			
		</div>
	</footer>
	
	<header class="entry-header">
		
  
    <h1 class="article-title entry-title" itemprop="name">
      InnoDB Locking
    </h1>
  

	</header>
	<div class="entry-content">
		
    	<p>翻译 &amp; 理解。</p>
<a id="more"></a>
<p><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html" target="_blank" rel="noopener">mysql v8.0 innodb locking</a></p>
<h3 id="Shared-and-Exclusive-Locks"><a href="#Shared-and-Exclusive-Locks" class="headerlink" title="Shared and Exclusive Locks"></a>Shared and Exclusive Locks</h3><p>InnoDB实现了两种标准的<code>行锁（row-level locks）</code>：</p>
<ul>
<li><p><strong>共享锁</strong>（<code>shared(S) locks</code>）允许持有该锁的事务<code>读取</code>数据行；</p>
</li>
<li><p><strong>排它锁</strong>（<code>exclusive(X) locks</code>）允许持有该锁的事务<code>更新或删除</code>数据行。</p>
</li>
</ul>
<blockquote>
<p>共享锁被称为共享的原因在于：多个事务可以同时持有共享锁，从而实现数据的并发读取。</p>
</blockquote>
<p>【例1】针对同一行数据r行，假设事务T1已持有该行的<code>共享锁</code>，则事务T2的请求加锁结果如下：</p>
<ul>
<li>如果事务T2尝试获取该行的<code>共享锁</code>，则会立即生效，此时，事务T1与事务T2均持有r行的共享锁；</li>
<li>如果事务T2尝试获取该行的<code>排它锁</code>，由于锁冲突，导致事务T2进入阻塞等待状态（直到事务T1释放锁）。</li>
</ul>
<p>【例2】针对同一行数据r行，假设事务T1已经持有该行的<code>排他锁</code>，则事务T2无论请求<code>共享锁</code>还是<code>排它锁</code>都会进入阻塞等待状态（直到事务T1释放锁）。</p>
<h3 id="Intention-Locks"><a href="#Intention-Locks" class="headerlink" title="Intention Locks"></a>Intention Locks</h3><p>InnoDB实现了<code>多粒度的锁（multiple granularity locking）</code>，用于支持行锁与表锁的共存。</p>
<p><code>意向锁（Intention Locks）</code>是<code>表锁（table-level locks）</code>，用于表示事务稍后需要哪种类型的锁(共享的或排他的)来锁定表中的某一行。</p>
<ul>
<li><strong>意向共享锁</strong>（<code>intention shared lock (IS)</code>）表示事务打算对表中的各个行设置<code>共享锁</code>；</li>
<li><strong>意向排他锁</strong>（<code>intention exclusive lock (IX)</code>）表示事务打算对表中的各个行设置<code>排他锁</code>。</li>
</ul>
<p><strong>意向锁与行锁的加锁规则</strong></p>
<ul>
<li>如果事务希望获取某行的<code>S锁（row-level locks）</code>之前，必须先获取表上的<code>IS锁（table-level locks）或更强的锁</code>;</li>
<li>如果事务希望获取某行的<code>X锁（row-level locks）</code>之前，必须先获取表上的<code>IX锁（table-level locks）</code>。</li>
</ul>
<p><strong>意向锁与表锁之间的兼容规则</strong></p>
<table>
<thead>
<tr>
<th>-</th>
<th>X</th>
<th>IX</th>
<th>S</th>
<th>IS</th>
</tr>
</thead>
<tbody>
<tr>
<td>X</td>
<td>Conflict</td>
<td>Conflict</td>
<td>Conflict</td>
<td>Conflict</td>
</tr>
<tr>
<td>IX</td>
<td>Conflict</td>
<td>Compatible</td>
<td>Conflict</td>
<td>Compatible</td>
</tr>
<tr>
<td>S</td>
<td>Conflict</td>
<td>Conflict</td>
<td>Compatible</td>
<td>Compatible</td>
</tr>
<tr>
<td>IS</td>
<td>Conflict</td>
<td>Compatible</td>
<td>Compatible</td>
<td>Compatible</td>
</tr>
</tbody>
</table>
<p>【例】如果事务T1已经持有<code>表的IX锁</code>，则事务T2获取不同<code>表锁</code>的结果如下：</p>
<ul>
<li>如果事务T2尝试获取<code>X锁或S锁</code>，则会造成锁冲突，事务T2进入阻塞等待（直到事务T1释放表的IX锁）；</li>
<li>如果事务T2尝试获取<code>IX锁或IS锁</code>，由于兼容规则，事务T2可以正常获取<code>IX锁或IS锁</code>。</li>
</ul>
<blockquote>
<p>注意<code>意向锁</code>与<code>表锁</code>、<code>行锁</code>的兼容规则的不同。</p>
</blockquote>
<hr>
<p>以下为用于测试初始化的SQL语句，</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 建表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`c`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`d`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`C`</span>(<span class="string">`C`</span>),</span><br><span class="line">  <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> <span class="string">`d`</span> (<span class="string">`d`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4 <span class="keyword">COLLATE</span>=utf8mb4_general_ci;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`test`</span>.<span class="string">`t`</span>(<span class="string">`id`</span>, <span class="string">`c`</span>, <span class="string">`d`</span>) <span class="keyword">VALUES</span> (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`test`</span>.<span class="string">`t`</span>(<span class="string">`id`</span>, <span class="string">`c`</span>, <span class="string">`d`</span>) <span class="keyword">VALUES</span> (<span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`test`</span>.<span class="string">`t`</span>(<span class="string">`id`</span>, <span class="string">`c`</span>, <span class="string">`d`</span>) <span class="keyword">VALUES</span> (<span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="Record-Locks"><a href="#Record-Locks" class="headerlink" title="Record Locks"></a>Record Locks</h3><p><code>记录锁（record locks）</code>是索引上的一种行锁。</p>
<p>如下面的sql，会对<code>c1=10</code>的行设置<code>记录锁record lock</code>，阻止其他事务对<code>id=0</code>的行进行<code>插入、更新、删除</code>。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">0</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>
<h4 id="Clustered-and-Secondary-Indexes"><a href="#Clustered-and-Secondary-Indexes" class="headerlink" title="Clustered and Secondary Indexes"></a>Clustered and Secondary Indexes</h4><blockquote>
<p><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-index-types.html" target="_blank" rel="noopener">mysql v8.0 Clustered and Secondary Indexes</a></p>
</blockquote>
<p>InnoDB使用<code>聚簇索引（clustered index）</code>来存储数据，该索引的构建方式如下：</p>
<p>① InnoDB使用表中显示的<code>主键（primary key）</code>来构建聚簇索引；</p>
<p>② 如果没有主键，InnoDB会尝试寻找一个<code>非空（NOT NULL）</code>的<code>唯一索引（UNIQUE INDEX）</code>来构建聚簇索引；</p>
<p>③ 如果表没有主键且没有非空的唯一索引，InnoDB会为表生成一个<code>隐式的ROW-ID</code>的自增字段，构建名为<code>GEN_CLUST_INDEX</code>的聚簇索引。</p>
<h4 id="How-the-Clustered-Index-Speeds-Up-Queries"><a href="#How-the-Clustered-Index-Speeds-Up-Queries" class="headerlink" title="How the Clustered Index Speeds Up Queries"></a>How the Clustered Index Speeds Up Queries</h4><p>聚簇索引的特点在于<code>把所有的数据存储在叶子节点</code>，实现了<code>数据与索引的分离</code>。</p>
<p>正常来说，数据占用的空间往往远大于索引，考虑不同索引实现的场景：</p>
<p>【场景1】如果采用BTree来实现，由于BTree的数据与索引是存储在同一个节点上，所以：</p>
<ul>
<li>查询时可以直接从节点上获取数据，不需要遍历整棵树</li>
<li>每个节点上存储的索引有限，当遇到深层次遍历时会触发大量的磁盘IO</li>
<li>范围查询性能差，需要再次遍历也子节点</li>
</ul>
<p>【场景2】如果采用B+Tree来实现，由于B+Tree的数据与索引是分离的，所以：</p>
<ul>
<li>查询时需要遍历整棵数才可以到叶子节点获取数据</li>
<li>非叶子节点不存储数据从而可以存储更多的索引数据，当遇到深层次遍历时所触发的磁盘IO较少，从而拥有更好的性能</li>
<li>范围查询性能好，利用叶子节点的顺序链表来遍历查询</li>
</ul>
<h4 id="How-Secondary-Indexes-Relate-to-the-Clustered-Index"><a href="#How-Secondary-Indexes-Relate-to-the-Clustered-Index" class="headerlink" title="How Secondary Indexes Relate to the Clustered Index"></a>How Secondary Indexes Relate to the Clustered Index</h4><p>除了聚簇索引，其他搜索都被称为<code>二级索引</code>。</p>
<p>二级索引中不会包含行的所有数据，仅会包括关联行的主键。</p>
<p>也就是说，二级索引的检索过程为：先检索二级索引，找到目标行的主键索引KEY，然后在检索聚簇索引，最终找到目标行的数据。</p>
<p>由于二级索引需要关联聚簇索引的KEY，因此聚簇索引的主键选择上不应该选择过大的数据结构。</p>
<blockquote>
<p>有一点疑问：为什么二级索引不采用BTree实现？</p>
<p>如果采用BTree实现的话，指定的目标查询不会遍历到叶子节点，这是BTree的优势。<br>但是如果需要范围查询的时候，性能就不如B+Tree这种实现了，这应该是采用该索引的原因。</p>
<p>实际上，MySQL InnoDB可以设置两种索引类型：<code>Btree</code>和<code>Hash</code>，如果该索引不会有顺序查询，使用<code>Hash</code>索引更合适。</p>
</blockquote>
<h3 id="Gap-Locks"><a href="#Gap-Locks" class="headerlink" title="Gap Locks"></a>Gap Locks</h3><p><code>间隙锁（gap locks）</code>是对索引记录之间（两个记录之间、第一个记录之前、最后一个记录之后）间隙的锁。</p>
<p>间隙锁的作用在于<code>防止其他事务操作当前间隙内的数据</code>。</p>
<p>【例】下面的SQL会增加一个<code>间隙锁</code>，区间为(10, 20)，因此，其他事务无法在间隙内插入、更新或删除，例如插入15会被阻塞。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> c <span class="keyword">BETWEEN</span> <span class="number">10</span> <span class="keyword">and</span> <span class="number">20</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>针对不同的索引类型，会出现不同的加锁情况：</p>
<ul>
<li>对于<code>唯一索引(UNIQUE INDEX)</code>来说，锁定某行时仅需要<code>锁定数据行（不需要间隙锁的）</code>；</li>
<li>对于<code>普通索引（INDEX）</code>来说，锁定某行时不仅需要<code>锁定数据行</code>，还要<code>锁定前后间隙</code>；</li>
</ul>
</blockquote>
<p>对于测试数据来说，索引（不同字段之间数据值相同）存在的间隙有：<code>(-∞, 0)</code>、<code>(0, 5)</code>、<code>(5, 10)</code>、<code>(10, +∞)</code>。</p>
<blockquote>
<p>不同的事务的间隙锁可以共存（甚至X锁与S锁），例如，在区间(0, 5)上，事务A持有S锁，事务B持有X锁。</p>
</blockquote>
<p>在<code>读已提交（READ COMMITTED</code>）的隔离级别下，间隙锁不再用于搜索与索引扫描，仅用于外键约束检查和重复键检查。</p>
<h4 id="Case-1"><a href="#Case-1" class="headerlink" title="Case 1"></a>Case 1</h4><p>在初始化测试数据的条件下，考虑c为普通索引，加锁结果如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 事务A：加排它锁成功，间隙锁(0,5)与(5,10)、记录锁&#123;5&#125;</span></span><br><span class="line"><span class="comment"># 其中，间隙锁(5,10)是由于临键锁(5,10]降级而来，从5向右遍历发现10这个节点不满足=5，所以去除c=10的记录锁)</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> c=<span class="number">5</span> <span class="keyword">for</span> <span class="keyword">update</span>; <span class="comment"># ok</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 事务B：加插入意向锁失败，由于事务A持有间隙锁(0, 5)导致冲突</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span> (<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>); <span class="comment"># blocking</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 此时，事务B提示：lock_mode X locks gap before rec insert intention waiting Record lock</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 事务C：加插入意向锁成功失败，由于事务A持有间隙锁(0, 5)（临键锁(5, 10]降级而来）导致冲突</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span> (<span class="number">8</span>, <span class="number">8</span>, <span class="number">8</span>); <span class="comment"># blocking</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 此时，事务C提示：lock_mode X insert intention waiting Record lock</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 事务D：加插入意向锁成功，由于13不在锁定范围之内</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span> (<span class="number">13</span>, <span class="number">13</span>, <span class="number">13</span>); <span class="comment"># ok</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 事务E：加入排他锁失败，由于记录锁&#123;5&#125;的冲突</span></span><br><span class="line"><span class="keyword">update</span> t <span class="keyword">set</span> c=<span class="number">3</span> <span class="keyword">where</span> c=<span class="number">5</span>; <span class="comment"># blocking</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 此时，事务E提示：lock_mode X waiting Record lock</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 事务F：加入排它锁成功，由于c=10，没有加锁</span></span><br><span class="line"><span class="keyword">update</span> t <span class="keyword">set</span> c=<span class="number">99</span> <span class="keyword">where</span> c=<span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p><code>c=5</code>是一个普通索引的加锁行为，不仅对当前的行加记录锁，而且会对两侧的间隙加锁（左侧是间隙锁，右侧为临键锁）。</p>
<blockquote>
<p><strong>临键锁的退化</strong>：</p>
<p>① 在RR级别下，加锁的单位为<code>临键锁</code>；</p>
<p>② 针对二级索引的等值(c=5)的加锁情况，会按照索引顺序继续寻找不同的行，进而退化为<code>间隙锁</code>，例如<code>事务F</code>并没有阻塞。</p>
</blockquote>
<h4 id="Case-2"><a href="#Case-2" class="headerlink" title="Case 2"></a>Case 2</h4><p>在初始化测试数据的条件下，考虑c为普通索引，加锁结果如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 事务A：加排它锁成功，间隙锁(0, 5)、记录锁&#123;5&#125;、临键锁(5, 10]</span></span><br><span class="line"><span class="comment"># 注意，c between 0 and 5 为非等值查询，因此不存在临键锁的退化</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> c <span class="keyword">between</span> <span class="number">0</span> <span class="keyword">and</span> <span class="number">5</span> <span class="keyword">for</span> <span class="keyword">update</span>; <span class="comment"># ok</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 事务B：加排它锁失败，由于存在记录锁&#123;5&#125;的冲突</span></span><br><span class="line"><span class="keyword">update</span> t <span class="keyword">set</span> c=<span class="number">3</span> <span class="keyword">where</span> c=<span class="number">5</span>;  <span class="comment"># blocking</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 事务C：加插入意向锁失败，由于存在临键锁(5, 10]的冲突</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span> (<span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>); <span class="comment"># blocking</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 事务D：加排它锁失败，由于存在临键锁(5, 10])</span></span><br><span class="line"><span class="keyword">update</span> t <span class="keyword">set</span> c=<span class="number">99</span> <span class="keyword">where</span> c=<span class="number">10</span>; <span class="comment"># blocking</span></span><br></pre></td></tr></table></figure>
<p><code>between</code>类似于一个范围查询，会把范围内的都加锁（无论是行还是间隙）。</p>
<blockquote>
<p>注意事务D的语句会被blocking，也证明了非等值语句的情况下，临键锁是不会退化的。</p>
</blockquote>
<h3 id="Next-Key-Locks"><a href="#Next-Key-Locks" class="headerlink" title="Next-Key Locks"></a>Next-Key Locks</h3><p><code>临键锁（next-key locks）</code>是记录锁与间隙锁的一种组合，锁住索引记录以及索引记录之前的间隙（<code>(左开右闭的区间]</code>）。</p>
<blockquote>
<p>RR级别下，加锁的最小单元是<code>临键锁（next-key locks）</code>，都是按照左开右闭的区间来加锁的。</p>
<p>不过，也存在锁降级的情况：</p>
<p>① 唯一索引下，降级为行锁</p>
<p>② 普通索引下，如果是等值查询的话，第二个<code>临键锁（next-key locks）</code>会退化为<code>间隙锁（gap locks）</code>。</p>
</blockquote>
<p>对于测试数据中c索引来说，临键锁（不同字段之间数据值相同）的区间有：<code>(-∞, 0]</code>、<code>(0, 5]</code>、<code>(5, 10]</code>、<code>(10, +∞)</code>。</p>
<blockquote>
<p><strong>锁降级</strong>：唯一索引上，临键锁会降级为记录锁（不包括左右边缘）。</p>
</blockquote>
<p>临键锁仅发生在<code>可重复度（REPEATABLE READ ）</code>的隔离级别，主要解决了<code>幻读（phantom read）</code>。</p>
<h4 id="Case-1-1"><a href="#Case-1-1" class="headerlink" title="Case 1"></a>Case 1</h4><p>唯一索引上的锁降级情况如下，</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 事务A：加排他锁成功，记录锁&#123;5&#125;</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">5</span> <span class="keyword">for</span> <span class="keyword">update</span>; <span class="comment"># ok</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 事务B：加插入意向锁成功</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span> (<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>); <span class="comment"># ok</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 事务C：加插入意向锁成功</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span> (<span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>); <span class="comment"># ok</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 事务D：加排它锁失败，c=5 找到 id=5，由于记录锁导致加锁失败</span></span><br><span class="line"><span class="keyword">update</span> t <span class="keyword">where</span> c=<span class="number">99</span> <span class="keyword">where</span> c=<span class="number">5</span>; <span class="comment"># blocking</span></span><br></pre></td></tr></table></figure>
<h4 id="Case-2-1"><a href="#Case-2-1" class="headerlink" title="Case 2"></a>Case 2</h4><p>在RR隔离级别下，在测试数据初始化的条件下，考虑c为普通索引，锁操作如下，</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 事务A：加排它锁成功，间隙锁(0,5)与(5,10)、记录锁&#123;5&#125;</span></span><br><span class="line"><span class="comment"># 其中，间隙锁(5,10)是由于临键锁(5,10]降级而来，从5向右遍历发现10这个节点不满足=5，所以去除c=10的记录锁)</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> c=<span class="number">5</span> <span class="keyword">for</span> <span class="keyword">update</span>; <span class="comment"># ok</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 事务B：加排他锁失败，由于临间隙锁(5, 10)的冲突</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span> (<span class="number">8</span>, <span class="number">8</span>, <span class="number">8</span>); <span class="comment"># blocking</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 此时，事务B提示：lock_mode X locks gap before rec insert intention waiting</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 事务C：加排他锁失败，不存在锁冲突</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span> (<span class="number">13</span>, <span class="number">13</span>, <span class="number">13</span>); <span class="comment"># ok</span></span><br></pre></td></tr></table></figure>
<p><code>c=5</code>为普通索引上的加锁，包括间隙锁(0, 5)、记录锁{5}、间隙锁(5, 10)(等值查询情况下的锁退化)。</p>
<h4 id="Case-3"><a href="#Case-3" class="headerlink" title="Case 3"></a>Case 3</h4><p>在RR隔离级别下，在测试数据初始化的条件下，考虑d为唯一索引，锁操作如下，</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 事务A：加排他锁成功，记录锁&#123;5&#125;</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> d=<span class="number">5</span> <span class="keyword">for</span> <span class="keyword">update</span>; <span class="comment"># ok</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 事务B：加插入意向锁成功，无冲突</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span> (<span class="number">8</span>, <span class="number">8</span>, <span class="number">8</span>); <span class="comment"># ok</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 事务C：加插入意向锁成功，无冲突</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span> (<span class="number">13</span>, <span class="number">13</span>, <span class="number">13</span>); <span class="comment"># ok</span></span><br></pre></td></tr></table></figure>
<h4 id="Case-4"><a href="#Case-4" class="headerlink" title="Case 4"></a>Case 4</h4><p>在RR隔离级别下，在测试数据初始化的条件下，考虑c为普通索引，锁操作如下，</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 事务A：加排他锁成功，间隙锁(5, 10)，记录锁&#123;10&#125;，临键锁(10, +∞)</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> c &gt; <span class="number">8</span> <span class="keyword">for</span> <span class="keyword">update</span>; <span class="comment"># ok</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 事务B：加插入意向锁失败，由于存在临键锁(10, +∞)冲突</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span> (<span class="number">13</span>, <span class="number">13</span>, <span class="number">13</span>); <span class="comment"># blocking...</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 此时，事务B提示：lock_mode X insert intention waiting Record lock</span></span><br></pre></td></tr></table></figure>
<h4 id="Case-5"><a href="#Case-5" class="headerlink" title="Case 5"></a>Case 5</h4><p>在RR隔离级别下，在测试数据初始化的条件下，考虑d为唯一索引，锁操作如下，</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 事务A：加排他锁成功，间隙锁(5, 10), 记录锁&#123;10&#125;, 临键锁(10, +∞)</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> d &gt; <span class="number">8</span> <span class="keyword">for</span> <span class="keyword">update</span>; <span class="comment"># ok</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 事务B：加插入意向锁失败，由于存在间隙锁(5, 10)冲突</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span> (<span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>); <span class="comment"># blocking...</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 事务C：加插入意向锁失败，由于存在临键锁(10, +∞)冲突</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span> (<span class="number">13</span>, <span class="number">13</span>, <span class="number">13</span>); <span class="comment"># blocking...</span></span><br></pre></td></tr></table></figure>
<h3 id="Insert-Intention-Locks"><a href="#Insert-Intention-Locks" class="headerlink" title="Insert Intention Locks"></a>Insert Intention Locks</h3><p><code>插入意图锁（insert intention locks）</code>是一种间隙锁，当执行<code>插入（insert）</code>操作是触发。</p>
<p>【例1】以下SQL会加入插入意向锁，锁住的间隙是(0, 5)，</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<p><strong>多事务的插入意向锁</strong></p>
<p>考虑到插入意向锁是间隙锁，因此，不同事务的插入意向锁可以共存。</p>
<p>不同事务同时持有相同间隙的插入意向锁的情况下，如果插入的位置不同（值不同），此时各个事务会正常执行插入操作，</p>
<p>否则，如果出现插入到相同位置，该事务会一直等待，直到插入该位置的事务释放锁。</p>
<p>【例2】存在三个事务，分别在初始化的测试数据集上尝试写入数据，具体如下，</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 事务A：持有插入意向锁成功，锁定区间(0, 5)，此时会给3增加行锁</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span> (<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>) <span class="comment"># ok</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 事务B：持有插入意向锁成功，锁定区间(0, 5)，与事务A插入位置不同，所以无冲突，执行成功</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span> (<span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>) <span class="comment"># ok</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 事务C：由于事务A已经对于同一位置写入数据，由于3已经被A持有了行锁，因此，当前事务阻塞等待事务A的释放</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span> (<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>) <span class="comment"># blocking</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 此时，事务C提示：lock mode S waiting Record lock</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>上面发现，相同位置数据的数据会提示S锁，插入不应该是X锁么？</p>
<p>对于唯一索引来说，插入前需要先检查是否存在重复数据，此时X锁先会降级为S锁来实现当前读。</p>
</blockquote>
<h3 id="AUTO-INC-Locks"><a href="#AUTO-INC-Locks" class="headerlink" title="AUTO-INC Locks"></a>AUTO-INC Locks</h3><p><code>自增锁（auto-inc locks）</code>是<code>表锁（table-level locks）</code>，用于实现自增主键。</p>
<p>由于自增锁属于表锁，性能必然很差，因此，考虑到自增主键使用的场景，自增锁的锁定范围并不是整个事务，而是锁定的<code>insert sql</code>语句级别，</p>
<p>也就说，不同的事务之间，在<code>insert</code>时是交替完成的，虽然是表锁但对事务的并发插入并没有太大的影响。</p>
<h3 id="Phantom-Reads"><a href="#Phantom-Reads" class="headerlink" title="Phantom Reads"></a>Phantom Reads</h3><p><code>幻读（phantom reads）</code>是由于不同事务之间新增数据导致的前后数量不一致的问题。</p>
<blockquote>
<p><code>幻读</code>是insert引起的，<code>不可重复读</code>是由update或delete引起的。</p>
<p><code>幻读</code>产生原因在于新增的，<code>不可重复读</code>产生的原因在于更新。</p>
</blockquote>
<p>在RR隔离级别下，通过<code>临键锁（next-key locks）</code>解决了幻读。</p>
<blockquote>
<p><code>select for update</code>属于当前读（排它锁），而<code>select</code>属于快照读（无锁）。</p>
<p><code>select lock in share mode</code>属于共享锁，无法与排它锁共存。</p>
</blockquote>
<h4 id="Case-1-2"><a href="#Case-1-2" class="headerlink" title="Case 1"></a>Case 1</h4><p>即使InnoDB实现了MVCC解决了幻读的情况，但不同事务之间仍然存在先后插入数据的冲突问题。</p>
<p>在测试数据初始化的条件下，观察以下加锁结果：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 事务A：快照读，不会加锁</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">id</span> &gt; <span class="number">2</span>; <span class="comment"># ok</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 事务B：加插入意向锁成功，锁定id=3（记录锁）</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span> (<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>); <span class="comment"># ok</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 事务A：加插入意向锁失败，由于事务B已经持有id=3的记录锁</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span> (<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>);  <span class="comment"># blocking...</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 此时，事务A提示：lock mode S waiting Record lock</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 事务B：提交事务，写入id=3的数据</span></span><br><span class="line"><span class="keyword">commit</span>; <span class="comment"># ok</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 事务A：由于事务B已经提交事务，返回失败"Duplicate entry '3' for key 'PRIMARY'"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 事务A：失败后再次执行快照读（前后数据不变，观察不到事务B已经写入数据），虽然提示3已经写入，但还是观察不到</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">id</span> &gt; <span class="number">2</span>; <span class="comment"># ok</span></span><br></pre></td></tr></table></figure>
<h3 id="Dead-Locks"><a href="#Dead-Locks" class="headerlink" title="Dead Locks"></a>Dead Locks</h3><p><code>死锁（dead locks）</code>是由于多个事务相互持有互相等待的锁导致的。</p>
<h4 id="Case-1-3"><a href="#Case-1-3" class="headerlink" title="Case 1"></a>Case 1</h4><p><strong>insert-insert-insert-rollback 三个事务写入的场景下的死锁</strong></p>
<p>在测试数据初始化的条件下，观察以下加锁结果：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 事务A：加插入意向锁(0,5)，id=3的排他锁（X锁）</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span> (<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>); <span class="comment"># ok</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 事务B：加插入意向锁失败，优先获取S锁，查看数据是否存在，进入阻塞等待事务A的释放</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span> (<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>); <span class="comment"># blocking...</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 事务C：同上</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span> (<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>); <span class="comment"># blocking...</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 事务A：回滚，释放事务A上的锁</span></span><br><span class="line"><span class="keyword">rollback</span>; <span class="comment"># ok</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 此时，事务B与事务C同时持有S锁，都在等待对方释放S锁进而添加X锁（存在死锁）</span></span><br><span class="line"><span class="comment"># 最终结果：</span></span><br><span class="line"><span class="comment"># 事务C：加插入意向锁(0,5)，id=3的排他锁（X锁）</span></span><br><span class="line"><span class="comment"># 事务B：加锁失败，出现死锁，返回异常：Deadlock found when trying to get lock; try restarting transaction</span></span><br></pre></td></tr></table></figure>
<p>由于两个事务持有同一个记录的S锁，彼此等待对方释放S锁，进而进入死锁。</p>
<h4 id="Case-2-2"><a href="#Case-2-2" class="headerlink" title="Case 2"></a>Case 2</h4><p><strong>update-insert 两个事务写入重叠锁区间场景下的死锁</strong></p>
<p>在测试数据初始化的条件下，观察以下加锁结果：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 事务A：加排他锁成功，间隙锁(0,5)、记录锁&#123;5&#125;、临键锁(5, 10]</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> c=<span class="number">5</span> <span class="keyword">for</span> <span class="keyword">update</span>; <span class="comment"># ok</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 事务B：加排他锁成功，间隙锁(5,10)、记录锁&#123;10&#125;、临键锁(10, +∞)</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> c=<span class="number">10</span> <span class="keyword">for</span> <span class="keyword">update</span>; <span class="comment"># ok</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 此时，存在锁重叠，区间为(5, 10]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 事务A：加插入意向锁失败，由于事务B的间隙锁(5,10)冲突</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span> (<span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>); <span class="comment"># blocking</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 事务B：加插入意向锁失败，由于事务A的临键锁(5, 10]冲突</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span> (<span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>); <span class="comment"># Deadlock found when trying to get lock; try restarting transaction</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 事务A：加插入意向锁成功，由于事务A出现死锁。</span></span><br></pre></td></tr></table></figure>
<h4 id="Case-3-1"><a href="#Case-3-1" class="headerlink" title="Case 3"></a>Case 3</h4><p><strong>S X X</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 事务A：id=5 S锁</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">5</span> <span class="keyword">for</span> <span class="keyword">share</span>; <span class="comment"># ok</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 事务B：id=5 请求 X锁</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">5</span> <span class="keyword">for</span> <span class="keyword">update</span>; <span class="comment"># blocking</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 事务A：id=5 请求 X锁</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">5</span> <span class="keyword">for</span> <span class="keyword">update</span>; <span class="comment"># ok</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 事务B：Deadlock found when trying to get lock; try restarting transaction</span></span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 事务A：id=5 S锁</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">5</span> <span class="keyword">for</span> <span class="keyword">share</span>; <span class="comment"># ok</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 事务B：id=5 请求 X锁</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">5</span>; <span class="comment"># blocking</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 事务A：id=5 请求 X锁</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">5</span>; <span class="comment"># ok</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 事务B：Deadlock found when trying to get lock; try restarting transaction</span></span><br></pre></td></tr></table></figure>
<p>临键锁会分为两段加锁：<code>加间隙锁</code>与<code>加记录锁</code>。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 事务A：间隙锁(0, 5)(5, 10)，记录锁&#123;5&#125;</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> c=<span class="number">5</span> <span class="keyword">for</span> <span class="keyword">share</span>; <span class="comment"># ok</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 事务B：加间隙锁成功(0,5)(5,10)，加记录锁&#123;5&#125;冲突，等待</span></span><br><span class="line"><span class="keyword">update</span> t <span class="keyword">set</span> c=<span class="number">99</span> <span class="keyword">where</span> c=<span class="number">5</span>; <span class="comment"># blocking</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 事务A：由于事务B持有间隙锁，因此出现死锁，事务B异常退出</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span> (<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>); <span class="comment">#ok</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 事务B：Deadlock found when trying to get lock; try restarting transaction</span></span><br></pre></td></tr></table></figure>
<h3 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h3><p><code>limit</code>对加锁范围仍然有影响：<code>仅会对扫描到的数据范围进行加锁</code>。</p>
<h4 id="Case-1-4"><a href="#Case-1-4" class="headerlink" title="Case 1"></a>Case 1</h4><p>针对唯一索引的limit场景如下，</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 事务A：扫描id&gt;0的数据，由于limit仅为1，则仅会锁住id=5的这条数据</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">id</span> &gt; <span class="number">0</span> <span class="keyword">limit</span> <span class="number">1</span>; <span class="comment"># ok</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 事务B：</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">id</span> &gt; <span class="number">5</span> <span class="keyword">limit</span> <span class="number">1</span>; <span class="comment"># ok</span></span><br></pre></td></tr></table></figure>
<h4 id="Case-2-3"><a href="#Case-2-3" class="headerlink" title="Case 2"></a>Case 2</h4><p>针对非唯一索引的limit场景如下，</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 事务A：扫描c&gt;0的数据，由于limit仅为1，间隙锁(0, 5)，行锁&#123;5&#125; 由于limit1，不会锁住5后面的区间</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> t <span class="keyword">where</span> c &gt; <span class="number">0</span> <span class="keyword">limit</span> <span class="number">1</span>; <span class="comment"># ok</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 事务B：由于事务A存在间隙锁(0, 5)，加锁失败</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span> (<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>); <span class="comment"># blocking</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 事务C：无锁冲突，加锁成功</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> t <span class="keyword">where</span> c &gt; <span class="number">5</span> <span class="keyword">limit</span> <span class="number">1</span>; <span class="comment"># ok</span></span><br></pre></td></tr></table></figure>
<h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p>数据库上的锁都是为了避免数据并发更新导致的问题，这与系统中所使用锁的初衷是一样的。</p>
<p>在InnoDB上，锁都是建立索引的基础之上，这里包括聚簇索引、二级索引等。</p>
<p>对于唯一索引来说，针对每个特定的值的遍历与查询是可以明确目标的，因此，不需要间隙锁，仅使用记录锁就可以了。</p>
<p>对于普通索引来说，针对某个特定的值的遍历与查询是不固定的，可能存在多个相同的值，此时就需要锁定目标值的前后，防止加入相同的值。</p>
<p>间隙锁是可以共存的，即使是冲突的锁，临键锁解决了幻读的问题。</p>
<p>插入意向锁是间隙锁，需要注意插入冲突的判断条件是位置是否相同，即使是相同范围的间隙锁，虽然插入位置不同也不会造成冲突。</p>
<p>对于自增锁来说，虽然是表锁，但锁定的时间仅限于插入SQL语句，不会跟随整个事务，因此，性能并没有那么差。</p>

    
	</div>
	
    
<nav id="article-nav">
  
    <a href="/2020/08/08/redis-skiplist/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Redis 跳跃表
        
      </div>
    </a>
  
  
    <a href="/2020/07/29/cache-usage/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">
        
          Local Cache &amp; Distributed Cache
        
      </div>
    </a>
  
</nav>

  
</article>







</div>

    <!--/div-->
    <div class="mb-search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="Search">
    <input type="hidden" name="q" value="site:simyy.cn">
  </form>
</div>
<footer id="footer">
	<h1 class="footer-blog-title">
		<a href="/">simyy</a>
	</h1>
    &nbsp;&nbsp;
	<span class="copyright">
		&copy; 2024 simyy  Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
	</span>
</footer>

    

<script src="https://cdn.bootcss.com/jquery/2.1.3/jquery.min.js"></script>


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>
