<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>simyy</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://simyy.cn/"/>
  <updated>2020-04-18T05:05:33.317Z</updated>
  <id>http://simyy.cn/</id>
  
  <author>
    <name>simyy</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SpringBoot原理分析</title>
    <link href="http://simyy.cn/2020/04/18/java-springboot/"/>
    <id>http://simyy.cn/2020/04/18/java-springboot/</id>
    <published>2020-04-18T05:03:22.000Z</published>
    <updated>2020-04-18T05:05:33.317Z</updated>
    
    <content type="html"><![CDATA[<p>本文简单分析下SpringBoot的原理设计。 </p><a id="more"></a><h3 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h3><p><code>SpringBoot</code>是为了简化构建应用的复杂度。</p><blockquote><p>SpringBoot到底解决了什么问题？</p></blockquote><hr><p><strong>在SpringBoot出现之前</strong></p><p>应用构建是建立在大量的<code>XML配置</code>之上，功能模块的依赖全部由开发人员自行整合。</p><p>整合的过程复杂不说，还会存在不同的整合方式，稍有不慎就会出现各种奇奇怪怪的问题。</p><p><strong>在SpringBoot出现之后</strong></p><p>应用构建是建立在大量的<code>starter</code>之上，功能模块的依赖通过<code>maven</code>引入后自动整合。</p><hr><h4 id="约定大于配置"><a href="#约定大于配置" class="headerlink" title="约定大于配置"></a>约定大于配置</h4><p><code>约定大于配置</code>是实现SpringBoot的基本原则。</p><p>SpringBoot整合了一套<code>默认配置</code>，不需要开发者手动配置<code>XML</code>，只有当默认配置不满足的情况下才需要手动修改默认配置。</p><h4 id="四大核心"><a href="#四大核心" class="headerlink" title="四大核心"></a>四大核心</h4><p><code>四大核心</code>包括：<code>auto-configuration（自动配置）</code>、<code>starters（起步依赖）</code>、<code>cli</code>和<code>actuator</code>。</p><p><strong>auto-configuration</strong></p><p><code>auto-configuration</code>是SpringBoot自动配置的核心，提供模块自动装配功能。</p><p>常见的<code>Enable**</code>注解属于自动配置的一部分。</p><p><strong>starters</strong></p><p><code>starters</code>是SpringBoot功能整合的关键，按照约定大于配置的原则实现。</p><p>例如，<code>spring-boot-starter-web</code>是<code>Spring MVC</code>的一种整合，不需要再去配置<code>servlet.xml</code>及<code>web.xml</code>，仅需要通过改变配置参数即可满足需求。</p><p><strong>cli</strong></p><p><code>cli</code>是快速创建原型项目的命令行工具，支持项目创建、编译打包等功能。</p><p><code>cli</code>还支持运行<code>Groovy脚本</code>。</p><p><strong>actuator</strong></p><p><code>actuator</code>是用于应用的监控与管理的工具，可以查看应用配置及自身环境属性等信息。</p><p><code>actuator</code>提供<code>REST API</code>来查询应用运行时的内部状态。</p><p><code>actuator</code>虽然提供便利，但也存在一定的安全风险，因此一般与<code>spring-boot-start-security</code>一起使用。</p><h4 id="自动配置的原理"><a href="#自动配置的原理" class="headerlink" title="自动配置的原理"></a>自动配置的原理</h4><blockquote><p><code>auto-configuration（自动配置）</code>是SpringBoot自动配置的核心，包括所有<code>Enable**</code>注解。</p></blockquote><p>首先，<code>starters</code>是SpringBoot模块整合的关键，通过简单的<code>maven</code>引入就可以实现模块的整合。</p><blockquote><p>那么<code>starter</code>是如何被引入的？</p></blockquote><ol><li><p>SpringBoot启动后会去依赖的<code>starter</code>包中查找<code>resources/META-INF/spring.factories</code>文件；</p></li><li><p>按照<code>spring.factories</code>来加载<code>AutoConfiture</code>配置类；</p></li><li><p>扫描<code>@Configuration</code>注解将配置注入到<code>Context</code>容器中。</p></li></ol><p>其中，<code>spring.factories</code>就是一种约定，SpringBoot按照这种约定来是先模块的自动加载配置。</p><h5 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h5><h6 id="启动注解的扫描过程"><a href="#启动注解的扫描过程" class="headerlink" title="启动注解的扫描过程"></a>启动注解的扫描过程</h6><p><code>@SpringBootApplication</code>是SpringBoot项目的启动注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(excludeFilters = &#123;</span><br><span class="line">        <span class="meta">@Filter</span>(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span><br><span class="line">        <span class="meta">@Filter</span>(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<code>@EnableAutoConfiguration</code>是启动自动配置的注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import</span>(AutoConfigurationImportSelector.class)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，涉及到<code>@Import</code>及<code>ImportSelector</code>两个功能点。</p><h6 id="Import-与-ImportSelector"><a href="#Import-与-ImportSelector" class="headerlink" title="@Import 与 ImportSelector"></a>@Import 与 ImportSelector</h6><p><code>@Import</code>注解用于将指定的实例注入到IOC容器中，等同于<code>XML中的import</code>。</p><p><code>@Import</code>支持三种注入方式：<code>直接注入</code>、<code>条件注入</code>和<code>动态注入</code>。</p><p><strong>直接注入</strong></p><p>通过直接引入目标配置<code>@Import({XXXAutoConfig.class})</code>来实现配置加载。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Import</span>(&#123;XXXAutoConfig.class&#125;)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnabletXXX &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>条件注入</strong></p><p>通过实现<code>ImportSelector</code>来选择注入的配置信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Import</span>(&#123;XXXEnableSelector.class&#125;)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnabletXXX &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XXXEnableSelector</span> <span class="keyword">implements</span> <span class="title">ImportSelector</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String[]&#123;XXXAutoConfigConfig.class.getName()&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>动态注入</strong></p><p>通过实现<code>ImportBeanDefinitionRegistrar</code>来实现动态注入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Import</span>(&#123;DynamicConfigEnableRegistrar.class&#125;)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnabletXXX &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要注入的注解</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE, ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> DynamicConfig &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现ImportBeanDefinitionRegistrar来实现动态扫描注册</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicConfigEnableRegistrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span>, <span class="title">ResourceLoaderAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ResourceLoader resourceLoader;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 注册扫码器</span></span><br><span class="line">        DynamicRegisterScanner scanner = <span class="keyword">new</span> DynamicRegisterScanner(registry, <span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">// 设置classloader</span></span><br><span class="line">        scanner.setResourceLoader(resourceLoader);</span><br><span class="line">        scanner.registerFilters();</span><br><span class="line">        <span class="comment">// 设置待扫描注解</span></span><br><span class="line">        scanner.addIncludeFilter(<span class="keyword">new</span> AnnotationTypeFilter(DynamicConfig.class));</span><br><span class="line">        <span class="comment">// 设置待扫描路径</span></span><br><span class="line">        scanner.doScan(<span class="string">"x.y.z.package"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setResourceLoader</span><span class="params">(ResourceLoader resourceLoader)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.resourceLoader = resourceLoader;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>mybatis的mapper扫描</code>就是通过<code>动态注入</code>的方式实现。</p><h6 id="扫描并加载配置"><a href="#扫描并加载配置" class="headerlink" title="扫描并加载配置"></a>扫描并加载配置</h6><p>SpringBoot通过实现<code>ImportSelector</code>接口来扫描并加载配置。</p><ul><li><code>getCandidateConfigurations</code>从<code>META-INF/spring.factories</code>获取待配置的类；</li><li><code>getAutoConfigurationEntry</code>去重并获取已排除的配置类，并出发<code>ImportEvent</code>事件；</li><li>重写<code>selectImports</code>实现配置类的导入。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AutoConfigurationImportSelector</span> ... </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 获取自动配置</span></span><br><span class="line">        AutoConfigurationEntry autoConfigurationEntry = getAutoConfigurationEntry(</span><br><span class="line">                autoConfigurationMetadata, annotationMetadata);</span><br><span class="line">        <span class="keyword">return</span> StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> AutoConfigurationEntry <span class="title">getAutoConfigurationEntry</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            AutoConfigurationMetadata autoConfigurationMetadata,</span></span></span><br><span class="line"><span class="function"><span class="params">            AnnotationMetadata annotationMetadata)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 获取候选配置</span></span><br><span class="line">        List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata,</span><br><span class="line">                attributes);</span><br><span class="line">        configurations = removeDuplicates(configurations);</span><br><span class="line">        Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes);</span><br><span class="line">        checkExcludedClasses(configurations, exclusions);</span><br><span class="line">        configurations.removeAll(exclusions);</span><br><span class="line">        configurations = filter(configurations, autoConfigurationMetadata);</span><br><span class="line">        fireAutoConfigurationImportEvents(configurations, exclusions);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AutoConfigurationEntry(configurations, exclusions);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> List&lt;String&gt; <span class="title">getCandidateConfigurations</span><span class="params">(AnnotationMetadata metadata,</span></span></span><br><span class="line"><span class="function"><span class="params">            AnnotationAttributes attributes)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 从META-INF/spring.factories获取自动配置的类</span></span><br><span class="line">        List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(</span><br><span class="line">                getSpringFactoriesLoaderFactoryClass(), getBeanClassLoader());</span><br><span class="line">        Assert.notEmpty(configurations,</span><br><span class="line">                <span class="string">"No auto configuration classes found in META-INF/spring.factories. If you "</span></span><br><span class="line">                        + <span class="string">"are using a custom packaging, make sure that file is correct."</span>);</span><br><span class="line">        <span class="keyword">return</span> configurations;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>META-INF/spring.factories</code>约定配置格式如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">  x.y.z.starter.StarterAutoConfiguration</span><br></pre></td></tr></table></figure><h4 id="条件注解"><a href="#条件注解" class="headerlink" title="条件注解"></a>条件注解</h4><p>SpringBoot提供了丰富的<code>条件注解</code>来解决依赖加载的问题。</p><hr><p>判断<code>Bean</code>是否注册到<code>IOC容器</code>中来确认是否触发当前逻辑，</p><ul><li><code>@ConditionalOnBean</code></li><li><code>@ConditionalOnMissingBean</code></li></ul><p>用于解决Bean的依赖问题，当存在某一个依赖模块时自动加载对应的依赖。</p><hr><p>判断<code>累加载器</code>中是否存在<code>Class类</code>来确认是否触发当前逻辑，</p><ul><li><code>@ConditionalOnClass</code></li><li><code>@ConditionalOnMissingClass</code></li></ul><hr><p>判断生存指定了<code>资源文件</code>来确认是否触发当前逻辑，</p><ul><li><code>@ConditionalOnResource</code></li></ul><p>可用于从远程拉取配置文件，实现应用的配置集中管理。</p><hr><p>此外，还包括<code>@ConditionalOnJava</code>、<code>ConditionalOnNotWebApplication</code>、<code>ConditionalOnWebApplication</code>等。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文简单分析下SpringBoot的原理设计。 &lt;/p&gt;
    
    </summary>
    
      <category term="编程语言" scheme="http://simyy.cn/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="编程语言" scheme="http://simyy.cn/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Java" scheme="http://simyy.cn/tags/Java/"/>
    
      <category term="SpringBoot" scheme="http://simyy.cn/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>Java 表达式引擎分析</title>
    <link href="http://simyy.cn/2020/04/16/java-expression-plugin/"/>
    <id>http://simyy.cn/2020/04/16/java-expression-plugin/</id>
    <published>2020-04-16T13:26:33.000Z</published>
    <updated>2020-04-16T15:00:50.128Z</updated>
    
    <content type="html"><![CDATA[<p>本文将和介绍及分析表达式引擎。</p><a id="more"></a><h3 id="表达式引擎"><a href="#表达式引擎" class="headerlink" title="表达式引擎"></a>表达式引擎</h3><p><code>表达式引擎</code>是把字符串表达式转换为计算机可以理解运行的计算规则。</p><p><code>Groovy</code>就是最常见的基于JVM动态语言的表达式引擎之一。</p><p><code>表达式的引擎</code>是基于编程语言的基础之上<code>编译原理</code>的一种实现。</p><h4 id="常见功能"><a href="#常见功能" class="headerlink" title="常见功能"></a>常见功能</h4><p>表达式引擎常见的功能有<code>操作符</code>、<code>对象</code>、<code>条件语句</code>、<code>循环语句</code>、<code>函数</code>、<code>集合</code>、<code>异常</code>、<code>脚本</code>等。</p><p><img src="/images/java_expression_plugin_01.png" alt="java_expression_plugin_01.png"></p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p><strong>编译型与解释型</strong></p><p>计算机是不能理解高级语言的，更不能直接执行高级语言。</p><p>任何高级语言编写的程序若想被计算机运行，都必须将其转换成计算机语言（<code>机器码</code>）。</p><p><code>编译型</code>是将高级语言源代码<code>一次性编译</code>成可被该平台硬件执行的机器码。</p><p><code>解释型</code>不需要事先编译而直接将源代码<code>解释</code>成机器码并立即执行。</p><blockquote><p>与预编译相比，解释机器码并执行效率较低。</p></blockquote><p>在Java的表达式引擎中，<code>MVEL</code>支持普通的解释运行及编译运行。</p><p><strong>强类型与弱类型</strong></p><p><code>弱类型检查</code>不会对变量类型做任何假设，而是在运行时做类型推断及自动转化。</p><p><code>强类型检查</code>可以保证在编译时就确定变量类型从而才能生成高效和正确的代码。</p><hr><p>在Java的表达式引擎中，</p><p><code>FEL</code>属于强类型检查，它没有自己的类型系统，而是利用Java类型来实现；</p><p><code>QLExpress</code>和<code>Groovy</code>属于弱类型检查，在编译时不会对类型做任何检查，而是在运行期对其推断并转换。</p><hr><p><strong>表达式解析</strong></p><p>表达式可以分为<code>波兰式(前缀表达式)</code>、<code>逆波兰式(后缀表达式)</code>和<code>中缀表达式</code>。</p><p>其中，<code>波兰式</code>和<code>逆波兰式</code>更适合计算机来执行，具体可以<a href="https://blog.csdn.net/lovejay7/article/details/81584402" target="_blank" rel="noopener">参考</a>。</p><p>表达式会首先被解析为<code>语法树AST</code>（中缀表达式），但<code>中缀表达式</code>不适合计算机运算，因此，需要转换为<code>波兰式</code>或<code>逆波兰式</code>。</p><hr><p><strong>Java表达式引擎原理</strong></p><p>表达式引擎的基础是<code>编译原理</code>及<code>Java字节码</code>技术。</p><p>在编译原理中，需要实现<code>解释器</code>和<code>编译器</code>。</p><p>解释器包括<code>语法分析</code>、<code>词法分析</code>及<code>语义分析</code>，而解释器包括<code>中间代码</code>和<code>目标代码</code>。</p><p>Java中的规则引擎一般会把<code>表达式</code>生成<code>.class</code>字节码，并利用JVM加载到内存中来执行，从而达到编译的运行效率。</p><hr><p>目前，规则的引擎的实现大体分为两种：<code>利用Java类运行时动态编译技术</code> 和 <code>利用ASM字节码生成技术</code>。</p><p><strong>利用Java类运行时动态编译技术</strong></p><blockquote><p>核心接口： <code>javax.tools接口JavaCompiler</code>。</p></blockquote><ul><li>使用<code>antlr</code>解析把表达式成<code>AST</code>；</li><li>使用JDK工具(<code>javax.tools.JavaCompiler</code>)动态编译成<code>.class</code>文件；</li><li>利用<code>URLClassLoader</code>把<code>.class</code>文件放入JVM直接运行。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expression string -&gt; antlr -&gt; AST -&gt; comiple -&gt; java source template -&gt; java class -&gt; Expression</span><br></pre></td></tr></table></figure><p>具体可<a href="https://yq.aliyun.com/articles/85362?spm=a2c4e.11153940.0.0.883e6bafJUGsec" target="_blank" rel="noopener">参考</a>。</p><p><strong>利用ASM字节码生成技术</strong></p><blockquote><p>核心技术：<code>antlr语法解析器</code> 与 <code>ASM字节码生成技术</code>。</p></blockquote><ul><li>使用<code>antlr</code>解析把表达式成<code>AST</code>；</li><li>利用<code>AMS</code>把<code>AST</code>的节点重新编排成<code>.class</code>文件或者指令；</li><li>利用<code>URLClassLoader</code>把<code>.class</code>文件放入JVM直接运行。</li></ul><hr><h4 id="Java中的表达式引擎"><a href="#Java中的表达式引擎" class="headerlink" title="Java中的表达式引擎"></a>Java中的表达式引擎</h4><p>表达式引擎的对比介绍可<a href="https://zhuanlan.zhihu.com/p/33927344" target="_blank" rel="noopener">参考</a>。</p><p><strong>基础功能</strong></p><p><code>FEL</code>、<code>SimpleExpress</code>都是仅支持表达式的基础功能，依赖Java类型系统。</p><p>此外，还包括<code>JUEL</code>、<code>JSEL</code>。</p><p><strong>高级功能</strong></p><p><code>Aviator</code>有自己的类型系统，属于若类型检查。</p><p><code>QLExpress</code>是阿里开源的表达式引擎，同样属于若类型检查，强调功能扩展。</p><p><code>Groovy</code>兼容Java语法，同时支持强类型和若类型检查，支持更多的集合操作。</p><p><code>Groovy</code>是<code>Java</code>官方的脚本语言，更适合构建大型规则引擎。</p><hr><p>性能对比：</p><p>表达式：<br><code>foobar * 100 &lt; 200 || foobar &gt; 300 || (foobar &lt; 200 &amp;&amp; foobar + 5 &lt; 300)</code></p><p>循环次数：<br><code>100 * 10000</code></p><p>结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">jsel::exec  Run Time:   2164 ms</span><br><span class="line">jselCompiled::exec  Run Time:   28 ms</span><br><span class="line">mvel::exec  Run Time:   1881 ms</span><br><span class="line">mvelCompiled::exec  Run Time:   120 ms</span><br><span class="line">qlexpress::exec Run Time:   14471 ms</span><br><span class="line">qlexpressCompiled::exec Run Time:   113 ms</span><br><span class="line">juel::exec  Run Time:   159 ms</span><br><span class="line">groovy::exec    Run Time:   680 ms</span><br><span class="line">groovyCompiled::exec    Run Time:   45 ms</span><br><span class="line">aviator::exec   Run Time:   16736 ms</span><br><span class="line">aviatorCompiled::exec   Run Time:   43 ms</span><br></pre></td></tr></table></figure></p><hr><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p><code>流程编排</code>：通过动态脚本来管理流程调度，例如，基于微服务来动态搭建流程。</p><p><code>规则引擎</code>：利用动态表达式来实时修改配置，例如，营销规则配置、审核流条件判断。</p><p><code>脚本引擎</code>：利用动态脚本来实现在线编辑器。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将和介绍及分析表达式引擎。&lt;/p&gt;
    
    </summary>
    
      <category term="编程语言" scheme="http://simyy.cn/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="编程语言" scheme="http://simyy.cn/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Java" scheme="http://simyy.cn/tags/Java/"/>
    
      <category term="表达式引擎" scheme="http://simyy.cn/tags/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%BC%95%E6%93%8E/"/>
    
      <category term="规则引擎" scheme="http://simyy.cn/tags/%E8%A7%84%E5%88%99%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title>Spring AOP 失效的原因</title>
    <link href="http://simyy.cn/2020/04/02/java-spring-aop-ineffective/"/>
    <id>http://simyy.cn/2020/04/02/java-spring-aop-ineffective/</id>
    <published>2020-04-02T10:53:09.000Z</published>
    <updated>2020-04-03T05:54:31.768Z</updated>
    
    <content type="html"><![CDATA[<p>分析AOP在一定情况下会失效的原因。</p><a id="more"></a><h5 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h5><p><code>Spring</code>提供了事务注解<code>Transactional</code>，在一定的使用场景下会发生事务不生效的情况。</p><p><strong>注：</strong>下列场景中，<code>updateInDB</code>为数据库更新操作。</p><h6 id="场景1（事务生效）"><a href="#场景1（事务生效）" class="headerlink" title="场景1（事务生效）"></a>场景1（事务生效）</h6><p>一般的使用方式如下，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">updateA</span><span class="params">(A a)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Update A</span></span><br><span class="line">        updateInDB(a)</span><br><span class="line">        b = ...</span><br><span class="line">        <span class="comment">// Then update B</span></span><br><span class="line">        updateB(b)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">updateB</span><span class="params">(B b)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Update B</span></span><br><span class="line">        updateInDB(b)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ServiceTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Service service;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        A a = <span class="keyword">new</span> A(...);</span><br><span class="line">        service.updateA(a)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于<code>updateA</code>包含了<code>updateB</code>的操作，因此<code>updateB</code>与<code>updateA</code>会在一个事务中。</p><p>此时，<code>updateA</code>与<code>updateB</code>会同时生效或失效。</p><h6 id="场景2（事务失效）"><a href="#场景2（事务失效）" class="headerlink" title="场景2（事务失效）"></a>场景2（事务失效）</h6><p>考虑<code>内部调用</code>的情况如下，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">update</span><span class="params">(A a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> updateA(A)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">updateA</span><span class="params">(A a)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Update A</span></span><br><span class="line">        updateInDB(a)</span><br><span class="line">        b = ...</span><br><span class="line">        <span class="comment">// Then update B</span></span><br><span class="line">        updateB(b)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">updateB</span><span class="params">(B b)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Update B</span></span><br><span class="line">        updateInDB(b)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ServiceTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Service service;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        A a = <span class="keyword">new</span> A(...);</span><br><span class="line">        service.update(a)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与场景1不同，此时通过<code>无事务标识的update</code>调用<code>有事务标识的updateA</code>。</p><p>此时，<code>updateA</code>与<code>updateB</code>的事务会失效。</p><h6 id="场景3（事务失效）"><a href="#场景3（事务失效）" class="headerlink" title="场景3（事务失效）"></a>场景3（事务失效）</h6><p>考虑<code>继承调用</code>的场景如下，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseService</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">updateA</span><span class="params">(A a)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Update A</span></span><br><span class="line">        updateInDB(a)</span><br><span class="line">        b = ...</span><br><span class="line">        <span class="comment">// Then update B</span></span><br><span class="line">        updateB(b)</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">updateB</span><span class="params">(B b)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Update B</span></span><br><span class="line">        updateInDB(b)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Service</span> <span class="keyword">extends</span> <span class="title">BaseService</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">updateA</span><span class="params">(A a)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Invoke super.method</span></span><br><span class="line">        <span class="keyword">super</span>.updateA(a)</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ServiceTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Service service;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        A a = <span class="keyword">new</span> A(...);</span><br><span class="line">        service.updateA(a)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>BaseService.updateA</code>标记了<code>Transactional</code>注解。</p><p><code>Service</code>继承自<code>BaseService</code>，覆盖了<code>updateA</code>，但没有事务标识。</p><p>此时，<code>service.updateA</code>调用<code>super.updateA</code>是无法保证事务的有效性。</p><h5 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h5><p>首先，<code>Spring的核心</code>是<code>IOC控制反转</code>和<code>AOP面向切面编程</code>。</p><p><code>IOC控制反转</code>也被称为<code>DI依赖注入</code>，负责管理Spring项目中所有对象的<code>生命周期</code>与<code>依赖关系</code>。</p><p><code>AOP面向切面编程</code>是通过<code>预编译</code>或<code>动态代理</code>来改变原有模块功能的技术方式。</p><blockquote><p><code>IOC</code>是实现<code>AOP</code>的基础。</p></blockquote><p><code>AOP</code>无论哪种实现方式都会为模块生成新的代理模块，而模块之间的依赖注入是依赖<code>IOC</code>的。</p><p>也就是说，如果希望<code>AOP</code>生效，必须通过<code>IOC</code>管理的对象实例才可以生效。</p><hr><blockquote><p><code>内部调用</code>: 通过<code>this</code>或<code>super</code>的调用。</p></blockquote><p>通过<code>this</code>和<code>super</code>产生的函数调用与<code>Spring IOC</code>无关，因此<code>AOP</code>无效。</p><p>在<code>场景2</code>和<code>场景3</code>中，虽然<code>updateA</code>与<code>super.updateA</code>都带有Spring的<code>Transactional</code>注解，</p><p>但是通过<code>this</code>与<code>super</code>来调用的，因此，<code>Transactional</code>注解无效。</p><blockquote><p>只有通过<code>代理</code>调用，<code>AOP</code>才会生效，而<code>代理</code>是<code>Spring IOC</code>的一部分。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;分析AOP在一定情况下会失效的原因。&lt;/p&gt;
    
    </summary>
    
      <category term="编程语言" scheme="http://simyy.cn/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="编程语言" scheme="http://simyy.cn/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Java" scheme="http://simyy.cn/tags/Java/"/>
    
      <category term="Spring" scheme="http://simyy.cn/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Python Json序列化</title>
    <link href="http://simyy.cn/2020/03/16/python-json-serialize/"/>
    <id>http://simyy.cn/2020/03/16/python-json-serialize/</id>
    <published>2020-03-16T04:10:51.000Z</published>
    <updated>2020-03-16T04:57:53.821Z</updated>
    
    <content type="html"><![CDATA[<p>记录一下Python对象中关于Json的序列化和反序列化。<br><a id="more"></a></p><p><code>Python</code>中常用的<code>Json序列化</code>采用<code>json.dupms</code>以及<code>json.loads</code>来实现。</p><h5 id="json-dumps"><a href="#json-dumps" class="headerlink" title="json.dumps"></a>json.dumps</h5><p><code>json.dumps</code>是我们最为常用的序列化方式，用于<code>dict</code>转换成<code>Json字符串</code>。</p><p>为了解决对象序列化的问题，一般需要利用<code>__dict__</code>来获取对象的所有字段内容。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">json.dumps(obj, default=<span class="keyword">lambda</span> obj: obj.__dict__)</span><br></pre></td></tr></table></figure><blockquote><p>存在问题：如果某一字段的类型为某一个类，在序列过程中就会出现问题。</p></blockquote><p>此时，由于该非基础类型的字段无法直接转化为dict，从而<code>lambda obj: obj.__dict__)</code>会失效。</p><p>为了解决上述问题，一般可以通过定制化每一个类的序列化函数，然后通过<code>default</code>来指定。</p><p>类似这种,</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.name = <span class="keyword">None</span></span><br><span class="line">        self.age = <span class="keyword">None</span></span><br><span class="line">        <span class="comment"># Address</span></span><br><span class="line">        self.address = <span class="keyword">None</span> </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Address</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.city = <span class="keyword">None</span></span><br><span class="line">        self.province = <span class="keyword">None</span></span><br><span class="line">        self.area_code = <span class="keyword">None</span></span><br><span class="line">        self.area_detail = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">student2d</span><span class="params">(student_obj)</span>:</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">json.dumps(obj, default=student2d)</span><br></pre></td></tr></table></figure><h5 id="json-loads"><a href="#json-loads" class="headerlink" title="json.loads"></a>json.loads</h5><p><code>json.loads</code>是我们最为常用的反序列化方式，用于<code>Json字符串</code>转换成<code>dict</code>。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">json.loads(json_str, object_hook=xxxx)</span><br></pre></td></tr></table></figure><blockquote><p>存在同样的问题：如果某一字段的类型为某一个类，在反序列过程中时无法识别到具体的类结构。</p></blockquote><p>存在上述问题的原因在于，<code>Python</code>属于<code>非强类型检查</code>，初始化的类时无法获取字段的具体类型，只有在运行期初始化才确定。</p><p>同样，为了解决上述问题，一般可以通过定制化每一个类的反序列化函数，然后通过<code>object_hook</code>来指定。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.name = <span class="keyword">None</span></span><br><span class="line">        self.age = <span class="keyword">None</span></span><br><span class="line">        <span class="comment"># Address</span></span><br><span class="line">        self.address = <span class="keyword">None</span> </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Address</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.city = <span class="keyword">None</span></span><br><span class="line">        self.province = <span class="keyword">None</span></span><br><span class="line">        self.area_code = <span class="keyword">None</span></span><br><span class="line">        self.area_detail = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">d2student</span><span class="params">(self, d)</span>:</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">json.loads(obj, object_hook=d2student)</span><br></pre></td></tr></table></figure><h5 id="通用序列化"><a href="#通用序列化" class="headerlink" title="通用序列化"></a>通用序列化</h5><p>仍然存在的问题：<code>每个类都需要定义自己的序列化和反序列化函数</code>。</p><p>上面的解决方式会带来大量的重复编码的功能。</p><p>为了解决这个问题，利用<code>abc</code>模块实现序列化的抽象，如下</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> abc</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AbstractJsonSerializer</span><span class="params">(abc.ABC)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>所有带有<code>Json序列化</code>功能的类都需要继<code>AbstractJsonSerializer</code>。</p><p>下面简单介绍下序列化和反序列化的思路。</p><h6 id="serialize"><a href="#serialize" class="headerlink" title="serialize"></a>serialize</h6><p>序列化过程中，为了避免<code>__dict__</code>中特殊类造成的影响，需要对字典值类型做判断。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 循环遍历对象字段</span></span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> self.__dict__.items():</span><br><span class="line">    <span class="comment"># 字段值属于基础类型</span></span><br><span class="line">    <span class="keyword">if</span> isinstance(v, int) <span class="keyword">or</span> isinstance(v, str) \</span><br><span class="line">            <span class="keyword">or</span> isinstance(v, float) <span class="keyword">or</span> isinstance(v, list) \</span><br><span class="line">            <span class="keyword">or</span> isinstance(v, tuple) <span class="keyword">or</span> isinstance(v, set) \</span><br><span class="line">            <span class="keyword">or</span> isinstance(v, dict):</span><br><span class="line">        _d[k] = v</span><br><span class="line">    <span class="comment"># 字段值时特殊类型</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> v <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="comment"># 判断字段值是否实现了AbstractJsonSerializer</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> issubclass(v.__class__, AbstractJsonSerializer):</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">"[%s] must be implemented JsonSerializer"</span> % v.__class__)</span><br><span class="line">        <span class="comment"># 由于特殊类型字段值实现了AbstractJsonSerializer，则直接调用序列化赋值</span></span><br><span class="line">        _d[k] = v.serialize()</span><br></pre></td></tr></table></figure><h6 id="deserialize"><a href="#deserialize" class="headerlink" title="deserialize"></a>deserialize</h6><p>反序列化过程中，为了避免特殊类造成的类型无法确定的问题，需要在类中指定特殊字段类型的映射。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 抽象方法，指定特殊字段类型映射</span></span><br><span class="line"><span class="meta">@abc.abstractmethod</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">field_cls</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="comment"># 返回值例如，return &#123;'address': Address&#125;</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deserialize</span><span class="params">(self, d: dict)</span>:</span></span><br><span class="line">    <span class="comment"># 获取特殊字段类型映射</span></span><br><span class="line">    cls_map = self.field_cls()</span><br><span class="line">    <span class="comment"># 判断特殊字段类型映射是否满足要求</span></span><br><span class="line">    <span class="keyword">if</span> cls_map <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span> <span class="keyword">and</span> <span class="keyword">not</span> isinstance(cls_map, dict):</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">'[%s].special_field_class_map is must be a dict'</span> % self.__class__)</span><br><span class="line">    <span class="comment"># 遍历类对象的字段</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> self.__dict__.keys():</span><br><span class="line">        <span class="keyword">if</span> k <span class="keyword">not</span> <span class="keyword">in</span> d:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="comment"># 非特殊字段类型</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> cls_map <span class="keyword">or</span> k <span class="keyword">not</span> <span class="keyword">in</span> cls_map:</span><br><span class="line">            self.__setattr__(k, d[k])</span><br><span class="line">        <span class="comment"># 特殊字段类型</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cls = cls_map[k]</span><br><span class="line">            <span class="comment"># 判断特殊字段类型是否实现了序列化</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> issubclass(cls, AbstractJsonSerializer):</span><br><span class="line">                <span class="keyword">raise</span> Exception(<span class="string">"[%s] must be implemented JsonSerializer"</span> % cls.__class__)</span><br><span class="line">            <span class="comment"># 由于特殊类型字段值实现了AbstractJsonSerializer，则直接调用反序列化赋值</span></span><br><span class="line">            self.__setattr__(k, cls().deserialize(d[k]))</span><br><span class="line">    <span class="keyword">return</span> self</span><br></pre></td></tr></table></figure><h6 id="驼峰和下划线命名方式的转换"><a href="#驼峰和下划线命名方式的转换" class="headerlink" title="驼峰和下划线命名方式的转换"></a>驼峰和下划线命名方式的转换</h6><p>下面两个方法时用来兼容<code>驼峰</code>和<code>下划线</code>的字段命名的不同。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 字段去除`_`并全部小写</span></span><br><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">format_attr</span><span class="params">(key)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> key.replace(<span class="string">'_'</span>, <span class="string">''</span>).lower()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 代替__setattr__</span></span><br><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_attr</span><span class="params">(d, obj)</span>:</span></span><br><span class="line">    <span class="comment"># 存储对象字段映射，&#123;格式化字段：字段&#125;</span></span><br><span class="line">    obj_key_dict = dict()</span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> obj.__dict__.keys():</span><br><span class="line">        <span class="keyword">if</span> key.startswith(<span class="string">'__'</span>):</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        obj_key_dict[AbstractJsonSerializer.format_attr(key)] = key</span><br><span class="line">    <span class="comment"># 遍历字典中数据</span></span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> d.keys():</span><br><span class="line">        <span class="comment"># 获取字典的格式化key</span></span><br><span class="line">        format_key = AbstractJsonSerializer.format_attr(key)</span><br><span class="line">        <span class="comment"># 判断是否存在于对象字段映射</span></span><br><span class="line">        <span class="keyword">if</span> format_key <span class="keyword">in</span> obj_key_dict:</span><br><span class="line">            obj.__setattr__(obj_key_dict[format_key], d[key])</span><br></pre></td></tr></table></figure><h6 id="完整版实现"><a href="#完整版实现" class="headerlink" title="完整版实现"></a>完整版实现</h6><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> abc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AbstractJsonSerializer</span><span class="params">(abc.ABC)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Json Serializer</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">field_cls</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        return field class map</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">serialize</span><span class="params">(self, need_format=False)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        convert obj to dict</span></span><br><span class="line"><span class="string">        :return: dict</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        _d = dict()</span><br><span class="line">        d = self.__dict__</span><br><span class="line">        <span class="keyword">for</span> k, v <span class="keyword">in</span> d.items():</span><br><span class="line">            <span class="keyword">if</span> isinstance(v, int) <span class="keyword">or</span> isinstance(v, str) \</span><br><span class="line">                    <span class="keyword">or</span> isinstance(v, float) <span class="keyword">or</span> isinstance(v, list) \</span><br><span class="line">                    <span class="keyword">or</span> isinstance(v, tuple) <span class="keyword">or</span> isinstance(v, set) \</span><br><span class="line">                    <span class="keyword">or</span> isinstance(v, dict):</span><br><span class="line">                _d[k] = v</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> v <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> issubclass(v.__class__, AbstractJsonSerializer):</span><br><span class="line">                    <span class="keyword">raise</span> Exception(<span class="string">"[%s] must be implemented JsonSerializer"</span> % v.__class__)</span><br><span class="line">                _d[k] = v.serialize()</span><br><span class="line">        <span class="keyword">return</span> _d</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deserialize</span><span class="params">(self, d: dict)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        convert dict to obj</span></span><br><span class="line"><span class="string">        :param: d: dict</span></span><br><span class="line"><span class="string">        :return: obj</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        cls_map = self.field_cls()</span><br><span class="line">        <span class="keyword">if</span> cls_map <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span> <span class="keyword">and</span> <span class="keyword">not</span> isinstance(cls_map, dict):</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">'[%s].special_field_class_map is must be a dict'</span> % self.__class__)</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> self.__dict__.keys():</span><br><span class="line">            <span class="keyword">if</span> k <span class="keyword">not</span> <span class="keyword">in</span> d:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> cls_map <span class="keyword">or</span> k <span class="keyword">not</span> <span class="keyword">in</span> cls_map:</span><br><span class="line">                self.__setattr__(k, d[k])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cls = cls_map[k]</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> issubclass(cls, AbstractJsonSerializer):</span><br><span class="line">                    <span class="keyword">raise</span> Exception(<span class="string">"[%s] must be implemented JsonSerializer"</span> % cls.__class__)</span><br><span class="line">                self.__setattr__(k, cls().deserialize(d[k]))</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">format_attr</span><span class="params">(key)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        format field for x_y or xY to xy</span></span><br><span class="line"><span class="string">        :param key: field</span></span><br><span class="line"><span class="string">        :return: format field</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> key.replace(<span class="string">'_'</span>, <span class="string">''</span>).lower()</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_attr</span><span class="params">(d, obj)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :param d: dict of obj</span></span><br><span class="line"><span class="string">        :param obj: target obj</span></span><br><span class="line"><span class="string">        :return: None</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        obj_key_dict = dict()</span><br><span class="line">        <span class="keyword">for</span> key <span class="keyword">in</span> obj.__dict__.keys():</span><br><span class="line">            <span class="keyword">if</span> key.startswith(<span class="string">'__'</span>):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            obj_key_dict[AbstractJsonSerializer.format_attr(key)] = key</span><br><span class="line">        <span class="keyword">for</span> key <span class="keyword">in</span> d.keys():</span><br><span class="line">            format_key = AbstractJsonSerializer.format_attr(key)</span><br><span class="line">            <span class="keyword">if</span> format_key <span class="keyword">in</span> obj_key_dict:</span><br><span class="line">                obj.__setattr__(obj_key_dict[format_key], d[key])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(AbstractJsonSerializer)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">field_cls</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">'address'</span>: Address&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.name = <span class="keyword">None</span></span><br><span class="line">        self.age = <span class="keyword">None</span></span><br><span class="line">        self.address = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Address</span><span class="params">(AbstractJsonSerializer)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">field_cls</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.city = <span class="keyword">None</span></span><br><span class="line">        self.province = <span class="keyword">None</span></span><br><span class="line">        self.area_code = <span class="keyword">None</span></span><br><span class="line">        self.area_detail = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    s = Student()</span><br><span class="line">    s.name = <span class="string">'jack'</span></span><br><span class="line">    s.age = <span class="number">11</span></span><br><span class="line">    a = Address()</span><br><span class="line">    a.city = <span class="string">'hangzhou'</span></span><br><span class="line">    a.province = <span class="string">'zhejiang'</span></span><br><span class="line">    a.area_code = <span class="string">'31000'</span></span><br><span class="line">    a.area_detail = <span class="string">'gongshuqu'</span></span><br><span class="line">    s.address = a</span><br><span class="line"></span><br><span class="line">    d = s.serialize()</span><br><span class="line">    print(d)</span><br><span class="line"></span><br><span class="line">    ss = Student().deserialize(d)</span><br><span class="line">    print(ss)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录一下Python对象中关于Json的序列化和反序列化。&lt;br&gt;
    
    </summary>
    
      <category term="编程语言" scheme="http://simyy.cn/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="编程语言" scheme="http://simyy.cn/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Python" scheme="http://simyy.cn/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>ReentrantLock原理分析</title>
    <link href="http://simyy.cn/2020/03/08/java-reentrantlock/"/>
    <id>http://simyy.cn/2020/03/08/java-reentrantlock/</id>
    <published>2020-03-08T10:48:56.000Z</published>
    <updated>2020-03-08T11:09:02.343Z</updated>
    
    <content type="html"><![CDATA[<p>从源码层面分析ReentrantLock原理和实现。</p><a id="more"></a><h4 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h4><p><code>ReentrantLock</code>通过设置<code>ReentrantLock.sync</code>来实现公平与非公平锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="FairSync-amp-NonfairSync"><a href="#FairSync-amp-NonfairSync" class="headerlink" title="FairSync &amp; NonfairSync"></a>FairSync &amp; NonfairSync</h4><p><code>FairSync</code>和<code>NonfairSync</code>是实现公平锁与非公平锁的关键，均继承自<code>Sync</code>。</p><p><code>Sync</code>则是继承自<code>AbstractQueuedSynchronizer</code>，也就是大家常说的<code>AQS</code>。</p><blockquote><p><code>ReentrantLock</code>通过<code>AQS</code>和<code>CAS</code>来实现公平与非公平锁。</p></blockquote><h4 id="AQS的原理"><a href="#AQS的原理" class="headerlink" title="AQS的原理"></a>AQS的原理</h4><p><code>AQS</code>可以被称为<code>队列同步器</code>，作为<code>JUC</code>并发包的基础。</p><p><code>AQS</code>使用<code>state</code>来表示<code>同步状态</code>，也就是当前同步器的<code>加锁</code>情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AbstractQueuedSynchronizer</span> ... </span>&#123;</span><br><span class="line">    <span class="comment">// state = 0, 表示当前锁已经释放，允许线程获取锁；</span></span><br><span class="line">    <span class="comment">// state &gt; 0, 表示当前锁重入的次数；</span></span><br><span class="line">    <span class="comment">// volatile仅保证可见性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 保证原子性更新，使用unsafe调用底层的CAS原子方法</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, expect, update);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>CLH（等待队列）</code>是AQS中线程阻塞的核心，它使用<code>双向队列</code>来管理线程的状态。</p><blockquote><p>队列的优势在于把<code>无序变有序</code>，具有<code>先进先出</code>的特点。</p></blockquote><p><img src="/images/java-reentrantlock-1.png" alt=""></p><p>线程通过获取<code>同步状态（state）</code>来判断是否进入<code>等待队列（CLH）</code>。</p><blockquote><p>CLH等待队列中<code>Head头节点</code>是持有当前同步器锁的线程节点。</p></blockquote><h4 id="lock-amp-tryLock"><a href="#lock-amp-tryLock" class="headerlink" title="lock &amp; tryLock"></a>lock &amp; tryLock</h4><p><code>lock</code>和<code>tryLock</code>的不同在于是否进入线程阻塞。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 请求获取锁，会阻塞</span></span><br><span class="line">    sync.lock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 请求获取锁，不会阻塞（不回考虑CLH等待队列，代码细节在非公平锁中有解析）</span></span><br><span class="line">    <span class="keyword">return</span> sync.nonfairTryAcquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意：<code>sync</code>继承了<code>AbstractQueuedSynchronizer（AQS）</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 抽象类</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 非阻塞抢占式获取锁（失败后直接返回，不参与CLH队列逻辑）</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="comment">// 初始状态尝试加锁</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 已持有锁则增加重入数</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>AbstractQueuedSynchronizer.acquire</code>是公平锁与非公平锁在<code>lock</code>时都会触发的逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AQS</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AbstractQueuedSynchronizer</span> ... </span>&#123;</span><br><span class="line">    <span class="comment">// 获取锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 尝试获取锁</span></span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            <span class="comment">// 如果获取失败，</span></span><br><span class="line">            <span class="comment">// 1. addWaiter创建一个CLH的Node节点加入等待队列，</span></span><br><span class="line">            <span class="comment">// 2. acquireQueued循环等待获取锁</span></span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            <span class="comment">// 如果获取失败并且加入队列成功，则线程阻塞 </span></span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 阻塞（循环）并不断尝试获取锁</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// 循环（线程阻塞）, 直到当前线程获取到锁</span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="comment">// 获取CLH中当前线程节点的前驱节点</span></span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="comment">// 如果前驱节点是头结点，则尝试获取锁</span></span><br><span class="line">                <span class="comment">// 注意：head头节点是持有锁的线程节点</span></span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    <span class="comment">// 获取锁后更新头节点问题（头结点为当前持有锁的线程节点）</span></span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> interrupted;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果无法获取锁，则需要判断是否需要阻塞等待</span></span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    <span class="comment">// 如果需要阻塞的话，触发线程阻塞</span></span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    interrupted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 如果失败，则需要删除CLH中的线程节点</span></span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据前驱节点判断是否应该阻塞等待</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取前驱节点的等待状态</span></span><br><span class="line">        <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">        <span class="comment">// 如果是响应状态，则需要暂停阻塞</span></span><br><span class="line">        <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 如果ws大于0(CANCELLED=1),前驱节点已取消等待，需要向前遍历一个等待中的节点</span></span><br><span class="line">        <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                node.prev = pred = pred.prev;</span><br><span class="line">            &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">            pred.next = node;</span><br><span class="line">        <span class="comment">// 如果ws&lt;=0(需要排除SIGNAL=-1,还有CONDITION=-2和PROPAGATE=-3,为初始状态), 尝试修改为响应状态</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// CAS原子操作</span></span><br><span class="line">            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 线程阻塞</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// LockSupport是JDK提供的用于阻塞线程的工具</span></span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码可以看出来，公平锁和非公平锁的大体流程相似：</p><ul><li>尝试获取锁</li><li>失败的话，加入CLH等待队列</li><li>按照CLH等待队列的逻辑获取锁（队首优先获取）</li><li>非队首节点判断自身是否需要进入线程阻塞</li><li>线程阻塞等待被唤醒（<code>唤醒是在前驱节点锁释放后触发的</code>）</li></ul><blockquote><p>那如何体现出两者的不同之处呢？<br>公平锁和非公平锁的区别在于<code>lock</code>与<code>tryAcquire</code>实现的不同。</p></blockquote><h5 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h5><p>公平锁的核心在于<code>CLH等待队列</code>。</p><p><code>CLH等待队列</code>按照线程入队的先后顺序来分配锁，在获取<code>state同步状态</code>时通过<code>unsafe的CAS</code>来操作来保证更新的原子性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 公平锁    </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用上面提到的AQS.acquire</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 尝试获取锁</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 当前线程</span></span><br><span class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">        <span class="comment">// AQS的同步状态（重入次数）</span></span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="comment">// 锁释放状态(重入次数为0)</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 重点逻辑：是否存在等待线程（与非公平锁的区别所在）</span></span><br><span class="line">            <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                <span class="comment">// 如果不存在等待线程，不需要进入队列，直接尝试CAS设置同步状态</span></span><br><span class="line">                compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                <span class="comment">// 更新锁状态成功的话，设置独占线程</span></span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 锁重入</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">            <span class="comment">// 更新重入次数</span></span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="非公平锁"><a href="#非公平锁" class="headerlink" title="非公平锁"></a>非公平锁</h5><p>非公平锁的核心在于<code>提前的抢占式获取锁</code>，如果提前抢占失败仍然会进入公平锁的锁分配逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 公平锁  </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 不同之处1：在acquire之前，直接尝试获取锁</span></span><br><span class="line">        <span class="comment">// CAS原子操作尝试修改同步状态，成功则更新独占线程</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        <span class="comment">// 获取失败，则继续尝试</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 同公平锁一样的逻辑</span></span><br><span class="line">            acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 不同之处2：tryAcquire中直接尝试获取锁（不考虑CLH队列情况）</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 上面有分析过</span></span><br><span class="line">        <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非公平获取（上面有分析过，这里仅指出与公平锁的不同）</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 不同之处2：不存在hasQueuedPredecessors的判断，缺少CLH队列校验</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>从代码中可以得知，非公平锁的不同之处有两点：</p><ul><li><code>lock</code>时直接使用<code>CAS</code>尝试获取锁 </li><li><code>acquire不考虑CLH等待队列</code>，直接使用<code>CAS</code>尝试获取锁</li></ul></blockquote><h5 id="unlock"><a href="#unlock" class="headerlink" title="unlock"></a>unlock</h5><p><code>锁的释放</code>会唤醒CLH等待队列中后续的阻塞线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 释放锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// AQS</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AbstractQueuedSynchronizer</span> ... </span>&#123;</span><br><span class="line">    <span class="comment">// 释放锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 尝试释放锁成功（重入情况下不一定释放锁，可能仅减少重入次数）</span></span><br><span class="line">        <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">            Node h = head;</span><br><span class="line">            <span class="comment">// CLH等待队列非空，头结点非初始状态（waitStatus=0为节点初始状态）</span></span><br><span class="line">            <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">                <span class="comment">// 唤醒CLH等待队列中的阻塞线程节点</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 尝试释放</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 减少重入数</span></span><br><span class="line">        <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">        <span class="comment">// 判断锁的所有权</span></span><br><span class="line">        <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">        <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 如果重入数为0，则释放锁并清空独占线程</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            free = <span class="keyword">true</span>;</span><br><span class="line">            setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新锁状态</span></span><br><span class="line">        setState(c);</span><br><span class="line">        <span class="keyword">return</span> free;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 唤醒CLH队列中阻塞的线程</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">        <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">            compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line">        Node s = node.next;</span><br><span class="line">        <span class="comment">// 过滤掉空节点与已删除节点（waitStatus=1）</span></span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            s = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 从对尾开始遍历直到对首，找到一个距离头节点最近的节点唤醒</span></span><br><span class="line">            <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">                <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                    s = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">// 与LockSupport.park对应，停止阻塞线程</span></span><br><span class="line">            LockSupport.unpark(s.thread);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>锁释放过程中需要注意：</p><ul><li>每次<code>tryRelease</code>不一定会释放锁，仅可能<code>减少重入次数</code>；</li><li>如果<code>重入次数为0</code>则代表锁可以释放，可以<code>唤醒CLH等待队列中阻塞的线程</code>。</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从源码层面分析ReentrantLock原理和实现。&lt;/p&gt;
    
    </summary>
    
      <category term="编程语言" scheme="http://simyy.cn/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="编程语言" scheme="http://simyy.cn/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Java" scheme="http://simyy.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>RPC实现原理</title>
    <link href="http://simyy.cn/2020/02/17/rpc/"/>
    <id>http://simyy.cn/2020/02/17/rpc/</id>
    <published>2020-02-17T14:13:16.000Z</published>
    <updated>2020-02-18T10:06:15.958Z</updated>
    
    <content type="html"><![CDATA[<p>本文简单记录下RPC框架的原理。</p><a id="more"></a><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p><code>RPC</code>全称为<code>Remote Procedure Call</code>，译为<code>远程过程调用</code>。</p><p>常见的<code>RPC框架</code>的包括<code>Dubbo</code>、<code>Thrift</code>、<code>Hissan</code>、<code>GRPC</code>等。</p><h4 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h4><p><code>RPC</code>主要是由<code>提供者</code>、<code>消费者</code>和<code>注册中心</code>三部分组成。</p><p><img src="/images/rpc-1.png" alt=""></p><ol><li><p><code>提供者</code>是服务的提供方，需要把自身提供的服务注册到<code>注册中心</code>。</p></li><li><p><code>消费者</code>是服务的消费方，需要从<code>注册中心</code>获取最新的服务提供方的信息。</p></li></ol><p>此外，为了集群消费状态的监控，<code>消费者</code>也需要把自己的地址注册到<code>注册中心</code>。</p><ol start="3"><li><code>注册中心</code>是服务注册和发现的关键，用于保存<code>服务提供者的地址端口</code>以及<code>消费者的地址</code>。</li></ol><h4 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a>注册中心</h4><p>常用的注册中心有<code>Zookeeper</code>、<code>Etcd</code>、<code>Consul</code>和<code>Euerka</code>。</p><p><code>Zookeeper</code>使用<code>zab</code>一致性协议，属于<code>CP</code>。</p><p><code>Etcd</code>和<code>Consul</code>均使用<code>raft</code>一致性协议，属于<code>CP</code>。</p><p><code>Euerka</code>属于<code>AP</code>，主要用于服务发现和注册（存在部分延迟影响不大），因此采用最终一致性。</p><blockquote><p><code>注册中心</code>的中心化问题？</p><p>服务的调用和发现都是依赖<code>注册中心</code>，其高可用尤为重要。</p><p><code>CAP</code>理论是由<code>一致性(C)</code>、<code>可用性(A)</code>、<code>分区备份(P)</code>组成。</p><ul><li><code>可用性(A)</code>：服务是否一直可用，集群环境下选主的方式（多分区）。</li><li><code>一致性(C)</code>：集群环境下的一致性算法包括<code>paxos</code>/<code>zab</code>/<code>raft</code>。</li><li><code>分区备份(P)</code>：数据多分备份。</li></ul></blockquote><h4 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h4><p><code>注册</code>可以分为两种：<code>节点注册</code>和<code>服务注册</code>，</p><ol><li><p><code>节点注册</code>：提供者、消费者，其中，提供者一般需要提供<code>IP</code>和<code>PORT</code>，而消费者仅提供<code>IP</code>；</p></li><li><p><code>服务注册</code>：提供者，仅需要提供当前节点所能提供的rpc服务。</p></li></ol><blockquote><p>注册存在<code>失败</code>的情况，因此需要设置合理的<code>失败重试机制</code>。</p></blockquote><p>注册的具体方式如图所示，</p><p><img src="/images/rpc-2.png" alt=""></p><p><code>/frpc</code>是<code>rpc</code>服务注册的独立命名空间。</p><blockquote><p><code>临时节点</code>的生命周期与注册节点相同，可以用于实现实时监控。</p></blockquote><p><code>非地址节点</code>都属于<code>持久节点</code>，<code>地址节点</code>属于<code>临时节点</code>。</p><p><code>服务隔离</code>是通过<code>/frpc/groupx</code>来实现的，通过把服务注册到不同的节点上来实现服务的隔离。</p><h4 id="发现"><a href="#发现" class="headerlink" title="发现"></a>发现</h4><p><code>发现</code>仅作为<code>消费者</code>的依赖服务获取方式。</p><p><code>发现</code>是通过<code>监控器Watcher</code>的方式来实现服务节点状态的实时更新。</p><h4 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h4><p><code>RPC</code>框架一般采用<code>直连调用</code>的方式来建立消费者和提供者之间的通信。</p><p><code>直连调用</code>的性能最佳，任何代理都会存在性能的损耗。</p><blockquote><p><code>服务网格</code>利用<code>proxy</code>来实现网格之间的调用，为了降低客户端的复杂度，牺牲了网络性能。</p></blockquote><p><code>通信方式</code>包括<code>TCP</code>、<code>UDP</code>、<code>HTTP</code>和<code>HTTP2</code>，常用的是<code>TCP</code>和<code>HTTP2</code>。</p><p><code>TCP</code>是传输层协议，存在粘包问题，需要自定义数据包格式。</p><p><img src="/images/rpc-3.png" alt=""></p><ul><li><code>Magic Number</code>：用于识别数据包的起始位置；</li><li><code>Serialize Type</code>：标识数据的序列化方式；</li><li><code>Packet Type</code>：标识数据包的结构类型；</li><li><code>Data Length</code>：标识数据的大小，用来读取完整的数据包；</li><li><code>Data Bytes</code>：具体数据。</li></ul><p><code>HTTP2</code>是应用层协议，用于取代<code>HTTP</code>，是<code>GRPC</code>中的通信方式。</p><h4 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h4><p><code>路由</code>是指同一服务下不同节点的选择策略，常见的选择策略包括<code>轮询</code>、<code>性能</code>、<code>负载</code>、<code>优先级</code>。</p><p><code>路由</code>一般分为两种：<code>基于客户端的路由</code>与<code>基于代理的路由</code>。</p><p><code>基于客户端的路由</code>是通过消费者自身的客户端来实现节点的选择策略，对消费者自身存在一定的性能消耗。</p><p><code>基于代理的路由</code>是通过部署再消费者环境下的独立存在，不会与消费者产生资源竞争，但存在一层网络性能损耗。</p><p>此外，<code>路由标签</code>可以用于服务的隔离。</p><h4 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h4><p><code>监控的目标</code>可分为两种：</p><ul><li><code>实体</code>：生产者、消费者、服务状态；</li><li><code>性能</code>：接口耗时、接口QPS。</li></ul><p><code>实体数据</code>可以从<code>注册中心</code>直接拉取，不需要提供者和消费者参与。</p><p><code>性能数据的上报</code>采用异步上报的方式，从而避免对服务性能的影响。</p><h4 id="管理"><a href="#管理" class="headerlink" title="管理"></a>管理</h4><p><code>管理</code>可以分为<code>服务管理</code>和<code>节点管理</code>。</p><p><code>服务管理</code>是指服务的<code>生效</code>和<code>失效</code>。</p><p><code>节点管理</code>是指节点的<code>上线</code>、<code>下线</code>和<code>路由权重</code>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文简单记录下RPC框架的原理。&lt;/p&gt;
    
    </summary>
    
      <category term="架构" scheme="http://simyy.cn/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="架构" scheme="http://simyy.cn/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="微服务" scheme="http://simyy.cn/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="RPC" scheme="http://simyy.cn/tags/RPC/"/>
    
  </entry>
  
  <entry>
    <title>消息系统</title>
    <link href="http://simyy.cn/2020/01/11/mq/"/>
    <id>http://simyy.cn/2020/01/11/mq/</id>
    <published>2020-01-11T08:37:10.000Z</published>
    <updated>2020-01-13T02:36:41.643Z</updated>
    
    <content type="html"><![CDATA[<p>记录下最近对消息系统的思考和理解。<br><a id="more"></a><br><img src="/images/mq_6.png" alt=""></p><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p><code>消息系统</code>存在的目的在于：<code>解耦</code>、<code>异步</code>、<code>消峰</code>。</p><p><strong>解耦</strong></p><ul><li><code>依赖关系</code>：组件之间从强依赖变为弱依赖，事件触发通过消息异步同步到依赖组件。</li><li><code>时效</code>：消息系统是一种暂存数据的异步系统，触发的时效是无法保证的。</li></ul><p><strong>异步</strong> </p><ul><li><code>单工</code>：对于生产者和消费者来说，消息系统只是一种单工代理，生产者和消费者无法之间通信。</li><li><code>回调</code>: 异步意味着调用结果无法实时返回，调用结果需要通过配置回调来返回。</li></ul><p><strong>消峰：</strong> </p><ul><li><code>队列</code>：队列的实质是无序变有序、多路变单路，从而降低依赖方的请求压力。</li><li><code>结果</code>：消峰只是一种手段，数据还是需要返回给请求方，可以通过回调或消息的方式返回。</li></ul><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>消息系统可分为<code>代理（Broker）</code>、<code>生产者（Producer）</code>、<code>消费者（Consumer）</code>。</p><p><img src="/images/mq_1.png" alt=""></p><h4 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h4><p><code>消息</code>是数据的载体，用于<code>生产者（Producer）</code>和<code>消费者（Consumer）</code>沟通的媒介。</p><p><strong>数据隔离</strong></p><ul><li><code>主题（Topic）</code>：用于区分不同业务类型的消息，隔离的是不同的业务事件。</li><li><code>分组（Group）</code>：用于区分同一主题下的不同业务方，隔离的是同一主题的不同订阅方。</li></ul><p><img src="/images/mq_2.png" alt=""></p><h4 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h4><p><code>代理（Broker）</code>是用于连接<code>生产者（Producer）</code>和<code>消费者（Consumer）</code>的关键模块。</p><h5 id="隔离方式"><a href="#隔离方式" class="headerlink" title="隔离方式"></a>隔离方式</h5><p><code>代理（Broker）</code>的数据隔离可以分为<code>物理隔离</code>和<code>逻辑隔离</code>，</p><ul><li><code>物理隔离</code>：订阅系统数量和数据备份数量相同，订阅数据之间隔离，缺点明显，浪费存储空间。</li><li><code>逻辑隔离</code>：数据仅有一份，不同系统通过<code>偏移量（Offset）</code>来记录消费进度。</li></ul><blockquote><p><code>逻辑隔离</code>的优点在于数据仅此一份，不同业务系统消费同一份数据，也不会出现数据不一致的情况。</p></blockquote><h5 id="分组管理"><a href="#分组管理" class="headerlink" title="分组管理"></a>分组管理</h5><p><code>分组管理</code>指的是同一<code>Topic</code>下同一<code>Group</code>下不同消费者的管理。</p><p>每一个<code>Topic</code>都会存在多个消费队列，每个消费队列仅能对应一个消费者。</p><blockquote><p>为了维护队列消费进度的Ofsset，不允许并发修改Offset的情况，需要保证<code>队列 : 消费者 = 1 : 1</code></p></blockquote><ul><li><code>代理维护</code>：代理来管理消息队列的分配。</li><li><code>消费者维护</code>：消费者通过选举选择Leader节点用来管理消息队列的分配。</li></ul><p><img src="/images/mq_3.png" alt=""></p><h5 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h5><p>存储方式可以采用传统的<code>BTree索引存储</code>和<code>文件存储</code>两种方式。</p><ul><li><code>BTree存储</code>的查询效率高，但写入效率低。</li><li><code>文件存储</code>的查询效率低，但写入效率高。</li></ul><p>考虑到消息的顺序读写，Kafka采用文件存储存储方式，追加写入日志。</p><blockquote><p><code>Kafka</code>的存储采用了<code>分区(partition)</code>、<code>分段(LogSegment)</code>和<code>稀疏索引</code>来实现高性能。</p></blockquote><p><img src="/images/mq_4.png" alt=""></p><h5 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h5><p><code>数据分区</code>是指数据分布在不同物理机上，可以分为两种方式：<code>逻辑分区</code>、<code>物理分区</code>。</p><ul><li><code>物理分区</code>：数据备份的单位是物理机，物理机备份方式采用主从备份。</li><li><code>逻辑分区</code>：数据备份的单位是数据分片（Partition），分片是按照一主多从的方式来备份。</li></ul><p>数据分片（Partition）的备份与物理机不同，采用数据分片（Partition）的备份不需要关心的物理机</p><p><code>Kafka</code>采用了逻辑分区，<code>RocketMQ</code>才用了物理分区。</p><p><img src="/images/mq_5.png" alt=""></p><h5 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h5><p>在集群环境下，<code>路由</code>是用于快速的定位和发现目标消息所在的位置。</p><p>在<code>kafka</code>中，通过选举功能选择一个<code>Broker</code>作为<code>Leader</code>，负责管理整个集群中<code>Topic</code>、<code>Broker</code>和<code>Partition</code></p><p>在<code>RocketMQ</code>中，<code>NameServer</code>是负责管理整个集群<code>Topic</code>及<code>Broker</code>信息。</p><p><code>RocketMQ</code>未使用<code>Zookeeper</code>，所有<code>Broker</code>的注册都是基于<code>NameServer</code>。</p><h4 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h4><p><code>生产者（Producer）</code>是消息的产生者，需要指定消息对应的<code>主题（Topic）</code>。</p><p><strong>发送方式</strong></p><ul><li><code>同步发送</code>：同步调用代理端，生产者可以感知消息发送的成功与否，确保此次消息的发送。</li><li><code>异步发送</code>：异步调用代理端，生产者无法感知消息发送的成功与否，在发送失败时仅能通过固定次数的重试。</li><li><code>批量发送</code>：也是一种<code>异步发送</code>，但是通过积累更多的消息一次性发送到代理端，主要用于大量消息的场景。</li></ul><p><strong>事务消息</strong></p><p><code>事务消息</code>是用来解决分布式事务的一种方式，它仅保证了消息的消费，如果出现消费失败是无法回滚，只能通过<code>人工介入</code>处理。</p><p>为了实现<code>事务消息</code>，生产者必须保证消息发送到代理端，那么只能选择<code>同步方式</code>来实现。</p><h4 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h4><p><code>消费者（Consumer）</code>是消息的订阅方，需要指定消息对应的<code>主题（Topic）</code>和消费者的<code>分组（Group）</code>。</p><p><strong>消费方式</strong></p><ul><li><code>被动Push</code>：代理端主动推送消息，消费者只需要被动等待，代理端集中管理消息的分发。</li><li><p><code>主动Pull</code>：消费者主动拉取最新的消息，基于轮询的方式。</p><p><code>主动Pull</code>是消息系统常见的消费方式，主动拉取消息减少了代理端的复杂度。</p></li></ul><blockquote><p><code>主动Pull</code>的优点在于把数据分发的压力转移到消费者。</p></blockquote><p><strong>消费进度</strong></p><p>上面提到，<code>消费进度</code>是通过<code>Offset</code>来维护的，<code>Offset</code>的上报决定了消息的消费情况。</p><p><code>实时上报</code>：消费者处理完消息后立刻上报最新的<code>Offset</code>情况。</p><p><code>周期上报</code>：消费者处理完消息后会把消费情况写入缓存，消费者会定期上报最新的<code>Offset</code>情况。</p><p><code>实时上报</code>是同步方式，而<code>周期上报</code>是异步方式。</p><p>同步方式意味着阻塞，吞吐量不如异步方式。</p><p><strong>事务支持</strong></p><p>为了保证消息的成功消费，事务消息需要采用<code>实时上报</code>的方式。</p><p>异步意味着不能实时上报，如果上报失败是无法感知的。</p><p><strong>顺序消费</strong> </p><p>前面提到一个主题可能包括多个消费队列，多个消费队列之间是无法保证消费顺序的。</p><p>为了实现顺序消费，需要业务方按照一定规则把一类消息存储在同一个队列中，从而保证消息被同一个消费者消费。</p><p>但是，如果发生消费者组重新分配的情况会导致顺序消费失效。</p><p><strong>重复消费</strong></p><p>造成<code>重复消费</code>的两种情况：</p><ul><li>异常宕机导致<code>Offset</code>未上报</li><li>消费者线程执行超时无反馈</li></ul><p>上面两种情况均是由于<code>Offset</code>没有及时上报，这是无法避免的，所以需要消费者做好<code>幂等</code>处理。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录下最近对消息系统的思考和理解。&lt;br&gt;
    
    </summary>
    
      <category term="中间件" scheme="http://simyy.cn/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
      <category term="中间件" scheme="http://simyy.cn/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
      <category term="消息队列" scheme="http://simyy.cn/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
      <category term="Kafka" scheme="http://simyy.cn/tags/Kafka/"/>
    
  </entry>
  
  <entry>
    <title>记录2019</title>
    <link href="http://simyy.cn/2020/01/01/2019-look-back/"/>
    <id>http://simyy.cn/2020/01/01/2019-look-back/</id>
    <published>2020-01-01T07:06:41.000Z</published>
    <updated>2020-01-02T09:09:53.332Z</updated>
    
    <content type="html"><![CDATA[<p>毕业后的每一年过的都很快，好像没留下什么记忆。<br><a id="more"></a></p><p>上一次写这样的笔记还是三年前，今天突然想写点啥，可又不知道到底能写点啥。</p><h4 id="杭州"><a href="#杭州" class="headerlink" title="杭州"></a>杭州</h4><p>记得2017年来到杭州，匆匆忙忙租了临时住所，开始了装修的漫漫长路。</p><blockquote><p>高温、潮湿的天气</p></blockquote><p>杭州是一个没有春秋的城市，夏天很热，冬天很冷。</p><p>杭州的冬天与北方不同，整个冬天都在阴雨中度过，实在是不舒服。</p><p>当时租的是一个八十年的六层楼中的二楼，虽说屋子的两件卧室都是朝南的，但梅雨季时北侧的墙面、玻璃全是水滴。</p><p>为了对抗梅雨季，买了一台烘焙机，真的是神器，不过后来搬家后再也没有用过。</p><p>新家楼层很高，一点都不潮了，所以南方买房子真的不能买低楼层。</p><p>冬天的魔法攻击真不是闹着玩的，物理保暖装备还是有限，尤其是在没有采暖的屋子里，只能靠发抖了。</p><p>作为一个怕冷的北方人，理所当然的装上了地暖。</p><h4 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h4><p>来到杭州之后再没有挤过地铁，也几乎没做过公交车，一台小电驴就足够了。</p><blockquote><p>混乱的交通</p></blockquote><p>一直以来的主要交通工具都是电瓶车，由于每天上班都很晚，也从来没有赶上过电瓶车大军，偶而会遇到一次，真的会堵车（电瓶车）。</p><p>以前一直很羡慕人家开车，去年和老婆商量下买了台代步车，看了没几家迷迷糊糊的就定了。</p><p>虽然有车了，也没去过啥地方，每周最爱去的就是超市了，买上一周的吃的，宅在家里学习、看剧，好像对我俩来说这就是最舒服的事了。</p><p>其实，最开心的是买第一台电瓶车的时候，那天还下着雨，骑着小电驴载着我俩慢悠悠的回家了。</p><h4 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h4><p>来杭州有两年半的时间了，工作上说不上顺利，但肯定的是自己成长了不少。</p><blockquote><p>经济寒冬</p></blockquote><p>在刚来杭州的时候就听做金融的同学说，这两年的经济会很差，首当其冲的就是互联网。</p><p>没想到真的发生在自己的身上，一个三流互联网公司把整个业务线、分公司全部裁掉，这样的事情从来没有听说过、没有想到过。</p><blockquote><p>奋斗逼之都</p></blockquote><p>除了旅游之都、互联网之都，杭州还被称为奋斗逼之都。</p><p>在毕业那会，大家都认为华为是最坑的，什么996、奋斗者协议都是华为搞出来的，大家都以这个为耻。</p><p>那会大家都希望能够进入互联网公司，因为它们代表了自由、开放、民主。</p><p>不知道从何时开始，B已经成为了杭州的标识，也成为了996的代名词。</p><p>目前来看，在杭州最累的肯定不是华为，因为大多数公司都在崇尚加班文化。</p><p>在我眼里，大多数的加班等同于低效率的工作，包括低效率的会议模式、无意义的会议主题、毫无依据的产品需求，可能这就是大公司的病（传染病）吧。</p><blockquote><p>团队与管理</p></blockquote><p>来到杭州后，也从单纯的开发岗位逐渐转变为技术管理，开始授人以渔。</p><p>对于团队来说，最重要的是信任（大家相互信任）。</p><p>见过一些团队，面对问题，团队的每一个人都不愿意承担，到最后，这个团队流动性很大，每个人也不会有太多成长。</p><p>想把团队做好一定要帮忙大家成长，自然而然的团队也会成长，其实自己在这个过程中也会不断成长。</p><h4 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h4><p>这一年杂七杂八看了不少书，也总结了不少技术知识。</p><p>这两年虽然博客更新的不多，但笔记还是做了不少，只是不太成章。</p><blockquote><p>曾经有人和我讲过，认知可以划分为三个阶段：三年、五年、八年。</p></blockquote><p>今年已经是第五年了，认知确实和三年时大有不同。</p><p>其实技术只是基础，合理的使用技术帮助团队把收益最大化才是最重要的。</p><p>很多翻过的旧书再看一遍会有所不同的理解。</p><p>这几年的经历让思想从点到面的转变，更加注重架构的选型、演进，保证需求的持续交付和快速迭代。</p><h4 id="未来"><a href="#未来" class="headerlink" title="未来"></a>未来</h4><p>已经30多岁的人了，下次写也不清楚是啥时候了。</p><p>自从上班后，感觉时间过得飞快，没有留下什么记忆，有时候会想这样生活值得么？</p><p>人的一生都是在探索，不知道明天会发生什么。</p><p>父母慢慢的老了，有一次视频中突然发现父母好像老了很多，明年希望能多带父母出去逛逛。</p><blockquote><p>我的价值是什么？</p></blockquote><p>对于家庭，健康生活是最大的价值。</p><p>对于社会，努力工作（并不是说996）是最大的价值。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;毕业后的每一年过的都很快，好像没留下什么记忆。&lt;br&gt;
    
    </summary>
    
      <category term="生活" scheme="http://simyy.cn/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="生活" scheme="http://simyy.cn/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>分库分表</title>
    <link href="http://simyy.cn/2019/12/28/sharding/"/>
    <id>http://simyy.cn/2019/12/28/sharding/</id>
    <published>2019-12-28T02:00:25.000Z</published>
    <updated>2019-12-28T02:04:58.748Z</updated>
    
    <content type="html"><![CDATA[<p>分库分表是为了解决数据库读写的性能问题。</p><a id="more"></a><h4 id="分片方案"><a href="#分片方案" class="headerlink" title="分片方案"></a>分片方案</h4><p>分库分表的分片方案包括：<code>应用层分片</code>和<code>中间件分片</code>。</p><p><img src="/images/sharding_1.png" alt="分片方案"></p><hr><p><strong>应用层分片：</strong> 分片逻辑耦合在应用系统中，直连数据库。</p><p><strong>优势:</strong> 在于<code>直连</code>，性能更好，运维成本低。</p><p><strong>劣势:</strong> 由于耦合在应用系统中，升级问题较为麻烦，需要每个应用重新升级发布。</p><p>常见的方案有<code>Sharding-jdbc</code>、<code>TDDL</code>。</p><hr><p><strong>中间件分片：</strong> 分片逻辑作封装为独立中间件，独立部署，作为应用系统与数据库之间的代理。</p><p><strong>优势:</strong> 对应用系统无入侵，独立部署后也仅需升级中间件。</p><p><strong>劣势:</strong> 独立部署运维成本高，代理模式增加性能消耗。</p><p>常见的方案有<code>Atlas</code>、<code>Mycat</code>、<code>Cobar</code>.</p><hr><h4 id="数据切分"><a href="#数据切分" class="headerlink" title="数据切分"></a>数据切分</h4><blockquote><p>数据的切分方式分为两种：<code>垂直切分</code>和<code>水平切分</code>。</p></blockquote><p><code>垂直切分</code>是基于<code>业务边界</code>拆分的，数据相对独立，拆分几乎无副作用。</p><p><code>水平切分</code>是基于<code>业务逻辑</code>拆分的，是为了解决大表的拆分策略。</p><blockquote><p>在系统演进的过程中一般都会先经历<code>垂直切分</code>然后再经历<code>水平切分</code>。</p></blockquote><h5 id="垂直切分"><a href="#垂直切分" class="headerlink" title="垂直切分"></a>垂直切分</h5><p><code>垂直切分</code>是指按照业务将表进行分类，重新分配到不同的数据库上，从而实现请求压力的拆分。</p><p><img src="/images/sharding_1.png" alt="垂直切分"></p><p><strong>优点：</strong></p><ul><li>切分规则清晰（划分数据边界）</li><li>切分后数据维护性不变（原有<code>SQL</code>无影响）</li><li>切分后请求压力会由不同业务数据库独自承担（业务之间无影响）</li></ul><p><strong>缺点：</strong></p><ul><li>不同业务之间的事务处理复杂（涉及到分布式事务）</li><li>不同业务之间的表无法<code>JOIN</code>，需要做关联查询（<code>HTTP/RPC</code>）</li></ul><p>在垂直切分情况下，可能存在一张表拆分为多张表的情况，那么原有的<code>直接查询</code>可能就需要修改为<code>关联查询</code>。</p><p>为了避免<code>关联查询</code>带来的性能损耗，在满足业务的情况下，可以冗余部分字段信息来避免关联查询。</p><h5 id="水平切分"><a href="#水平切分" class="headerlink" title="水平切分"></a>水平切分</h5><p><code>水平切分</code>是指按业务逻辑对表中数据行的切分，把单表数据分配到多个数据库及多个表中，从而实现请求压力的拆分。</p><p><code>水平切分</code>注重的是<code>大表的切分</code>，是基于大表中<code>某个字段</code>的<code>某种规则</code>的切分。</p><blockquote><p>什么是大表？</p><p>业界公认MySQL单表容量在<code>1KW</code>以下是最佳状态，因为这时它的<code>B+TREE索引树高在3~5之间</code>。</p></blockquote><p><img src="/images/sharding_1.png" alt="水平切分"></p><p><strong>优点：</strong></p><ul><li>切分后不存在单库大表，读写性能更好</li></ul><p><strong>缺点：</strong></p><ul><li>切分规则会对SQL存在影响（任何SQL都需要带有<code>Sharding Key</code>）</li><li>跨库查询性能差，跨库事务处理复杂（涉及到分布式事务）</li><li>需要考虑后期数据的二次扩展</li><li>数据归档与归档查询</li><li>跨库<code>JOIN</code>性能差</li></ul><h4 id="切分策略"><a href="#切分策略" class="headerlink" title="切分策略"></a>切分策略</h4><p>由于<code>垂直切分</code>是基于业务边界的切分，需要问题在于业务边界的划分，这里不再讨论。</p><p>这里仅分析<code>水平切分</code>。</p><blockquote><p><code>切分策略</code>可以分为：<code>Hash切分</code>和<code>Range切分</code>。</p></blockquote><p><code>数据切分</code>都是基于<code>Sharding Key</code>的，而<code>Sharding Key</code>的选择与业务SQL是强关联的。</p><p>例如，数据库应存在1亿的用户数据，此时需要对用户表进行切分，考虑到业务场景下，大部分的请求都是基于用户纬度来查询的，因此使用用户ID作为<code>Sharding Key</code>来做数据切分。</p><h5 id="Hash切分"><a href="#Hash切分" class="headerlink" title="Hash切分"></a>Hash切分</h5><p><code>Hash切分</code>是最为常用的切分策略，一般采用<code>取模MOD</code>来切分数据表，但其水平扩展会造成<code>数据的迁移</code>。</p><p><img src="/images/sharding_4.png" alt="Hash切分"></p><p>建议取模方式：<code>MOD（2^n）</code>，可以避免部署数据的迁移，例如，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10 % 4 == 10 % 8 == 2</span><br></pre></td></tr></table></figure><blockquote><p>考虑到水平扩展的性能，可以使用一致性Hash算法来切分数据。</p></blockquote><h6 id="一致性Hash切分"><a href="#一致性Hash切分" class="headerlink" title="一致性Hash切分"></a>一致性Hash切分</h6><p>与哈希方法一样，<code>Hash环</code>利用环形形状来表示<code>取模MOD</code>后节点分布情况。</p><p>但是在节点扩容的情况下，不再需要</p><blockquote><p>一致性Hash的优势在于：节点扩容和缩容不会导致大量数据的迁移。</p></blockquote><p><code>一致性Hash</code>的关键：</p><ul><li><code>顺序针</code>寻找最近的节点作为存储数据存储节点</li><li>利用<code>虚拟节点</code>来均衡各个节点的负载情况</li></ul><p><img src="/images/sharding_5.png" alt="一致性Hash"></p><h5 id="Range切分"><a href="#Range切分" class="headerlink" title="Range切分"></a>Range切分</h5><p><code>Range切分</code>是利用数据<code>时间</code>或<code>ID</code>来切分数据表，常用于日志、归档数据的切分，是一种顺序切分。</p><p>切分规则可控，水平扩展不会造成数据迁移，扩展更容易。</p><p>由于数据是按顺序切分的，无法解决集中写入瓶颈的问题，而且存在跨库跨表查询性能查。</p><p><img src="/images/sharding_6.png" alt="Range切分"></p><h4 id="拆分数量"><a href="#拆分数量" class="headerlink" title="拆分数量"></a>拆分数量</h4><p>数据库一般被部署在物理机上，其性能受物理机的影响。</p><blockquote><p>数据库的性能与CPU、内存有直接关系。</p></blockquote><p>常见情况下，一台物理机部署多个数据库实例，多个数据库实例共享同一台主机的性能。</p><p>由于物理机的性能有限，所以在同一台物理机上增加过多的实例是无效的。</p><blockquote><p><strong>集群性能的定义：</strong></p><p><code>Sharding集群性能 = Sharding集群物理机的数量 * 单台物理机的性能</code></p></blockquote><p>具体拆分方式不仅需要通过业务场景来决定的，而且需要DBA合理部署<code>Sharding集群</code>，从而才能实现Sharding集群性能的最大化。</p><h4 id="分布式唯一ID"><a href="#分布式唯一ID" class="headerlink" title="分布式唯一ID"></a>分布式唯一ID</h4><p>在单库单表的情况下，直接使用数据库<code>自增ID</code>。</p><p>在分库分表的情况下，数据分布在不同库表上，无法使用数据库<code>自增特性</code>，需要使用<code>分布式唯一ID</code>。</p><h5 id="UUID"><a href="#UUID" class="headerlink" title="UUID"></a>UUID</h5><p><code>UUID</code>一般通过本地网卡、时间和随记数来生成。</p><ul><li>16字节128位，36个字符长度不适合做主键，存储成本高</li><li>无序，作为主键时会导致B+树索引在写的时候有过多的随机写操作</li></ul><blockquote><p>聚集主键的InnoDB会按照主键进行数据排序，因此要求分布式唯一ID具有<code>有序性</code>；</p></blockquote><h5 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h5><p><code>Redis</code>提供了<code>incr/increby</code>原子操作，从而可以用来生成分布式ID。</p><ul><li>基于内存自增生成ID，性能较好</li><li>内存自增操作保证ID有序</li><li>单机部署存在可用性问题，需要集群解决单点问题</li><li>双击部署、数据持久化</li></ul><blockquote><p>数据库在插入数据时对分布式ID是强依赖，如果出现问题会导致无法正常插入数据，所以需要保证分布式ID生成器的高可用。</p></blockquote><p>使用<code>incr</code>仅可以生成一个ID；<br>使用<code>increby</code>可以批量生成多个ID，可用于批量插入数据；</p><h5 id="Snowflake"><a href="#Snowflake" class="headerlink" title="Snowflake"></a>Snowflake</h5><p><code>Snowflake</code>是<code>Twitter</code>利用<code>Zookeeper</code>实现了一个全局ID生成的服务。</p><p><code>Snowflake</code>生成的<code>分布式唯一ID</code>的组成 (由高位到低位):</p><ul><li>41 bits: Timestamp (毫秒级)</li><li>10 bits: 节点 ID (datacenter ID 5 bits + worker ID 5 bits)</li><li>12 bits: sequence number</li></ul><p><img src="/images/sharding_7.png" alt="雪花算法"></p><p><strong>优点：</strong></p><ul><li>高性能，低延迟</li><li>按时间有序</li></ul><p><strong>缺点：</strong></p><ul><li>强依赖机器时钟，如果机器上时钟回拨，会导致发号重复或者服务会处于不可用状态</li></ul><h5 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h5><p><a href="https://tech.meituan.com/2017/04/21/mt-leaf.html" target="_blank" rel="noopener">Leaf——美团点评分布式ID生成系统</a></p><h4 id="数据迁移"><a href="#数据迁移" class="headerlink" title="数据迁移"></a>数据迁移</h4><p><code>数据迁移</code>是分库分表的重要工作，按照切分逻辑把历史数据迁移至新的分库分表数据库中。</p><p>常见的两种方式：<code>停机迁移</code>和<code>在线迁移</code>。</p><h5 id="停机迁移"><a href="#停机迁移" class="headerlink" title="停机迁移"></a>停机迁移</h5><p> 数据迁移过程中需要<code>停止相关服务</code>，优势在于迁移过程简单。</p><p> 由于迁移过程中不会产生新的数据，所以迁移过程仅需要一次，迁移完成后恢复服务运行。</p><p> 此方法仅适用于那些调用频次低、暂时停机无影响的服务。</p><h5 id="在线迁移"><a href="#在线迁移" class="headerlink" title="在线迁移"></a>在线迁移</h5><p>数据迁移过程中服务正常运行，优势在于不影响系统运行，但迁移过程复杂。</p><p><strong>迁移步骤为：</strong></p><ul><li>在不影响主库的情况下，基于从库同步历史数据到目标库表中</li><li>上一步同步完成后，切换数据写入开关状态到<code>双写状态1</code>（同步写入历史库表、异步写入切分库表）</li><li>定期检查历史库表和切分库表的数据差异，如果存在数据差异，再次同步差异数据到切分库表</li><li>当数据基本无差异的情况下，切换数据开关状态到<code>双写状态2</code>（同步写入切分库表、异步写入历史库表），此时读写迁移至切分库表</li><li>定期检查历史库表和切分库表的数据差异，如果存在数据差异，再次同步差异数据到历史库表</li><li>稳定运行一段时间后才可以停止历史库表的写入，否则无法实现切分的回滚</li></ul><blockquote><p><code>双写状态</code>这里需要注意下，尽量避免双数据源的同步写入，辅助同步逻辑可以通过异步方式实现。</p></blockquote><p><img src="/images/sharding_8.png" alt="数据迁移"></p><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><blockquote><p>只有当数据库性能不能满足业务发展时，才真的需要进行分库分表。</p></blockquote><p>分库分表只会给系统增加复杂度，原本一条SQL可以处理的数据，跨库操作存在大量的网络延迟及数据聚合，将会带来大量的性能损耗。</p><hr><blockquote><p>分库分表不是必须的！</p></blockquote><p>有些场景下，数据是可以通过<code>归档的方式</code>来减少数据的量级。</p><p><code>ES+HBase</code>是比较常见的归档方案，其中，<code>ES</code>仅存储索引字段，<code>HBase</code>存储全量数据。</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://www.infoq.cn/article/ZMlCBpIhOThWJeqmZD4I" target="_blank" rel="noopener">数据库分库分表基础和实践</a><br><a href="https://www.cnblogs.com/405845829qq/p/7552750.html" target="_blank" rel="noopener">MySQL分库分表方案</a><br><a href="https://zhuanlan.zhihu.com/p/24036067" target="_blank" rel="noopener">大众点评订单系统分库分表实践</a><br><a href="https://cloud.tencent.com/developer/article/1448626" target="_blank" rel="noopener">分库分表最佳实践</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;分库分表是为了解决数据库读写的性能问题。&lt;/p&gt;
    
    </summary>
    
      <category term="架构" scheme="http://simyy.cn/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="架构" scheme="http://simyy.cn/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="Sharding" scheme="http://simyy.cn/tags/Sharding/"/>
    
  </entry>
  
  <entry>
    <title>SOLID设计原则</title>
    <link href="http://simyy.cn/2019/12/21/solid-priciple/"/>
    <id>http://simyy.cn/2019/12/21/solid-priciple/</id>
    <published>2019-12-21T08:14:27.000Z</published>
    <updated>2019-12-21T09:26:17.483Z</updated>
    
    <content type="html"><![CDATA[<p>SOLID设计原则主要用于解决如何构建可持续性的软件架构。</p><a id="more"></a><h4 id="SRP"><a href="#SRP" class="headerlink" title="SRP"></a>SRP</h4><p><code>SRP</code>全称为<code>Single Responsibility Principle</code>，译为<code>单一职责原则</code>。</p><p><strong>定义：</strong></p><blockquote><p>There should never be more than one reason for a class to change.</p><p><code>任何一个软件模块都应该有且仅有一个被修改的原因</code>。</p></blockquote><p>在<code>Clean Architecture</code>中，重新定义如下:</p><blockquote><p><code>任何一个软件模块都应该只针对某一类行为负责</code>。</p></blockquote><p>相比之下，第二种定义更让人容易理解，因为它是站在<code>职责边界</code>的角度来分析职责的划分。</p><p>在面向对象的设计中，<code>高内聚、低耦合</code>是评判一个软件设计好坏的标准。</p><blockquote><p><code>内聚</code>：模块内部元素之间关联的程度。<br><code>耦合</code>：模块之间关联的程度。</p></blockquote><p><code>高内聚</code>与<code>低耦合</code>相辅相成，<code>高内聚</code>自然会带来<code>低耦合</code>的效果。</p><p>在软件设计层面上，<code>SRP</code>是一种抽象概念，与<code>高内聚、低耦合</code>是同样的目的，都是为了实现模块功能的职责独立。</p><p>“模块仅负责<code>某一类行为</code>“ 不就是<code>高内聚</code>的一种表现方式。</p><hr><blockquote><p>如何实现<code>SPR</code>？</p></blockquote><p>上面有提到实现<code>SPR</code>的关键在于<code>聚类行为</code>，那么行为如何聚类呢？</p><p>利用<code>领域驱动设计</code>的思想找到模块的边界，从而实现行为的归类。</p><hr><h4 id="OCP"><a href="#OCP" class="headerlink" title="OCP"></a>OCP</h4><p><code>OCP</code>全称为<code>Open Closed Principle</code>，译为<code>开闭原则</code>。</p><p><strong>定义：</strong></p><blockquote><p>Software entities (classes, modules, functions, etc.) should be open for extension, but closed for modification.</p><p><code>一个软件实体（如类，模块和函数）应该对扩展开放，对修改关闭。</code></p></blockquote><p><code>Open</code>对应的是<code>扩展</code>，<code>Closed</code>对应的是<code>修改</code>。</p><p>换一个角度来思考<code>OCP</code>，面对需求变化是否需要修改历史代码？</p><blockquote><p><code>软件设计应该通过扩展来实现变化，而不是通过修改来实现变化。</code></p></blockquote><p><code>修改</code>意味着改变原有逻辑，变化可能带来副作用，尤其对于那些年久失修、无人维护的代码来说。</p><p>因此，强调通过<code>扩展</code>的方式来拥抱需求变化更为合适，而这里的扩展的手段是<code>抽象化</code>。</p><hr><blockquote><p>如何实现<code>OCP</code>？</p></blockquote><p><code>抽象化</code>是实现<code>OCP</code>的关键，具体可以通过<code>面向接口编程</code>和<code>面向抽象编程</code>。</p><p>通过<code>接口和抽象</code>来限定功能范围，具体行为通过具体实现来控制（<code>多态</code>和<code>继承</code>）。</p><p>模块之间的依赖仅通过<code>接口和抽象</code>来关联，与具体逻辑无关，每当需求发生变更的时候，在不改变<code>接口和抽象</code>的前提下通过增加新的实现来满足需求。</p><hr><h4 id="LSP"><a href="#LSP" class="headerlink" title="LSP"></a>LSP</h4><p><code>LSP</code>全称为<code>Liskov Substitution Principle</code>，译为<code>里氏替换原则</code>。</p><p><strong>定义：</strong></p><blockquote><p>Functions that use pointers or references to base classes must be able to useobjects of derived classes without knowing it.</p><p>引用基类的地方都可以透明地使用其子类对象。</p></blockquote><p><code>LSP</code>的关键在于<code>可替换</code>。</p><p>在面向对象的编程方式中，<code>可替换</code>可以基于<code>继承</code>来实现。</p><p><code>继承</code>的特点是<code>子类</code>拥有<code>父类</code>所有堆外暴露的功能。</p><p>在实际情况下，<code>继承</code>的使用方式：</p><ul><li><code>代码复用</code>，父类实现共享方法，父类方法不可被重写，父类可实例化</li><li><code>代码复用+多态</code>，父类实现共享方法，并提供待子类实现的抽象方法，<code>父类一般为抽象类，不允许实例化</code></li></ul><p><code>LSP</code>中的<code>可替换</code>也就是多态的一种表现，通过<code>接口</code>和<code>抽象类</code>来做模块之间的关联，与模块的具体实现无关。</p><blockquote><p><code>OCP</code>和<code>LSP</code>是相辅相成的，</p><p>前者关注<code>扩展</code>来解决模块内部变化的问题，后者关注<code>可替换</code>来解决模块之间逻辑变化的问题。</p></blockquote><h4 id="ISP"><a href="#ISP" class="headerlink" title="ISP"></a>ISP</h4><p><code>ISP</code>全称为<code>Interface Segregation Principle</code>，译为<code>接口隔离原则</code>。</p><p><strong>定义：</strong></p><blockquote><p>The dependency of one class to another one should depend on the smallest possible interface.</p><p>类间的依赖关系应该建立在最小的接口上。</p></blockquote><p><code>ISP</code>的关键在于<code>功能的划分</code>。</p><p><code>ISP</code>的目的在于避免过多的功能暴露给依赖方，也就是解决<code>Fat Interface</code>。</p><p><code>SRP</code>的目的在于<code>职责的划分</code>，属于边界划分的范畴，而<code>ISP</code>更倾向于<code>功能聚类</code>，让依赖者不必关心不需要的功能方法。</p><p>职责下所涉及的功能如果太多，可以划分为多个功能聚类来简化功能的检索，不仅可以帮忙开发者更好管理功能，也可以帮忙依赖方对接口功能的划分更加清晰。</p><hr><blockquote><p>先满足<code>ISP</code>还是<code>SRP</code>？</p></blockquote><p>在软件设计初期需要考虑的是<code>SRP</code>，职责的划分更为重要。</p><p>在解决职责问题之后，在功能设计阶段就需要考虑<code>ISP</code>，包括</p><ul><li>解决<code>Fat Interface</code>的问题</li><li>功能方法聚类，隔离无关功能，让依赖变得更简单</li></ul><hr><h4 id="DIP"><a href="#DIP" class="headerlink" title="DIP"></a>DIP</h4><p><code>DIP</code>全称为<code>Dependency Inversion Principle</code>，译为<code>依赖倒置原则</code>。</p><p><strong>定义：</strong></p><blockquote><p>High level modules should not depend upon low level modules. Both should depend upon abstractions. Abstractions should not depend upon details. Details should depend upon abstractions.</p><p>高层模块不应该依赖于低层模块，两者都应该依赖于抽象；抽象不应该依赖于细节，细节应该依赖于抽象。</p></blockquote><p>当修改接口的时必然会修改实现，但修改实现不需要修改接口。</p><blockquote><p>接口比实现更稳定。</p></blockquote><p>任何具体逻辑的实现及修改和接口抽象无关，依赖方只需要关注接口是否变化，并不需要关注细节本身（这往往是分工开发中需要注意的问题）。</p><blockquote><p><code>DIP</code>是一种<code>松耦合</code>的设计原则。</p></blockquote><p><code>DIP</code>是站在抽象的角度上来建立模型，更类似于伪代码，确定整体的设计思路（模块或功能间的耦合关系）。</p><p><code>OCP</code>、<code>LSP</code>是具体的实现方式，通过<code>扩展</code>和<code>替换</code>来实现不同逻辑细节。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;SOLID设计原则主要用于解决如何构建可持续性的软件架构。&lt;/p&gt;
    
    </summary>
    
      <category term="架构" scheme="http://simyy.cn/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="架构" scheme="http://simyy.cn/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="软件设计" scheme="http://simyy.cn/tags/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>Reactor &amp; Proactor</title>
    <link href="http://simyy.cn/2019/12/16/re-pro-actor/"/>
    <id>http://simyy.cn/2019/12/16/re-pro-actor/</id>
    <published>2019-12-16T14:52:17.000Z</published>
    <updated>2019-12-17T02:25:10.605Z</updated>
    
    <content type="html"><![CDATA[<p>总结常见的两种网络模型设计模式Reactor和Proactor。</p><a id="more"></a><h3 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h3><p>在网络模型设计中，有两个的高性能模型：<code>Reactor</code>和<code>Proactor</code>。</p><p>这里会涉及到<code>同步/异步</code>、<code>阻塞/非阻塞</code>两个知识点。</p><p><strong>同步/异步</strong>：应用程序和系统内核之间交互（通信）方式，主动监听还是被动通知。</p><p><code>select/poll/epoll</code>都需要用户程序不断轮询检查IO操作是否就绪，所以它们都属于<code>同步IO</code>。</p><p><code>Boost.Asio</code>通过对<code>epoll</code>的二次封装实现了<code>异步IO</code>，WIN下的<code>IOCP</code>同样也属于<code>异步IO</code>；</p><p><strong>阻塞/非阻塞</strong>：用户进程执行IO操作后如何等待调用结果。</p><p>进程挂起等待属于<code>阻塞</code>，进程直接返回等待下次重试属于<code>非阻塞</code>。</p><h3 id="Reactor"><a href="#Reactor" class="headerlink" title="Reactor"></a>Reactor</h3><p><code>Reactor</code>属于<code>同步非阻塞</code>模型。</p><p><strong>同步</strong>：同步监听，需要用户端主动监听IO就绪状态。</p><p><strong>非阻塞</strong>：用户进程执行IO操作后不会导致用户进程的挂起，会通过重试的方式来尝试获取执行结果。</p><p>Reactor模型中，主要分为<code>Acceptor</code>、<code>Reactor</code>、<code>Handler</code>三个主要组件。</p><ul><li><strong>Acceptor</strong>：获取客户端链接，绑定客户端注册事件。</li><li><strong>Reactor</strong>：监控触发的事件，并分发给对应的事件处理器。</li><li><strong>Handler</strong>：处理对应的事件请求，例如，读写处理器、加解密处理器、命令执行处理器等。</li></ul><p><code>Reactor组件</code>是模型中的关键组件（也是和<code>Proactor</code>的不同之处），包括以下两部分：</p><ul><li>通过不断轮询<code>select/epoll</code>来监听准备就绪的事件；</li><li>通过<code>Dispatch</code>来分发事件到对应的时间处理器。</li></ul><blockquote><p><code>Reactor</code>中的读和写是由<code>应用程序</code>来决定何时操作的。</p></blockquote><p>Reactor模型的实现方式：<code>单Reactor单处理器</code>、<code>单Reactor多处理器</code>、<code>多Reactor多处理器</code>。</p><h5 id="单Reactor单处理器"><a href="#单Reactor单处理器" class="headerlink" title="单Reactor单处理器"></a>单Reactor单处理器</h5><p><code>单Reactor单处理器</code>也就是简单的单线程模型。</p><p><img src="/images/RE_PRO_ACTOR_1.png" alt=""></p><h5 id="单Reactor多处理器"><a href="#单Reactor多处理器" class="headerlink" title="单Reactor多处理器"></a>单Reactor多处理器</h5><p><code>单Reactor多处理器</code>是通过处理器多线程化来实现并发能力，但是需要考虑多处理器的并发情况下<code>资源竞争</code>的问题。</p><p><img src="/images/RE_PRO_ACTOR_2.png" alt=""></p><h5 id="多Reactor多处理器"><a href="#多Reactor多处理器" class="headerlink" title="多Reactor多处理器"></a>多Reactor多处理器</h5><p><code>多Reactor多处理器</code>是在<code>单Reactor多处理器</code>的基础之上，分离了<code>Acceptor</code>的能力，并且增加多个<code>子Reactor</code>来实现分而治之的方法。</p><p><img src="/images/RE_PRO_ACTOR_3.png" alt=""></p><h3 id="Proactor"><a href="#Proactor" class="headerlink" title="Proactor"></a>Proactor</h3><p><code>Reactor</code>属于<code>异步非阻塞</code>模型。</p><p><strong>异步</strong>：异步回调，系统自动回调用户程序通知IO就绪状态。</p><p><strong>非阻塞</strong>：同<code>Reactor</code>。</p><p><code>Proactor</code>模型中，主要分为<code>Proactor</code>、<code>Proactor Initiator</code>、<code>Handler</code>、<code>Asynchronous Operation Processor</code>四个主要组件。</p><ul><li><strong>Asynchronous Operation Processor</strong>：异步操作处理器，操作系统提供；</li><li><strong>Proactor Initiator</strong>：事件注册器，用于注册事件以及对应的事件处理器；</li><li><strong>Proactor</strong>：用于监听触发的事件，并分发给不同的事件处理器处理；</li><li><strong>Handler</strong>：同<code>Reactor</code>。</li></ul><p><img src="/images/RE_PRO_ACTOR_4.png" alt=""></p><blockquote><p>在<code>Proactor</code>中，<code>数据的读写</code>都是由<code>系统内核</code>来实现的，<code>应用程序</code>只是从<code>缓存区</code>上进行读写。</p></blockquote><p>Proactor模型的关键在于系统提供的<code>Asynchronous Operation Processor</code>异步操作处理器。</p><blockquote><p>由于基于<code>缓存区的</code>交互方式，<code>Proactor</code>中的读和写是<code>操作系统</code>来决定何时操作的。</p></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>Reactor</code>和<code>Proactor</code>均为非阻塞I/O模型。</p><p><code>Reactor</code>是同步的（主动查询），<code>Proactor</code>是异步的（被动通知）。</p><p><code>Proactor</code>接收到的是IO操作已完成事件（缓存区），<code>Reactor</code>接收到的是IO操作就绪事件。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://mp.weixin.qq.com/s?__biz=MzUyNzgyNzAwNg==&amp;mid=2247483941&amp;idx=1&amp;sn=97628f4d69d8607badf39bfeb7557457&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">彻底搞懂Java的网络IO</a><br><a href="https://zhuanlan.zhihu.com/p/35065251" target="_blank" rel="noopener">Linux 的 IO 通信 以及 Reactor 线程模型浅析</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总结常见的两种网络模型设计模式Reactor和Proactor。&lt;/p&gt;
    
    </summary>
    
      <category term="架构" scheme="http://simyy.cn/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="中间件" scheme="http://simyy.cn/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
      <category term="网络" scheme="http://simyy.cn/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="架构" scheme="http://simyy.cn/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="网络模型" scheme="http://simyy.cn/tags/%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>分布式任务调度</title>
    <link href="http://simyy.cn/2019/12/08/distributed-job-dispatch/"/>
    <id>http://simyy.cn/2019/12/08/distributed-job-dispatch/</id>
    <published>2019-12-08T04:19:34.000Z</published>
    <updated>2019-12-17T02:24:47.671Z</updated>
    
    <content type="html"><![CDATA[<p>任务调度解决定时触发的问题，分布式解决单点触发的问题。</p><a id="more"></a><h3 id="任务调度"><a href="#任务调度" class="headerlink" title="任务调度"></a>任务调度</h3><blockquote><p><code>任务调度</code>来<code>触发</code>那些无法自动触发的任务。</p></blockquote><p>任务调度中最重要的三个基础组件：<code>任务</code>、<code>触发器</code>和<code>执行器</code>。</p><p><strong>任务</strong>：保存待处理的任务，包括任务的触发的关键信息（例如，目标地址、调用方式、触发参数）。</p><p><strong>触发器</strong>：保存待处理任务的执行时间，包括定时触发、周期触发。</p><p><strong>执行器</strong>：任务触发的媒介，任务达到触发状态后都交于执行器来触发任务的执行。</p><h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p>任务调度的组件大体依赖关系如下图，</p><p><img src="/images/distributed_job_dispatch_1.png" alt="组件依赖关系"></p><p><strong>任务的创建和触发流程</strong>：</p><ul><li>创建<code>Job</code>，并指定具体的任务类型（<code>RpcJob</code>或<code>HttpJob</code>）；</li><li>创建<code>Trigger</code>作为任务的触发器，指定任务触发方式（<code>TimeTrigger</code>或<code>CrondTrigger</code>）；</li><li>计算<code>Trigger</code>下一次触发时间；</li><li>关联<code>Job</code>和<code>Trigger</code>，用于组装<code>JobContext</code>；</li><li>扫描<code>最近一段时间内</code>待触发的<code>Trigger</code>，并组装对应的<code>JobContext</code>；</li><li><code>Executor</code>拉取待触发的<code>JobContext</code>，按<code>Trigger</code>指定的执行时间来执行<code>Job</code>。</li></ul><h4 id="任务状态"><a href="#任务状态" class="headerlink" title="任务状态"></a>任务状态</h4><p>任务调度系统的状态可划分为：</p><p><img src="/images/distributed_job_dispatch_2.png" alt="任务状态流转图"></p><h3 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h3><p>对于单机任务调度系统来说，存在问题包括：<code>单点故障</code>、<code>任务堆积</code>。</p><blockquote><p>分布式系统通过把任务分配给到不同的调度节点来解决<code>单点</code>和<code>任务堆积</code>的问题。</p></blockquote><p>常见的分布式解决方案：</p><ul><li><code>Quartz</code>：基于数据库实现作业的高可用，存在代码入侵。</li><li><code>Elastic Job</code>：采用zookeeper实现分布式协调，实现任务高可用以及分片。</li></ul><h5 id="并行调度"><a href="#并行调度" class="headerlink" title="并行调度"></a>并行调度</h5><blockquote><p><code>并行调度</code>：将任务分配到多个实例节点，使得多个应用实例能并行执行任务，以提升调度系统的执行效率。</p></blockquote><p>从单实例到多实例，<code>任务的分配</code>是<code>并行调度</code>的关键问题，常见的分配方式包括：</p><p><code>哈希分配</code>：计算任务的哈希值，分配到固定的实例节点，需要处理集群扩容和缩容的问题。</p><p><code>负载优先分配</code>：需要动态调整各个实例节点的负载压力，难点在于机器负载的定义与计算。</p><p><code>平均分配</code>：任务轮询分配到各个集群实例节点。</p><p><code>抢占式分配</code>：实现相对简单，不需要集群的管理节点来实现，只需要控制好并发锁的问题。</p><h5 id="高可用性"><a href="#高可用性" class="headerlink" title="高可用性"></a>高可用性</h5><blockquote><p><code>高可用性</code>：当执行任务的应用实例崩溃后，其他应用实例可以继续执行该任务。</p><p>也就是说，如何保证分布式中节点异常情况下，所有任务的正常执行。</p></blockquote><p><code>异常节点的任务迁移</code>是关<code>高可用</code>的键问题。</p><p>迁移必然带来任务的<code>动态分配</code>问题（与扩容类似），具体方法与使用的<code>任务分配</code>方式相关。</p><ul><li><code>哈希分配</code>：采用<code>一致性哈希算法</code>来解决节点异常导致的大量的任务迁移问题；</li><li><code>负载优先分配</code>：把节点异常的任务迁移到负载最低的节点来处理；</li><li><code>平均分配</code>：把节点异常的任务平均分配到集群其他节点上。</li><li><code>抢占式分配</code>：把节点异常的任务丢回任务池中等待其他节点来抢占。</li></ul><p>其中，负载优先分配方式下需要实时监控每个实例节点的负载能力，并需要实现动态调整实例的负载，实现任务的高效执行。</p><blockquote><p>集群实例节点的状态如何监控？</p></blockquote><p>利用<code>Zookeeper</code>和<code>Etcd</code>来实现应用实例状态的监控，当发生异常情况时及时迁移异常节点的待处理任务。</p><p>一般情况下，集群中会有一台实例节点充当管理者，利用<code>Zookeeper</code>和<code>Etcd</code>的分布式协调能力来选择集群的管理者，并监控整个集群的状态。</p><blockquote><p><code>Zookeeper</code>和<code>Etcd</code>分别实现了<code>zab</code>和<code>raft</code>一致性算法，可以辅助其他系统实现集群的状态管理。</p></blockquote><hr><p>下图代表了一致性hash来实现集群任务的分配及异常节点的任务迁移。</p><p><img src="/images/distributed_job_dispatch_3.png" alt="一致性哈希下的任务分配和异常迁移"></p><hr><h5 id="弹性扩容"><a href="#弹性扩容" class="headerlink" title="弹性扩容"></a>弹性扩容</h5><blockquote><p><code>动态扩容</code>：当集群无法满足大量任务的并发执行时，需要动态增加集群实例数量，同时保证历史任务的正常触发。</p></blockquote><p>上面有提到过，<code>一致性哈希</code>来实现任务的哈希分配扩容情况下造成的节点任务迁移问题。</p><p>此外，在扩容过程中也需要考虑扩容的任务迁移对任务的准时执行是否存在的影响，如果存在影响的话，是否可以考虑把可能会受到影响的任务留在当前实例节点。</p><h5 id="失败处理"><a href="#失败处理" class="headerlink" title="失败处理"></a>失败处理</h5><blockquote><p>只要是程序就会出现异常，任务调度也不例外，异常处理也是重要的一部分。</p></blockquote><p>失败一般包括以下几种情况：</p><ul><li>集群实例节点down机</li><li>任务调用超时</li><li>任务无法调用到目标应用（网络 or 目标应用down机）</li></ul><p>任务调度系统需要设置合理的<code>任务重试机制</code>，包括<code>重试次数</code>、<code>超时时间</code>等。</p><p>此外，对于异常任务，需要配置对应的<code>报警策略</code>来通知相关业务人员及时处理异常问题。</p><h5 id="任务优先级"><a href="#任务优先级" class="headerlink" title="任务优先级"></a>任务优先级</h5><blockquote><p>集群的并行处理能力是有限的，在满足需求的条件下，允许配置任务的优先级。</p></blockquote><p>任务调度系统中，通过设置<code>不同的优先级的任务处理器</code>来实现任务的优先处理。</p><p><code>带有优先级的任务处理器</code>可以由预分配多个线程池来处理，优先级的高低决定了任务处理器线程池中并发执行线程的数量，高优先级的线程池配置更多的线程，低优先级的线程池配置更少的线程，从而实现高低优先级任务的隔离处理。</p><h5 id="任务分片"><a href="#任务分片" class="headerlink" title="任务分片"></a>任务分片</h5><blockquote><p><code>任务分片</code>：任务按照参数可以拆分成多个子任务，子任务下发到集群的不同实例节点并发执行。</p></blockquote><p>任务分片的关键问题：<code>任务的拆分</code>。</p><p>可以分片的任务一定是可以<code>逻辑拆分</code>的，拆分之后的子任务没有任何关联关系。</p><p>例如，为每一个用户统计他最近一天的消费信息，可以按照用户id的取模方式来实现任务的拆分：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. id % 5 = 任务拆分为5个子任务</span><br><span class="line">2. 5个子任务分配分配到集群的5个节点来并发执行</span><br></pre></td></tr></table></figure></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>任务调度的目的是准时触发任务，分布式的目的是解决单点问题，通过zookeeper和etcd等组件来实现集群的状态管理。</p><p>为了试下准时触发和优先级触发，实例节点需要配置对应的线程池来实现高低优先级任务的隔离。</p><h5 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h5><p><a href="https://zhuanlan.zhihu.com/p/26493355" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/26493355</a><br><a href="https://juejin.im/post/5c55ac0bf265da2da771a216" target="_blank" rel="noopener">https://juejin.im/post/5c55ac0bf265da2da771a216</a><br><a href="https://www.cnblogs.com/davidwang456/p/9057839.html" target="_blank" rel="noopener">https://www.cnblogs.com/davidwang456/p/9057839.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;任务调度解决定时触发的问题，分布式解决单点触发的问题。&lt;/p&gt;
    
    </summary>
    
      <category term="架构" scheme="http://simyy.cn/categories/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="中间件" scheme="http://simyy.cn/categories/%E6%9E%B6%E6%9E%84/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
      <category term="中间件" scheme="http://simyy.cn/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
      <category term="分布式" scheme="http://simyy.cn/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="架构" scheme="http://simyy.cn/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="任务调度" scheme="http://simyy.cn/tags/%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>Java 虚拟机</title>
    <link href="http://simyy.cn/2019/11/26/jvm/"/>
    <id>http://simyy.cn/2019/11/26/jvm/</id>
    <published>2019-11-26T11:36:26.000Z</published>
    <updated>2020-03-05T03:36:44.326Z</updated>
    
    <content type="html"><![CDATA[<p><code>Java虚拟机（Java Virtual Machine）</code>是一种能够运行<code>Java字节码</code>的虚拟机。</p><a id="more"></a><p>实际上只要编译文件符合JVM对加载编译文件格式要求，任何语言都可以由JVM编译运行，例如<code>JPython</code>、<code>Scala</code>、<code>JRupy</code>。</p><h3 id="总体结构"><a href="#总体结构" class="headerlink" title="总体结构"></a>总体结构</h3><p><code>Java虚拟机</code>主要被划分为四部分： </p><ul><li><code>类加载器（ClassLoader）</code></li><li><code>运行时数据区（Runtime Data Area）</code></li><li><code>执行引擎（Execution Engine）</code></li><li><code>本地库接口（Native Interface）</code></li></ul><p><img src="/images/JVM_1.png" alt=""></p><blockquote><p><code>Java</code>是如何<code>跨平台</code>运行的？</p><p><code>Java虚拟机</code>在这里充当了<code>桥梁</code>的作用，通过屏蔽了具体操作系统的API(不同平台JVM实现有所不同)，只要生成<code>Java字节码</code>就可以在多平台不加修改的运行。</p></blockquote><h4 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h4><p><code>类加载器（ClassLoader）</code>负责把class加载到JVM。</p><p><img src="/images/JVM_2.jpg" alt=""></p><p>Java文件再被JVM处理之前，需要编译成<code>Java字节码</code>格式的class文件，然后通过类加载器加载到JVM。</p><h4 id="执行引擎"><a href="#执行引擎" class="headerlink" title="执行引擎"></a>执行引擎</h4><p><code>Java虚拟机</code>通过模拟操作系统实现了一套虚拟架构，包括<code>处理器</code>、<code>堆栈</code>、<code>寄存器</code>等。</p><p><code>执行引擎（Execution Engine）</code>就是模拟操作系统执行命令的原理，以指令为单位读取<code>Java字节码</code>。</p><blockquote><p><code>Java字节码</code>指令都由<code>操作码</code>和<code>操作数</code>组成。</p></blockquote><p><code>Java字节码</code>是实现跨平台的关键，所以在不同平台并不能直接执行，这就需要<code>不同平台实现各自的执行引擎来</code>生成各自可执行机器语言。</p><hr><p>在<code>Java虚拟机</code>中，存在三种执行方式：</p><p><strong>解释器模式</strong>：读取字节码解释并且执行字节码指令，由于省去编译时间，应用启动快，但执行效率差，<code>Python</code>默认就是采用此方法。</p><p><strong>JIT编译模式</strong>：通过把字节码编译成机器码达到提供执行效率的方法，由于在程序运行前需要编译，导致程序启动慢，但是执行效率高。</p><blockquote><p><code>JIT（Just In Time）即时编译</code>：在程序运行中对<code>热点代码</code>进行即时编译成机器码，从而提高程序运行效率。<code>热点代码（HotSpotCode）</code>可划分为：<code>多次被调用的方法</code>和<code>多次被执行的循环体</code>。</p></blockquote><p><strong>混合模式</strong>：上面两种模式的混合，在适合的时候选择合适的模式，从而解决两种模式存在的问题。</p><p><img src="/images/JVM_3.jpg" alt=""></p><blockquote><p><code>Java虚拟机</code>到底采用那种模式呢？</p><p>实际上，不同的JVM采用了不同的方式，<code>HotSpotVM</code>才用了混合模式来执行引擎，而<code>JRockitVM</code>才用了<code>JIT编译模式</code>(并没有实现解析器)。<br>如果对解释和编译感兴趣的话，可以戳一下 <a href="https://www.zhihu.com/question/37389356" target="_blank" rel="noopener">为什么 JVM 不用 JIT 全程编译？</a></p></blockquote><h4 id="本地库接口"><a href="#本地库接口" class="headerlink" title="本地库接口"></a>本地库接口</h4><p><code>本地接口</code>的作用是融合不同的编程语言为<code>Java虚拟机</code>所用，其一般被称为JNI（Java Native Interface）。</p><blockquote><p><strong>wikipedia</strong>： <code>JNI</code>是一种编程框架，使得<code>Java虚拟机</code>中的Java程序可以<code>调用本地应用/或库</code>，也可以<code>被其他程序调用</code>。</p></blockquote><h4 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h4><p><code>运行时数据区</code>是<code>Java虚拟机</code>中最重要的组成部分，也常被称为<code>JVM内存</code>。</p><p><img src="/images/JVM_4.jpg" alt=""></p><p><code>JVM内存</code>可分为以下<code>五个部分</code>：</p><p><strong>方法区</strong>：<code>线程共享</code>，主要用于存储<code>加载的类信息</code>、<code>常量池</code>、<code>静态变量</code>、<code>JIT编译的代码</code>等。</p><hr><blockquote><p>实际上不同JVM实现上也有所不同，</p><ul><li><code>JDK1.7</code>中，已经把放在永久代的<code>字符串常量池</code>移到<code>堆</code>中。</li><li><code>JDK1.8</code>中，已经把放在永久代的<code>静态变量</code>移到<code>堆</code>中。</li><li><code>JDK1.8</code>撤销<code>永久代(Perm)</code>，引入<code>元空间(Metaspace)</code>（存放在本地内存，不在受JVM内存限制）。</li><li>其他VM都不存在永久代，例如，<code>JRockitVM</code>就没有<code>永久代</code>。</li></ul></blockquote><blockquote><p><code>JDK1.8</code>中JVM进程占用的内存会多出来1G？</p></blockquote><p>由于<code>JDK1.8</code>默认开启了<code>-XX:+UseCompressedClassPointers</code>，<code>CompressedClassSpace</code>默认值为<code>1G</code>，因此会发现JVM进程占用的内存会多出来1G。</p><hr><p><strong>堆</strong>：<code>线程共享</code>，用于存储对象，是<code>GC</code>的主要区域。</p><p>与<code>C/C++</code>不同之处就在于此，<code>Java虚拟机</code>为开发者省去了内存管理的麻烦，也降低了软件开发和维护的难度。</p><p>内存管理一般会涉及到<code>内存释放的时机</code>、<code>内存碎片</code>、<code>并发清理内存垃圾的性能</code>等问题。</p><p>具体GC算法可以戳 <a href="http://simyy.cn/2017/01/25/gc/">垃圾回收GC</a></p><hr><p><strong>虚拟机栈</strong>：<code>线程独占</code>，用于存储<code>局部变量表、操作栈、动态链接、方法返回地址</code>等信息。</p><blockquote><p><code>局部变量表</code>：是用于存放<code>方法参数</code>和方法内部定义的<code>局部变量</code>，在<code>编译期确定</code>最大容量。<br><code>操作栈</code>：执行引擎就是基于<code>操作栈</code>来工作的，在<code>编译期确定</code>最大容量。<br><code>动态链接</code>：运行期加载的<code>常量池</code>中关联当前方法的<code>符号引用</code>。</p></blockquote><hr><p><strong>本地方法栈</strong>：<code>线程独占</code>，用于执行<code>本地方法（Native Method）</code>。</p><hr><p><strong>程序计数器</strong>：<code>线程独占</code>，用于保存当前线程执行的内存地址，用于JVM程序多线程切换后恢复执行环境。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>Java虚拟机</code>不仅提供了<code>平台无关</code>运行环境，并且接管了<code>内存管理</code>机制，从而使得<code>Java</code>开发、维护变得简单和流行。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;Java虚拟机（Java Virtual Machine）&lt;/code&gt;是一种能够运行&lt;code&gt;Java字节码&lt;/code&gt;的虚拟机。&lt;/p&gt;
    
    </summary>
    
      <category term="编程语言" scheme="http://simyy.cn/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="编程语言" scheme="http://simyy.cn/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Java" scheme="http://simyy.cn/tags/Java/"/>
    
      <category term="JVM" scheme="http://simyy.cn/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>拓扑排序</title>
    <link href="http://simyy.cn/2019/11/10/topological-sort/"/>
    <id>http://simyy.cn/2019/11/10/topological-sort/</id>
    <published>2019-11-10T10:20:35.000Z</published>
    <updated>2019-12-17T02:24:46.038Z</updated>
    
    <content type="html"><![CDATA[<p>简单介绍下图及拓扑排序。</p><a id="more"></a><h3 id="图"><a href="#图" class="headerlink" title="图"></a>图</h3><p>图（Graph）是由<code>顶点的有穷非空集合</code>和顶点之间的<code>边的集合</code>组合。</p><blockquote><p>一般可以用<code>G(V,E)</code>来标识一个<code>图</code>，其中，<code>V</code>表示图G的<code>顶点集合</code>，<code>E</code>表示图G的<code>边集合</code>。</p></blockquote><p><strong>无向图</strong>：图中任意两个顶点之间的边都是<code>无向边</code>（顶点之间的边没有方向，则称该条边为无向边）。</p><p><img src="/images/topological_sort_01.png?200x" alt="无向图"></p><p><strong>连通图</strong>：所有顶点之间都是连通的无向图（顶点之间的连通允许跨多条边的路径）。</p><p><strong>有向图</strong>：图中任意两个顶点之间的边都是<code>有向边</code>（顶点之间的边有方向，则称该条边为有向边）。</p><p><img src="/images/topological_sort_02.png" alt="有向图"></p><p><strong>入度</strong>：有向图中以顶点为<code>终点</code>的边的个数。</p><p><strong>出度</strong>：有向图中以顶点为<code>起点</code>的边的个数。</p><h3 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><p><code>邻接矩阵（Adjaceny Matrix）</code>是图的存储方式，由<code>一维数组存储图的顶点集合</code>和<code>二维数据存储图的边集合</code>组成。</p><p>假设图G存在<code>n个顶点</code>，则邻接矩阵可以表示为一个<code>n * n</code>的矩阵matrix，<code>matix[i][j]</code>代表<code>顶点i</code>和<code>顶点j</code>之间的边。</p><p><img src="/images/topological_sort_03.png" alt="无向图邻接矩阵"></p><p><img src="/images/topological_sort_04.png" alt="有向图邻接矩阵"></p><h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><p>在图论中，由一个有向无环图的顶点组成的序列，当且仅当满足下列条件时，称为该图的一个拓扑排序（Topological Sort）</p><ul><li>每个顶点出现且只出现一次；</li><li>若A在序列中排在B的前面，则在图中不存在从B到A的路径。</li></ul><p>在拓扑排序中实现方式有两种：<code>Kahn算法</code>和<code>DFS深度遍历算法</code>，算法的时间复杂度均为<code>O(N+E)</code>。</p><blockquote><p>由于遍历存在随机性，所以拓扑排序的结果不一定唯一。</p></blockquote><h4 id="Kahn算法"><a href="#Kahn算法" class="headerlink" title="Kahn算法"></a>Kahn算法</h4><blockquote><p>以入度（或出度）为零的顶点作为遍历的开始，不断排除入度为零的顶点的所有边，不断重复此过程。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">L ← 包含已排序的元素的空列表</span><br><span class="line">S ← 没有入边的顶点（入度为零的顶点）的集合</span><br><span class="line">G ← 统计所有顶点的出边顶点集合（记录顶点的下级顶点）</span><br><span class="line"></span><br><span class="line">while S 非空时：</span><br><span class="line">    从S取出顶点n</span><br><span class="line">    将点n从S移走</span><br><span class="line">    将n加到L尾</span><br><span class="line">    从G中获取顶点N的所有出边顶点集合T</span><br><span class="line">    for 顶点t in 遍历顶点集合T：</span><br><span class="line">        顶点t的入度减一</span><br><span class="line">        if 顶点t的入度为零：</span><br><span class="line">            把顶点t加入S集合</span><br><span class="line">            顶点t的入度减一（此时入度=-1，不会再处理）</span><br><span class="line"></span><br><span class="line">return L</span><br></pre></td></tr></table></figure><p>Kahn算法可以分为<code>无前趋的的顶点优先拓扑排序</code>和<code>无后继的的顶点优先拓扑排序</code>，区别在于使用<code>入度为零</code>还是<code>出度为零</code>的边作为起点。</p><h4 id="DFS深度遍历算法"><a href="#DFS深度遍历算法" class="headerlink" title="DFS深度遍历算法"></a>DFS深度遍历算法</h4><blockquote><p>DFS同样使用以入度为零的顶点作为遍历的开始，通过记录节点的访问状态不断遍历前置顶点。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">L ← 包含已排序的元素的空列表</span><br><span class="line">G ← 统计所有顶点的入边顶点集合（记录顶点的前置条件）</span><br><span class="line">S ← 没有进入边的节点（入度为零的节点）的集合</span><br><span class="line">V ← 所有顶点的访问记录（初始化为False）</span><br><span class="line"></span><br><span class="line">for n in S:</span><br><span class="line">    dfs(n)</span><br><span class="line">    </span><br><span class="line">function dfs(n)</span><br><span class="line">    if 已经访问过 n in V:</span><br><span class="line">        return</span><br><span class="line">    记录n的访问状态 V[n] = True</span><br><span class="line">    从G中找到顶点所有的出边集合T</span><br><span class="line">    for t in 出边集合T：</span><br><span class="line">        dfs(t)</span><br><span class="line">    将n加到L尾</span><br><span class="line">   </span><br><span class="line">return L</span><br></pre></td></tr></table></figure><p>在算法中，集合V是用来记录节点的访问记录，从而实现环的判断（如果已经访问的节点再次访问则一定存在环）。</p><h4 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h4><blockquote><p>在碰到该类问题，一般需要注意几点：</p><ul><li>是否存在环（循环依赖）；</li><li>顶点的入度和出度，不存在环的情况下，至少存在一个入度为0和一个出度为0的顶点；</li><li>遍历的起点一定是入度或出度为零的顶点；</li><li>入度和出度计算出的排序不同；</li><li>对于kahn算法，如果同时出现多个入度或出度为零的顶点则拓扑排序结果不唯一。</li></ul></blockquote><p> 在某校的选课系统中，存在这样的规则：</p><ul><li>每门课可能有若干门先修课，如果要修读某一门课，则必须要先修读此课程所要求的先修课后才能修读 （图的有向边）。</li><li>假设一个学生同时只能修读一门课程，那么，被选课系统允许的他修完他需要所有课程的顺序是一个拓扑序。</li></ul><p><a href="https://leetcode.com/problems/course-schedule/" target="_blank" rel="noopener">course-schedule</a><br><a href="https://leetcode.com/problems/course-schedule-ii/" target="_blank" rel="noopener">course-schedule-ii</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单介绍下图及拓扑排序。&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://simyy.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://simyy.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://simyy.cn/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java 堆外内存</title>
    <link href="http://simyy.cn/2019/10/19/java-direct-memory/"/>
    <id>http://simyy.cn/2019/10/19/java-direct-memory/</id>
    <published>2019-10-19T13:26:37.000Z</published>
    <updated>2019-12-17T02:30:43.536Z</updated>
    
    <content type="html"><![CDATA[<p><code>堆外内存</code>是相对于堆内内存的一个概念。</p><a id="more"></a><h3 id="堆内内存"><a href="#堆内内存" class="headerlink" title="堆内内存"></a>堆内内存</h3><p><code>Java虚拟机</code>中运行时数据区中<code>堆</code>的内存，用于存储<code>Java实例对象</code>。</p><p><code>堆内内存</code>是受<code>Java虚拟机</code>的管控的，<code>内存的分配和释放</code>都是基于<code>Java虚拟机</code>的内存管理机制。</p><p>常用的垃圾回收方式：<code>分代回收</code>。</p><p>常用的垃圾回收算法：<code>CMS</code>、<code>G1</code>.</p><h3 id="堆外内存"><a href="#堆外内存" class="headerlink" title="堆外内存"></a>堆外内存</h3><p><code>堆外内存</code>就是把内存对象分配在<code>Java虚拟机的堆以外的内存</code>，直接使用系统内存，不受虚拟机内存管理的控制。</p><p><strong>优势</strong>：</p><ul><li><code>提高垃圾回收速度</code>：垃圾回收不会处理堆外内存；</li><li><code>加快了复制的速度</code>，与直接内存的复制相比，堆内数据同样需要复制到直接内存（堆外内存 -&gt; 堆外内存）。</li></ul><p><strong>缺点</strong></p><ul><li><code>堆外内存难以控制</code>：由于堆外内存不受虚拟机控制，内存的管理是开发者决定的，如果出现内存泄露不好排查；</li><li><code>对象存储效率低（序列化问题）</code>：对外内存要求必须以字节数组方式存储，因此对象必须在存储过程中进行序列化/反序列化操作，效率较低。</li></ul><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ul><li>生命周期较长的对象，例如，应用预加载的常驻内存的数据；</li><li>直接的文件拷贝或IO操作，例如，NIO框架中使用方式；</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;堆外内存&lt;/code&gt;是相对于堆内内存的一个概念。&lt;/p&gt;
    
    </summary>
    
      <category term="编程语言" scheme="http://simyy.cn/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="编程语言" scheme="http://simyy.cn/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Java" scheme="http://simyy.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>计算机内存架构 &amp; JMM</title>
    <link href="http://simyy.cn/2019/09/02/memory-and-jmm/"/>
    <id>http://simyy.cn/2019/09/02/memory-and-jmm/</id>
    <published>2019-09-02T14:26:24.000Z</published>
    <updated>2019-12-23T06:07:36.432Z</updated>
    
    <content type="html"><![CDATA[<p>总结下计算机内存架构的基本原理以及JMM的不同之处。</p><a id="more"></a><h4 id="内存架构"><a href="#内存架构" class="headerlink" title="内存架构"></a>内存架构</h4><p><img src="/images/memory_and_jmm_1.jpg" alt="内存架构"></p><p>现代内存架构如上图所示。</p><blockquote><p><code>高速缓存</code>存在的意义？</p><p>计算机的<code>存储设备</code>与<code>处理器</code>的运算速度之间有着几个数量级的差距。</p></blockquote><p>由于处理器和内存之间的性能差距，当代所有计算机系统都加入了一层<code>高速缓存</code>来间接缓冲数据（可以理解为业务中使用的本地缓存、分布式缓存等）。</p><p><strong>访问速度比较</strong>：<code>寄存器</code> &gt; <code>高速缓存</code> &gt; <code>主内存</code>，有些计算机架构中存在多级缓存（例如，Linux多级缓存）。</p><h5 id="多级缓存"><a href="#多级缓存" class="headerlink" title="多级缓存"></a>多级缓存</h5><p>计算机提供了多级缓存来提高系统的读写效率。</p><p><img src="/images/memory_and_jmm_0.png" alt="多级缓存"></p><hr><p><strong>Core 内部：</strong></p><blockquote><p>CPU内部意味着L0、L1、L2都属于CPU的一部分，因此每一个CPU都拥有独占的LO、L1、L2。</p></blockquote><ul><li>L0：寄存器</li><li>L1：L1高速缓存（SRAM），划分为一级数据缓存（L1 D-Cache）和一级指令缓存（L1 I-Cache）</li><li>L2：L2高速缓存（SRAM）</li></ul><hr><p><strong>Core 共享：</strong></p><ul><li>L3：L3高速缓存（SRAM），会造成伪共享（False Sharing）</li><li>L4：主内存（DRAM）</li><li>L5：本地二级存储（本地磁盘）</li><li>L6：远程二级存储（分布式文件系统）</li></ul><hr><p><img src="/images/memory_and_jmm_0_1.png" alt="多级缓存"></p><p>从图中可以看到，每个处理器都有自己的高速缓存，而它们又共享同一主内存。</p><p>当多个处理器的运算任务都涉及同一块主内存区域时，将可能导致各自的缓存数据不一致。</p><h5 id="缓存一致性"><a href="#缓存一致性" class="headerlink" title="缓存一致性"></a>缓存一致性</h5><p><code>高速缓存</code>类似一种代理模式，在CPU和主内存质之间构建一条高速公路，但也会造成缓存一致性问题。</p><blockquote><p>当多个处理器同时共享同一块主内存时，将可能导致高速缓存的<code>一致性问题</code>。</p></blockquote><p>为了解决这个问题，提出了<code>缓存一致性协议</code>，常见的协议包括MSI、MESI等。</p><blockquote><p>缓存一致性的大体思想：当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。</p></blockquote><h6 id="伪共享"><a href="#伪共享" class="headerlink" title="伪共享"></a>伪共享</h6><p>CPU缓存系统是按<code>缓存行(Cache Line)</code>为单位存储的。</p><blockquote><p>缓存行(Cache Line)：CPU缓存的最小单位，大小一般为64bytes。</p></blockquote><p>CPU加载主内存到缓存是按照缓存行来加载的，也就是说，一个缓存行可以存储多个变量。</p><p>在多线程情况下，如果需要修改共享在同一个缓存行的变量，也会造成共享缓存行中其他变量的缓存失效，从而影响彼此的性能，这就是<code>伪共享（False Sharing）</code>。</p><blockquote><p><strong>解决方法：</strong>利用单个数据填充一个缓存行，空间换时间的方式，避免多个变量共享同一个缓存行。</p></blockquote><p>Java8中新增了一个注解<a href="mailto:`@sun.misc.Contended" target="_blank" rel="noopener">`@sun.misc.Contended</a>`用于解决伪共享的问题。</p><blockquote><p><a href="mailto:`@sun.misc.Contended" target="_blank" rel="noopener">`@sun.misc.Contended</a>`：通过在对象或字段前后追加padding，使数据长度达到128bytes（2被缓存行的大小），从而避免相邻扇区预取导致的伪共享冲突。</p></blockquote><p>具体参考：<a href="https://www.jianshu.com/p/c3c108c3dcfd" target="_blank" rel="noopener">Java8使用@sun.misc.Contended避免伪共享</a></p><h5 id="指令重排"><a href="#指令重排" class="headerlink" title="指令重排"></a>指令重排</h5><p>即使存在高速缓存也不能把CPU的性能充分利用，因此提出了<code>指令重排</code>。</p><blockquote><p><code>指令重排</code>：处理器会对输入的代码进行乱序优化，在保证结果不变的情况下，优化指令排序，从而实现CPU的充分利用。</p></blockquote><h4 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h4><p><code>JMM</code>的全程是<code>Java内存模型(Java Memory Model)</code>。</p><p><img src="/images/memory_and_jmm_2.jpg" alt="映射关系"></p><p><code>JMM</code>与硬件内存架构是不同的，区别在于：<strong>硬件内存架构未区分线程栈和堆</strong>。</p><p><code>JMM</code>中<code>工作内存（Working Memory）</code>是一个抽象概念，涵盖了CPU寄存器、高速缓存等。</p><p><img src="/images/memory_and_jmm_3.jpg" alt="Java内存模型"></p><h5 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h5><blockquote><p><code>可见性</code>：基于工作内存，在多线程的情况下，任意线程修改了共享变量的值，其他线程能够同步感知到变量的变化。</p></blockquote><p>Java提供了<code>volatile</code>来解决内存可见性问题。</p><p>当操作发生在<code>volatile</code>变量时，有如下规则：</p><ul><li><strong>写</strong>：<code>JMM</code>会把该线程对应的工作内存中的共享变量值刷新到主内存;</li><li><strong>读</strong>：<code>JMM</code>会把该线程对应的工作内存置为无效并从主内存中读取共享变量。</li></ul><blockquote><p>读写<code>volatile</code>变量会导致变量从主内存读写，这远比从CPU缓存读写更加耗时。</p></blockquote><h5 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h5><blockquote><p><code>内存屏障</code>：不仅可以保证屏障前后的指令顺序，也可以保证内存数据的可见性。</p></blockquote><p>为了保证内存可见性，Java编译器在生成指令序列的适当位置会插入<code>内存屏障指令</code>来禁止特定类型的处理器重排序。</p><p><code>volatile</code>也提供了禁止指令重排序的功能。</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://zhuanlan.zhihu.com/p/29881777" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/29881777</a><br><a href="https://blog.csdn.net/muxiqingyang/article/details/6615199" target="_blank" rel="noopener">https://blog.csdn.net/muxiqingyang/article/details/6615199</a><br><a href="https://www.yuque.com/crow/xriqpk/hm5s0s?language=en-us" target="_blank" rel="noopener">https://www.yuque.com/crow/xriqpk/hm5s0s?language=en-us</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总结下计算机内存架构的基本原理以及JMM的不同之处。&lt;/p&gt;
    
    </summary>
    
      <category term="计算机原理" scheme="http://simyy.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="计算机原理" scheme="http://simyy.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/"/>
    
      <category term="Java" scheme="http://simyy.cn/tags/Java/"/>
    
      <category term="Linux" scheme="http://simyy.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>线程模型及上下文切换</title>
    <link href="http://simyy.cn/2019/08/21/java-thread-1/"/>
    <id>http://simyy.cn/2019/08/21/java-thread-1/</id>
    <published>2019-08-21T09:20:33.000Z</published>
    <updated>2019-12-17T02:30:45.369Z</updated>
    
    <content type="html"><![CDATA[<p>记录下Java上下文切换的思考。</p><a id="more"></a><h3 id="线程实现"><a href="#线程实现" class="headerlink" title="线程实现"></a>线程实现</h3><p>线程的实现可分为三种方式<code>用户空间实现</code>、<code>内核空间实现</code>和<code>混合实现</code>。</p><p><code>用户空间实现</code>（N:1）：操作系统仅感知进程，而感知不到线程，线程是在用户空间实现（线程创建、销毁及调度）。</p><p><img src="/images/java_thread_1.jpg" alt="N:1"></p><blockquote><p><code>用户空间实现</code>其实类似于目前在<code>Python</code>、<code>Golang</code>中的<code>协程</code>的实现。</p><p><code>优点</code>：线程的调度只是在用户态，<code>减少了操作系统从内核态到用户态的切换开销</code>；<br><code>缺点</code>：操作系统不敢知线程，需要设计线程的调度算法和线程对CPU资源的抢占使用，难度较大。</p></blockquote><p><code>内核空间实现</code>（1:1）：操作系统感知进程和线程，线程是在内核空间实现（线程创建、销毁及调度）。</p><p><img src="/images/java_thread_2.jpg" alt="1:1"></p><blockquote><p><code>Linux</code>已经基于<code>NPTL</code>实现了更符合POSIX标准的线程。</p><p>在<code>Linux</code>中，线程被认为<code>轻量级进程(LWP)</code>，它是建立在内核之上并由内核支持的用户线程（内核线程的高度抽象），每一个轻量级进程都与一个特定的内核线程关联。内核线程只能由内核管理并像普通进程一样被调度。</p></blockquote><p><code>混合实现</code>（M:N）：通过使用<code>用户空间实现</code>、<code>内核空间实现</code>两种实现方式，即可以把线程管理交给内核，又可以利用内核态内切换开销小的特点。</p><p><img src="/images/java_thread_3.jpg" alt="M:N"></p><p><code>特点：</code></p><ul><li>轻量级进程作为用户态和内核态的桥梁;</li><li>尽量在用户态解决问题，避免内核态的切换；</li><li>轻量级进程负责用户态到内核态的切换。</li></ul><blockquote><p>Java中到底才用了哪种实现和具体虚拟机的实现有关（一般采用1:1的内核实现）。</p></blockquote><h3 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h3><p><code>Linux</code>是一个<code>多任务</code>操作系统，它支持远大于CPU数量的任务同时运行，通过将CPU轮流分配给它们，让用户感官上任务在同时运行。</p><p>多任务的分片执行必然会带来<code>CPU依赖环境的切换</code>，也就是<code>上下文切换</code>，其中包括<code>CPU寄存器</code>和<code>程序计数器</code>。</p><p><img src="/images/java_thread_4.png" alt="上下文切换"></p><blockquote><p><code>CPU寄存器</code>：CPU内置的容量小、但速度极快的内存；<br><code>程序计数器</code>：存储CPU正在执行的指令位置、或者即将执行的下一条指令位置；</p></blockquote><p><code>上下文切换</code>可以分为<code>线程上下文切换</code>、<code>进程上下文切换</code>、<code>中断上下文切换</code>。</p><p><code>线程</code>是调度的基本单位，<code>进程</code>则是资源拥有的基本单位。</p><p>内核调度的目标实际上对应的是<code>线程</code>，进程提供<code>虚拟内存</code>和<code>全局变量</code>。</p><p><strong>上下文切换的内容：</strong></p><ul><li><code>线程上下文切换</code>：<code>虚拟栈</code>、<code>寄存器</code>；</li><li><code>进程上下文切换</code>：<code>虚拟内存</code>、<code>全局变量</code>以及<code>虚拟栈</code>、<code>寄存器</code>。</li></ul><blockquote><p>一次系统调用实际上触发了<strong>两次</strong>上下文切换（用户态-&gt;内核态-&gt;用户态）。</p></blockquote><h3 id="Java线程模型"><a href="#Java线程模型" class="headerlink" title="Java线程模型"></a>Java线程模型</h3><p>如果按照<code>1:1模型</code>，Java中的线程就是<code>内核线程</code>，通过内核来调度线程的切换。</p><p>线程私有部有<code>程序计数器</code>和<code>虚拟机栈</code>，也是线程上下文切换时需要保存和加载的数据，其中，</p><ul><li><code>程序计数器</code>：字节码行号指示器；</li><li><code>虚拟机栈</code>：存放局部变量。</li></ul><blockquote><p><code>Java虚拟机</code>是一个独立的进程，在Java中其实不使用多进程编程，这里和其他语言不太一样。</p></blockquote><p><strong>那为什么Java中不使用多进程编程？</strong></p><p>资源的隔离性，一个虚拟机实例对应着一个进程，同一个虚拟机仅负责对应进程的内存管理，如果有一个进程发生异常，并不影响其它的子进程。</p><p>在<code>Python</code>中，存在GIL的原因导致多进程编程的存在。</p><p>一般来说么，多进程往往应用在隔离性很强的场景下，例如sandbox。</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://blog.csdn.net/CringKong/article/details/79994511#12__16" target="_blank" rel="noopener">https://blog.csdn.net/CringKong/article/details/79994511#12__16</a><br><a href="https://segmentfault.com/a/1190000000663472" target="_blank" rel="noopener">https://segmentfault.com/a/1190000000663472</a><br><a href="https://www.jianshu.com/p/2b27a5f30ce9" target="_blank" rel="noopener">https://www.jianshu.com/p/2b27a5f30ce9</a><br><a href="https://www.zhihu.com/question/23096638" target="_blank" rel="noopener">https://www.zhihu.com/question/23096638</a><br><a href="http://wanggaoliang.club/2018/11/30/cpu%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2/" target="_blank" rel="noopener">http://wanggaoliang.club/2018/11/30/cpu%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录下Java上下文切换的思考。&lt;/p&gt;
    
    </summary>
    
      <category term="计算机原理" scheme="http://simyy.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="计算机原理" scheme="http://simyy.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/"/>
    
      <category term="Java" scheme="http://simyy.cn/tags/Java/"/>
    
      <category term="多线程" scheme="http://simyy.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>微服务浅谈</title>
    <link href="http://simyy.cn/2019/06/20/microservice/"/>
    <id>http://simyy.cn/2019/06/20/microservice/</id>
    <published>2019-06-20T12:57:21.000Z</published>
    <updated>2019-11-29T05:50:34.696Z</updated>
    
    <content type="html"><![CDATA[<p>大部分公司都会经历单体应用、SOA、微服务的各个架构演变的过程。</p><a id="more"></a><h3 id="单体应用"><a href="#单体应用" class="headerlink" title="单体应用"></a>单体应用</h3><p><strong>单体应用</strong> 是一个耦合了大量内部不可见的服务的独立系统，由于内部多个功能的耦合导致无法模块之间无法简单的拆分（牵一发而动全身）。</p><h5 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h5><blockquote><p><strong>优点：</strong></p><ul><li><code>易于开发/调试</code>，全部功能集中在一个项目</li><li><code>易于测试</code>，功能耦合在一起，没有分布式带来的诸多问题</li><li><code>易于部署</code>，只有一个应用</li></ul></blockquote><blockquote><p><strong>缺点：</strong></p><ul><li><code>不易于开发</code>，功能集中、内部依赖关系复杂导致系统难以开发和优化</li><li><code>不易于持续开发迭代</code>，整体开发、构建、部署都会影响整个迭代过程中的效率</li><li><code>技术受限</code>，整个应用使用相同的技术栈开发不同的功能，无法根据具体的场景做出其他选择</li><li><code>性能瓶颈</code>，部分功能出现瓶颈无法有针对性的优化，只能通过增加整个节点来临时解决问题（浪费资源）</li></ul></blockquote><p><img src="/images/microservice-1.png" alt="">@h=400</p><h5 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h5><p>个人博客、中小型论坛、小型门户咨询网站、个人电商系统都可以采用单体应用的方式来构建。</p><h3 id="SOA"><a href="#SOA" class="headerlink" title="SOA"></a>SOA</h3><p><strong>SOA</strong> 是一种分布式运算的软件设计方法<a href="https://zh.wikipedia.org/zh-hans/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84" target="_blank" rel="noopener">(来自维基百科)</a>，它将应用程序的不同功能单元（称为服务）通过这些服务之间定义的接口联系起来。</p><blockquote><p><code>SOA 是一种架构模式，是一种面向服务的思维方式</code>。</p></blockquote><ul><li>服务单独部署、易于系统优化</li><li>服务瓶颈单独维护和解决、易于伸缩</li><li>多应用部署运维要求较高</li><li>引入分布式问题：系统容错、网络延迟、分布式事务</li><li>接口调整引入的问题（依赖方需要感知接口的调整）</li></ul><h5 id="ESB架构"><a href="#ESB架构" class="headerlink" title="ESB架构"></a>ESB架构</h5><p><code>企业服务总线ESB(enterprise service bus)</code>是类似于通信模型中的通信总线的概念，所有服务应用将通过总线交互，而总线扮演着应用间的信息调度的角色，从而可以实现相互隔离的异构分布式服务系统。</p><p><img src="/images/microservice-2.png" alt="">@h=400</p><blockquote><p><strong>问题</strong></p><ul><li>ESB负责兼容和调度各个服务的异构接口（复杂均衡、流量控制等），内部实现很复杂</li><li>所有服务共用ESB的通道，直接影响了服务的通信速度</li></ul></blockquote><h5 id="ESB的替代品？"><a href="#ESB的替代品？" class="headerlink" title="ESB的替代品？"></a>ESB的替代品？</h5><p>在Java生态中，大家常用<code>grpc</code>、<code>thrift</code>、<code>dubbo</code>和<code>spring cloud</code>。</p><blockquote><p>这就是<code>第一代的微服务</code>的具体实现，特点在于：<code>注重服务发现、轻量链路通信。</code></p></blockquote><ul><li><code>服务注册、服务发现、负载均衡</code>均等功能都由具体的服务应用来控制</li><li><code>服务状态</code>信息由<code>分布式协调服务来维护</code>，例如<code>zookeeper</code>/<code>etcd</code></li><li>服务之间通信不再依赖一个单点总线，而是<code>点对点</code>的服务之间进行交互</li></ul><h5 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h5><p>中大型互联网公司都在使用SOA或者微服务架构，这种架构满足互联网的快速迭代、运维自由伸缩、资源独立运维的需求。</p><p>不同团队负责不同的业务，同一业务划分不同的功能模块独立部署，从而实现快速开发、快速构建、快速部署，快速上线的要求，而且也降低了不同团队之间的耦合，大家只需要根据API接口来沟通即可，不需要关心内部实现逻辑。</p><h3 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h3><p>从维基百科可以简单的了解一下什么是<a href="https://zh.wikipedia.org/wiki/%E5%BE%AE%E6%9C%8D%E5%8B%99" target="_blank" rel="noopener">微服务</a>。</p><blockquote><p><code>微服务</code> 是一种软件架构风格，它是以专注于<code>单一责任与功能的小型功能区块</code> (Small Building Blocks) 为基础，利用<code>模块化的方式组合</code>出复杂的大型应用程序，<code>各功能区块使用与语言无关</code> (Language-Independent/Language agnostic) 的 API 集相互通信。</p></blockquote><p><strong>单一职责与功能</strong>：功能独立，意味着应用可以独立部署，资源单独控制。<br><strong>模块化方式组合</strong>：功能可任意组合，组合方式通过任意通信方式（通信协议）来实现，不限于RPC/Restfull。<br><strong>功能区块与语言无关</strong>：应用独立部署、通信方式与语言无关，任意语言有自己的实现方式，所以应用可以采用更适合的语言来开发。</p><blockquote><p>其实这里看下来，微服务和SOA是不是一样的？</p><p>较早实践微服务的公司<code>Netflix</code>就曾经称他们构建的架构是<code>「细粒度的SOA」</code>。</p></blockquote><h4 id="SOA遇到kubernetes"><a href="#SOA遇到kubernetes" class="headerlink" title="SOA遇到kubernetes"></a>SOA遇到kubernetes</h4><p><code>细粒度的SOA</code>意味着服务拆分的更细，不仅是<code>服务拆分上的细</code>，也是<code>运维资源上的细</code>。</p><blockquote><p><code>运维资源上的细可以</code>通过<code>K8S</code>来实现，从而实现了<code>第二代微服务</code>。</p></blockquote><p><code>K8S或者说容器调度平台</code>的引入是比较<strong>革命性的</strong>。</p><p>容器使得我们的微服务对环境的依赖可以<code>打包整合进行随意分发</code>，从而实现<code>微服务节点任意调度</code>。</p><p>调度平台通过<code>服务的分类和抽象</code>，使得微服务本身的<code>部署和维护实现自动化</code>，以及实现更上一层楼的<code>自动伸缩</code>。</p><blockquote><p>自动化的难点就在于<code>服务的编排协调</code>。</p></blockquote><h6 id="虚拟化"><a href="#虚拟化" class="headerlink" title="虚拟化"></a>虚拟化</h6><p>虚拟化是指通过虚拟化技术将一台计算机虚拟为多台逻辑计算机。</p><p><code>VM（虚拟机）</code>是一个<code>物理硬件层抽象</code>，用于将一台服务器变成多台服务器，<code>每个VM都包含一整套操作系统</code>、 占用大量空间、启动慢。</p><p><code>Docker</code>是一个<code>应用层抽象</code>，用于将代码和依赖资源打包在一起。每个容器是<code>基于已有的公共基础设施中操作系统</code>的功能来运行的，<code>各自作为独立的进程在用户空间中运行</code>，占用空间极少，启动快。</p><blockquote><p><code>Docker</code>的轻量对于微服务来说是在适合不过了。</p></blockquote><h6 id="kubernetes"><a href="#kubernetes" class="headerlink" title="kubernetes"></a>kubernetes</h6><p><code>kubernetes（k8s）</code>是用于<code>自动部署</code>、<code>扩展和管理容器化（containerized）</code>应用程序的开源系统。</p><p><code>SOA</code>的思想出现后，系统拆分服务会变得越来越多，单靠原有的运维方式无法支撑管理，往往需要应用开发同事来帮忙查看到底那里出现了问题（配置发生了变更？目录权限有问题？）。</p><p>基于<code>kubernetes</code>，运维只负责<code>资源交付</code>，服务的启动注册、目录权限、配置都让服务的开发者来管理，从而降低了运维的压力，而运维更能把重点转移到基础运维工作中。</p><blockquote><p><code>kubernetes</code>解决了服务的编排协调及快速伸缩。</p></blockquote><p>虽然<code>kubernetes</code>为应用程序提供服务发现、负载均衡和外部路由的功能，但是大部分公司都是采用<code>dubbo/grpc</code>等框架来实现完整的服务发现。</p><h4 id="Service-Mesh"><a href="#Service-Mesh" class="headerlink" title="Service Mesh"></a>Service Mesh</h4><p><code>Service Mesh(服务网格)</code>是一个基础设施层，用于处理服务间通信。</p><p><img src="/images/microservice-3.png" alt="">@h=200</p><blockquote><p><code>Service Mesh</code>类似于在k8s的基础之上又封装了统一的服务发现功能。</p></blockquote><p><code>Service Mesh</code>会接管整个集群的网络，把所有请求在服务之间做转发。从而业务开发不再需要关注服务的注册和发现，只专注完成业务逻辑，服务之间的通讯环节就从应用层剥离出来。</p><p><code>Service Mesh（服务网格）</code>实际上是抽象出了一个基础设施层，独立于应用之外，所提供的功能就是实现请求的可靠路由，部署上体现为轻量级的网络代理，并对应用是透明的。</p><h5 id="服务治理"><a href="#服务治理" class="headerlink" title="服务治理"></a>服务治理</h5><blockquote><p><code>微服务</code>时代面临最大的挑战就是<code>服务治理</code>。</p></blockquote><p>在大型互联网公司都会有自研的一套服务治理框架，功能各不相同各有优势，但都有不足之处。</p><p>目前最火的<code>SpringCloud</code>提供了一系列的组件来实现微服务下的<code>服务治理</code>。</p><p><code>Service Mesh（服务网格）</code>利用<code>基础设施层</code>来解决<code>服务注册、服务路由、流量控制、服务降级、安全认证</code>等功能。</p><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><p>对于大规模部署微服务，内部服务异构程度高的场景，使用<code>Service Mesh（服务网格）</code>方案是一个不错的选择。</p><p><code>Service Mesh（服务网格）</code>实现了<code>业务逻辑和控制的解耦</code>。</p><p><code>网络中多了一跳</code>，增加了<code>性能的损耗和访问的延迟</code>。</p><p>每个服务都需要部署<code>Sidecar</code>, 这也会使本来就具有一定复杂度的分布式系统变得更加复杂。</p><p><img src="/images/microservice-4.png" alt="">@h=200</p><h5 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h5><p>第一代<code>Service Mesh</code>的代表为<code>Linkerd</code>和<code>Envoy</code>。</p><p>第二代<code>Service Mesh</code>主要改进集中在更加强大的控制面功能（<code>Sidecar</code>），典型代表有<code>Istio</code>和<code>Conduit</code>。</p><p>到目前为止，服务网格的概念已经被实现，也有投入生产的实例，但普及还是需要一定时间。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>从<code>单体应用、SOA、微服务、K8S、ServiceMesh</code>的发展中可以看到技术的层出不穷，技术分工越来越细。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://jinfei21.github.io/2018/11/15/%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E7%9C%8B%E5%A5%BD%E6%96%B0%E4%B8%80%E4%BB%A3%E5%BE%AE%E6%9C%8D%E5%8A%A1ServiceMesh/" target="_blank" rel="noopener">https://jinfei21.github.io/2018/11/15/%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E7%9C%8B%E5%A5%BD%E6%96%B0%E4%B8%80%E4%BB%A3%E5%BE%AE%E6%9C%8D%E5%8A%A1ServiceMesh/</a><br><a href="https://juejin.im/post/592f87feb123db0064e5ef7c#heading-1" target="_blank" rel="noopener">https://juejin.im/post/592f87feb123db0064e5ef7c#heading-1</a><br><a href="https://juejin.im/post/5ad4146ff265da238670592f" target="_blank" rel="noopener">https://juejin.im/post/5ad4146ff265da238670592f</a><br><a href="https://zhuanlan.zhihu.com/p/53260098" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/53260098</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大部分公司都会经历单体应用、SOA、微服务的各个架构演变的过程。&lt;/p&gt;
    
    </summary>
    
      <category term="架构" scheme="http://simyy.cn/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="架构" scheme="http://simyy.cn/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="微服务" scheme="http://simyy.cn/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>Java 锁与多线程协作</title>
    <link href="http://simyy.cn/2019/05/14/java-lock/"/>
    <id>http://simyy.cn/2019/05/14/java-lock/</id>
    <published>2019-05-14T11:14:15.000Z</published>
    <updated>2020-01-09T06:45:57.042Z</updated>
    
    <content type="html"><![CDATA[<p>一般谈到多线程都会谈到<code>锁</code>这个概念，通过限制并发控制来保证操作互斥的要求。</p><a id="more"></a><p><strong>锁</strong>：在执行多线程时用于强行限制资源访问的同步机制，即用于在并发控制中保证对互斥要求的满足（wikipedia）。</p><p><img src="/images/java_lock_1.png" alt=""></p><h3 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h3><p><code>Synchronized</code>是Java中提供的最基础的悲观锁。</p><blockquote><p><strong>悲观锁</strong>：它可以阻止一个事务以影响其他用户的方式来修改数据（wikipedia）。</p></blockquote><p><code>Synchronized</code>是通过<code>Monitor</code>来实现的，通过<code>javap</code>命令生成的字节码大体结构如下，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">method ...</span><br><span class="line">    ...</span><br><span class="line">    monitorenter // 加锁</span><br><span class="line">    ...</span><br><span class="line">    aload 0</span><br><span class="line">    moniterexit // 解锁</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>注意上面的<code>monitorenter</code>和<code>monitorexit</code>对应着加锁和解锁的操作。</p><blockquote><p><strong>Monitor</strong>：一种线程同步机制，每个Java对象都持有一个Monitor锁(再下面会仔细介绍)。<br><code>Key Point 1</code>: 每个线程都有一个<code>Monitor Record 列表</code>；<br><code>Key Point 2</code>: 每个被锁住的对象都会与当前线程的<code>Monitor Record 列表</code>关联;<br><code>Key Point 3</code>: <code>Monitor的Owner字段</code>存放持有锁的线程的唯一标识;</p></blockquote><blockquote><p><strong>对象头</strong>：每一个对象都包含了一个<code>Mark Word</code>字段，默认存储<code>对象的HashCode</code>，<code>分代年龄</code>和<code>锁标志位</code>信息。</p></blockquote><p>每当一个线程执行到<code>Synchronized</code>包裹的代码块时，都会先查询当前线程是否已经持有或可以持有当前对象的Monitor锁。</p><blockquote><p><strong>问题</strong>：线程切换耗时可能比用户代码执行的之间还要长，从而频繁线程切换会浪费大量的时间。</p></blockquote><p>在JDK 1.6开始，<code>HotSpot虚拟机</code>开发团队开始对Java中的锁进行优化，加入了<code>适应性自旋</code>、<code>锁消除</code>、<code>锁粗化</code>、<code>轻量级锁</code>和<code>偏向锁</code>等针对<code>Synchronized</code>的优化。</p><blockquote><p>推荐看一下这篇文章对锁优化的总结：<a href="https://tech.meituan.com/2018/11/15/java-lock.html" target="_blank" rel="noopener">不可不说的Java“锁”事</a></p></blockquote><h4 id="synchronized-amp-volatile"><a href="#synchronized-amp-volatile" class="headerlink" title="synchronized &amp; volatile"></a>synchronized &amp; volatile</h4><p><strong>可见性&amp;原子性</strong>：<code>volatile</code>仅能保证变量修改的可见性，不能保证原子性；<code>synchronized</code>即可以保证变量的修改可见性，又能保证变量修改的原子性。</p><p><strong>线程阻塞</strong>：<code>volatile</code>不会造成线程阻塞，<code>synchronized</code>会造成线程阻塞。</p><p><strong>用法</strong>：<code>volatile</code>仅能用在变量，<code>synchronized</code>可以使用在变量、方法和类。</p><h4 id="锁的膨胀"><a href="#锁的膨胀" class="headerlink" title="锁的膨胀"></a>锁的膨胀</h4><blockquote><p><code>偏向锁</code>和<code>轻量级锁</code>是乐观锁，基于CAS来实现的，而<code>重量级锁</code>是悲观锁，基于底层的操作系统的<code>Mutex Lock（互斥锁）</code>来实现的。</p></blockquote><p><code>偏向锁</code>：仅一个线程进入临界区，当前对象会持有<code>偏向锁</code>。</p><p><code>轻量级锁</code>：当两个线程交替进入临界区，会发生锁的升级，更新到<code>轻量级锁</code>。</p><p><code>重量级锁</code>：当多个线程同时进入临界区或者线程自旋的次数太大的时候，会发生锁的升级，更新到<code>重量级锁</code>。</p><h3 id="Object-wait-notify"><a href="#Object-wait-notify" class="headerlink" title="Object wait/notify"></a>Object wait/notify</h3><p>Object提供了<code>wait</code>和<code>notify</code>来实现多线程协作，而其底层实现也是基于<code>Monitor</code>来实现的。</p><p>对于每一个对象都存在一个<code>ObjectMonitor结构</code>,</p><blockquote><p><strong>Owner</strong>：当前持有锁的线程ID；<br><strong>WaitSet</strong>：存放处于wait状态的线程队列；<br><strong>EntryList</strong>：存放处于等待锁block状态的线程队列。</p></blockquote><p><strong>步骤：</strong></p><ol><li>当多个线程同时访问一段同步代码时，会进入<code>EntryList</code>队列中尝试获取锁。</li><li>当一个线程获取到锁的时候会更新对象的<code>Owner</code>字段中的线程ID为当前线程ID。</li><li>当线程调用<code>wait</code>方法时，释放当前对象的Monitor，<code>Owner</code>字段恢复为null，当前线程加入到<code>WaitSet</code>中等待被其他线程唤醒。</li><li>当线程调用<code>notify</code>方法时，释放当前对象得Monitor，<code>Owner</code>字段恢复为null，并唤醒处于<code>WaitSet</code>中的线程。</li></ol><h3 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h3><p><code>AQS</code>是一个用来构建锁和同步器的框架，例如<code>ReentrantLock</code>、<code>ReentrantReadWriteLock</code>等皆是基于AQS来实现的。</p><blockquote><p><strong>核心思想</strong>：</p><ol><li>如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。</li><li>如果被请求的共享资源被占用，那么就需要一套<code>线程阻塞等待</code>以及<code>被唤醒时锁分配</code>的机制(CLH队列锁)。</li></ol></blockquote><p><img src="/images/java_lock_3.png" alt=""></p><p><code>CLH(Craig,Landin,and Hagersten)队列</code>是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。</p><p><code>AQS</code>是将每条请求共享资源的线程封装成一个<code>CLH锁队列的一个结点（Node）</code>来实现锁的分配。</p><p><code>AQS</code>定义两种资源共享方式：<code>独占</code>和<code>共享</code>。</p><p><code>独占</code>是只有一个线程能执行（如如ReentrantLock等），而<code>共享</code>是允许多个线程同时执行（如Semaphore等）。</p><blockquote><p><code>独占</code>模式下又可分为<code>公平锁</code>和<code>非公平锁</code>。</p><p><code>公平锁</code>：按照线程在队列中的排队顺序，先到者先拿到锁；<br><code>非公平锁</code>：当线程要获取锁时，无视队列顺序直接去抢锁，谁抢到就是谁的。</p></blockquote><h3 id="重入"><a href="#重入" class="headerlink" title="重入"></a>重入</h3><p><code>Synchronized</code>与<code>JUC lock</code>都是<code>可重入</code>的。</p><p><code>可重入</code>是同一线程可以重复获得当前锁，也是为了<code>避免死锁问题</code>。</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://www.jianshu.com/p/f4454164c017" target="_blank" rel="noopener">https://www.jianshu.com/p/f4454164c017</a><br><a href="https://blog.csdn.net/kobejayandy/article/details/39975339" target="_blank" rel="noopener">https://blog.csdn.net/kobejayandy/article/details/39975339</a><br><a href="https://tech.meituan.com/2018/11/15/java-lock.html" target="_blank" rel="noopener">https://tech.meituan.com/2018/11/15/java-lock.html</a><br><a href="https://www.hollischuang.com/archives/2030" target="_blank" rel="noopener">https://www.hollischuang.com/archives/2030</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一般谈到多线程都会谈到&lt;code&gt;锁&lt;/code&gt;这个概念，通过限制并发控制来保证操作互斥的要求。&lt;/p&gt;
    
    </summary>
    
      <category term="编程语言" scheme="http://simyy.cn/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="编程语言" scheme="http://simyy.cn/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Java" scheme="http://simyy.cn/tags/Java/"/>
    
      <category term="锁" scheme="http://simyy.cn/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>Java 类的加载和多版本控制</title>
    <link href="http://simyy.cn/2019/03/20/java-classloader/"/>
    <id>http://simyy.cn/2019/03/20/java-classloader/</id>
    <published>2019-03-20T10:20:51.000Z</published>
    <updated>2019-12-17T02:30:43.078Z</updated>
    
    <content type="html"><![CDATA[<p><code>类加载器（ClassLoader）</code>是通过一个类的<code>全限定名</code>来获取定义此类的二进制字节流。<br><a id="more"></a></p><p>在类加载的第一阶段<code>“加载”</code>过程中，需要通过一个类的<code>全限定名</code>来获取定义此类的二进制字节流，完成这个动作的代码块就是<code>类加载器</code>。</p><h3 id="类的唯一性"><a href="#类的唯一性" class="headerlink" title="类的唯一性"></a>类的唯一性</h3><p>类加载器虽然只用于实现类的加载动作，但是对于任意一个类，都需要由<code>加载它的类加载器</code>和<code>这个类本身</code>共同确立其在Java虚拟机中的<code>唯一性</code>。</p><blockquote><p>通俗的说，JVM中两个类是否“相等”，首先就必须是同一个类加载器加载的，否则，即使这两个类来源于同一个Class文件，被同一个虚拟机加载，只要类加载器不同，那么这两个类必定是不相等的。</p></blockquote><h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><p>从<code>Java虚拟机角度</code>来说，只存在两种不同的类加载器：</p><ul><li><strong>启动类加载器（Bootstrap ClassLoader）</strong>，这个类加载器使用C++语言实现（HotSpot虚拟机中），是虚拟机自身的一部分；</li><li><strong>其他的类加载器</strong>，这些类加载器都有Java语言实现，<code>独立于虚拟机外部</code>，并且全部继承自<code>java.lang.ClassLoader</code>。</li></ul><p>从<code>开发者的角度</code>，类加载器可以细分为：</p><ul><li><strong>启动（Bootstrap）类加载器</strong>：负责将Java_Home/lib下面的类库加载到内存中（比如rt.jar）。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作。</li><li><strong>标准扩展（Extension）类加载器</strong>：是由Sun的ExtClassLoader（sun.misc.Launcher$ExtClassLoader）实现的。它负责将Java_Home/lib/ext或者由系统变量java.ext.dir指定位置中的类库加载到内存中。开发者可以直接使用标准扩展类加载器。</li><li><strong>应用程序（Application）类加载器</strong>：是由Sun的AppClassLoader（sun.misc.Launcher$AppClassLoader）实现的。它负责将系统类路径（CLASSPATH）中指定的类库加载到内存中。开发者可以直接使用系统类加载器。由于这个类加载器是ClassLoader中的getSystemClassLoader()方法的返回值，因此一般称为<code>系统（System）加载器</code>。</li></ul><p><img src="/images/java_classloader_1.png" alt=""></p><h3 id="破坏双亲委派模型"><a href="#破坏双亲委派模型" class="headerlink" title="破坏双亲委派模型"></a>破坏双亲委派模型</h3><p><code>Tomcat</code>、<code>JDBC</code>、<code>JNDI</code>、<code>Thread.currentThread().setContextClassLoader()</code>等都违反了双亲委托。</p><h4 id="Tomcat类加载"><a href="#Tomcat类加载" class="headerlink" title="Tomcat类加载"></a>Tomcat类加载</h4><p><code>Tomcat</code>作为一个web容器，需要保证web容器之间的互不影响。</p><blockquote><p><code>容器之间隔离性：</code></p><ul><li>保证每个应用的类库都是独立的，保证相互隔离；</li><li>部署在不同web容器中相同的类库相同的版本可以共享；</li><li>基于安全考虑，应该让容器的类库和程序的类库隔离开来。</li></ul></blockquote><p><code>Tomcat</code>为了上面的隔离性问题，没有遵守双亲委派这个约定，每个<code>webappClassLoader</code>加载自己的目录下的<code>class文件</code>，<code>不会传递给父类加载器</code>。</p><p><img src="/images/java_classloader_2.png" alt=""></p><p><strong>Tomcat的类加载过程：</strong></p><ol><li>在本地缓存中查找是否已经加载过该类；</li><li>委托Appication类加载器尝试加载该类（<code>为了防止一些基础类会被web中的类覆盖</code>）；</li><li>委托WebApp应用的类加载器将自行加载(违反了双亲委托机制)，如果加载到则返回；</li><li>委托父类Common类加载器（违反了双亲委托机制）去加载。</li></ol><h4 id="SPI"><a href="#SPI" class="headerlink" title="SPI"></a>SPI</h4><blockquote><p><code>双亲委派存在的问题？SPI为什么出现？</code></p><p>在实际开发场景中，存在一些组件或扩展的实现由应用来具体实现的。可以理解为，系统类提供了通用的接口，具体实现需要应用来实现并且加载。</p></blockquote><p><code>SPI(Service Provider Interface)</code>是Java提供的一套用来被第三方实现或者扩展的API，它可以用来启用框架扩展和替换组件。</p><blockquote><p><strong>JDBC违背了双亲委派模型？</strong></p><p>在<code>JDBC4.0</code>之前，连接数据库的时候，通常会用<code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;)</code>加载数据库相关的驱动，然后再进行获取连接等的操作。<br>而<code>JDBC4.0</code>之后不需要<code>Class.forName</code>来加载驱动，直接获取连接即可，这里使用了<code>Java的SPI扩展机制</code>来实现。</p></blockquote><h4 id="OSGI"><a href="#OSGI" class="headerlink" title="OSGI"></a>OSGI</h4><p><code>OSGi（Open Service Gateway Initiative）</code>是Java动态化模块化系统的一系列规范。</p><p><img src="/images/java_classloader_3_osgi.png" alt=""></p><p><code>bundle</code>是开发、部署 OSGi 应用的基本单元，可以认识一个功能模块，最重要的是每个<code>bundle</code>都有单独的类加载器(这也是解决多版本冲突的重点)。</p><blockquote><p><strong>为什么需要动态化模块？</strong><br><code>版本化</code>：<code>bundle</code>可以版本化，多版本能够共存而不会影响系统功能；<br><code>热插拔</code>：<code>bundle</code>能够进行即时的更新，服务可以根据需要动态增加或者删除；</p></blockquote><p><code>OSGI</code>可以通过仅暴露服务，不同<code>bundle</code>可以依赖各自版本的jar包来解决<code>java多版本冲突</code>的问题。</p><blockquote><p><code>在Java9中提供了模块化特性</code>。</p><p>阿里有一款未开源的<code>Pandora中间件</code>，同样利用了模块化思想。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;类加载器（ClassLoader）&lt;/code&gt;是通过一个类的&lt;code&gt;全限定名&lt;/code&gt;来获取定义此类的二进制字节流。&lt;br&gt;
    
    </summary>
    
      <category term="编程语言" scheme="http://simyy.cn/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="编程语言" scheme="http://simyy.cn/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Java" scheme="http://simyy.cn/tags/Java/"/>
    
  </entry>
  
</feed>
