<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>simyy</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://simyy.cn/"/>
  <updated>2020-07-19T11:31:42.118Z</updated>
  <id>http://simyy.cn/</id>
  
  <author>
    <name>simyy</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Netty设计原理</title>
    <link href="http://simyy.cn/2020/07/19/netty/"/>
    <id>http://simyy.cn/2020/07/19/netty/</id>
    <published>2020-07-19T11:23:15.000Z</published>
    <updated>2020-07-19T11:31:42.118Z</updated>
    
    <content type="html"><![CDATA[<p>Netty设计原理。</p><a id="more"></a><h3 id="事件模型"><a href="#事件模型" class="headerlink" title="事件模型"></a>事件模型</h3><p><code>Netty</code>是一个基于<code>Java NIO</code>的高性能的通信框架。</p><p>Netty是<code>Reactor</code>的一种实现，通过分离<code>Boss线程</code>与<code>Worker线程</code>实现高性能的IO操作。</p><p><img src="/images/netty-1.png" alt=""></p><p><code>Selector</code>是事件驱动的核心，是基于<code>select/epoll/kqueue</code>等实现。</p><p><code>BossGroup</code>负责不断循环执行<code>select</code>来获取当前已经就绪的事件。</p><p><code>WorkerGroup</code>负责具体的IO操作(<code>OP_READ</code>/<code>OP_WRITE</code>等)。</p><blockquote><p>注意：BossGroup中线程的数量与绑定的端口有关，如果仅绑定一个端口，线程数为1即可。</p></blockquote><p><code>ServerBootstrapAcceptor</code>负责<code>ParentGroup</code>到<code>ChildGroup</code>之间<code>Channel</code>的传递.</p><h3 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h3><p><code>Channel</code>是IO操作的媒介，Netty中的Channel与JDK中NIO是一一映射的，</p><ul><li>NioSocketChannel <----> SocketChannel</----></li><li>NioServerSocketChannel <----> ServerSocketChannel</----></li></ul><p><code>Channel</code>是NIO通信的基础，<code>selector</code>是需要注册到<code>Channel</code>来能实现事件驱动的绑定。</p><h4 id="pipeline"><a href="#pipeline" class="headerlink" title="pipeline"></a>pipeline</h4><p>Netty实现了一套<code>pipeline</code>以支持IO流的自定义处理。</p><p><img src="/images/netty-2.png" alt=""></p><p>如图所示，<code>pipeline</code>保存了用于此Channel的所有Handler，</p><p>其中，可以被分为两种：</p><ul><li><code>ChannelInboundHandler</code>：处理读操作（对应着请求）的处理器</li><li><code>ChannelOutboundHandler</code>：处理写操作（对应着回复）的处理器</li></ul><p><code>channel.read()</code>是Channel的读操作，调用<code>findContextInbound</code>获取Inbound处理器，</p><p><code>channel.forceFlush()</code>是Channel的写入操作，调用<code>findContextOutbound</code>获取outbound处理器。</p><blockquote><p>在使用过程中，需要注意Inbound/outbound的顺序。</p></blockquote><p>那么，pipeline到底什么用，举个例子：</p><ul><li>利用<code>ByteToMessageDecoder（ChannelInboundHandler）</code>对读到的数据进行解码，</li><li>利用<code>MessageToByteEncoder（ChannelOutboundHandler）</code>来对回复的数据进行编码。</li></ul><h4 id="selector"><a href="#selector" class="headerlink" title="selector"></a>selector</h4><p><code>NioSocketChannel &amp; NioServerSocketChannel</code>使用<code>SelectorProvider</code>来获取当前平台默认的事件驱动模型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SelectorProvider DEFAULT_SELECTOR_PROVIDER = SelectorProvider.provider()</span><br></pre></td></tr></table></figure><p><code>SelectionKey</code>是<code>selector</code>获取到已就绪的事件，利用<code>processSelectedKey</code>实现读写事件的分发处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processSelectedKey</span><span class="params">(SelectionKey k, AbstractNioChannel ch)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 如果是写事件</span></span><br><span class="line">    <span class="keyword">if</span> ((readyOps &amp; SelectionKey.OP_WRITE) != <span class="number">0</span>) &#123;</span><br><span class="line">        ch.unsafe().forceFlush();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是读事件</span></span><br><span class="line">    <span class="keyword">if</span> ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != <span class="number">0</span> || readyOps == <span class="number">0</span>) &#123;</span><br><span class="line">        unsafe.read();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="EventLoop"><a href="#EventLoop" class="headerlink" title="EventLoop"></a>EventLoop</h3><p><code>EventLoop</code>是Netty中用于<code>绑定Channel</code>并<code>处理Channel IO</code>的实现。</p><p>NioEventLoop继承自<code>SingleThreadEventExecutor</code>，也就是说，每一个NioEventLoop就是<code>一个单线程</code>。</p><p><code>SingleThreadEventExecutor</code>是一个单线程的线程池，利用队列实现任务的<code>非阻塞的异步执行</code>。</p><ul><li>运行状态：<code>volatile int state</code>，会涉及到<code>UnSafe.CAS</code>操作</li><li>任务队列：<code>Queue&lt;Runnable&gt; taskQueue</code></li><li>延迟队列：<code>PriorityQueue&lt;ScheduledFutureTask&lt;?&gt;&gt; scheduledTaskQueue</code></li></ul><p>任务执行<code>execute(Runnable task)</code>会把当前任务添加到<code>taskQueue</code>，最后通过<code>runAllTasks</code>来触发任务的执行。</p><p><img src="/images/netty-3.png" alt=""></p><p>上图为<code>NioEventLoop.run</code>函数的大体内容，主要分为两部分，</p><ul><li><code>任务执行</code>：遍历触发<code>taskQueue</code>的缓存的未执行的任务</li><li><code>事件遍历</code>：通过<code>selector.select()</code>获取已就绪的事件</li></ul><h3 id="EventLoopGroup"><a href="#EventLoopGroup" class="headerlink" title="EventLoopGroup"></a>EventLoopGroup</h3><p><code>EventLoopGroup</code>是用来管理<code>EventLoop</code>的，类似于线程池的管理。</p><p>EventLoopGroup继承自<code>EventExecutorGroup</code>，它实现了整个事件池的管理。</p><p><code>MultithreadEventLoopGroup</code>是EventExecutorGroup的抽象实现，负责管理事件执行器的声明周期，</p><p>主要变量有：</p><ul><li>处理器的存储：<code>EventExecutor[] children</code></li><li>处理器的选择：<code>EventExecutorChooserFactory.EventExecutorChooser chooser</code></li></ul><p><code>EventExecutor</code>是基于<code>AbstractExecutorService</code>的实现，等价于<code>Reator模型中的Handler</code>。</p><p>Netty会根据<code>chooser</code>逻辑来选择一个事件执行器来处理Channel上的事件。</p><h3 id="ByteBuf"><a href="#ByteBuf" class="headerlink" title="ByteBuf"></a>ByteBuf</h3><p><code>ByteBuf</code>是Netty提供的一套高性能Byte缓冲区。</p><p><img src="/images/netty-4.png" alt=""></p><p><strong>读写索引</strong></p><p><code>ByteBuf</code>使用<code>readIndex</code>与<code>writeIndex</code>来记录读写情况。</p><p><code>ByteBuffer</code>使用<code>position、limit、capacity</code>来记录读写情况，通过flip切换读写。</p><p><strong>动态扩展</strong></p><p><code>ByteBuf</code>当内存大小不足以写入数据会触发空间扩容（<code>ensureWritable0</code>）。</p><p><code>ByteBuffer</code>的容量固定，超出容量大小会报错。</p><p><strong>零拷贝</strong></p><p><code>CompositeByteBuf</code>是多个ByteBuf的逻辑拼接，使用<code>Component数组</code>来存储ByteBuf的引用，不会产生复制。</p><p>当Component数组大小不足时候，支持自动扩容数组大小，此时的扩容也仅仅涉及到引用的复制。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Netty设计原理。&lt;/p&gt;
    
    </summary>
    
      <category term="架构" scheme="http://simyy.cn/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="中间件" scheme="http://simyy.cn/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
      <category term="编程语言" scheme="http://simyy.cn/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Java" scheme="http://simyy.cn/tags/Java/"/>
    
      <category term="网络模型" scheme="http://simyy.cn/tags/%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>Redlock - Distributed locks with Redis</title>
    <link href="http://simyy.cn/2020/07/04/redis-redlock/"/>
    <id>http://simyy.cn/2020/07/04/redis-redlock/</id>
    <published>2020-07-04T06:53:10.000Z</published>
    <updated>2020-07-07T11:10:44.597Z</updated>
    
    <content type="html"><![CDATA[<p>Redlock - 基于Redis的分布式锁。</p><a id="more"></a><blockquote><p>除了自己的思考以外，内容来源如下：</p><p><a href="https://redis.io/topics/distlock" target="_blank" rel="noopener">Distributed locks with Redis</a><br><a href="https://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html" target="_blank" rel="noopener">How to do distributed locking</a><br><a href="http://antirez.com/news/101" target="_blank" rel="noopener">Is Redlock safe?</a></p></blockquote><h3 id="SETNX-amp-SET-NX"><a href="#SETNX-amp-SET-NX" class="headerlink" title="SETNX &amp; SET NX"></a>SETNX &amp; SET NX</h3><p>通常，大家利用Redis实现分布式锁最简单的方案是<code>命令SETNX</code>。</p><p><code>SETNX</code>全称为<code>SET IF NOT EXIST</code>，也就是说如果不存在则设置该值。</p><p><strong>那为什么<code>SETNX</code>可以实现分布式锁的功能呢？</strong></p><p>由于Redis的单线程（无锁化的命令执行）特性，可以保证不会出现多个客户端同时执行SETNX的情况。</p><h4 id="Implements"><a href="#Implements" class="headerlink" title="Implements"></a>Implements</h4><p>在Redlock之前，Redis分布式锁大体包含以下四种实现方式，</p><p>不过仔细考量下这种实现方式就会发现一些问题，具体如下：</p><p><code>① 加锁成功后没有释放锁，导致死锁</code>，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加锁</span></span><br><span class="line">SETNX LOCK_KEY <span class="number">1</span></span><br><span class="line"><span class="comment">// 业务逻辑</span></span><br><span class="line"><span class="keyword">do</span> somethind ...</span><br><span class="line"><span class="comment">// 释放锁</span></span><br><span class="line">EXPIRE LOCK_KEY <span class="number">0</span></span><br></pre></td></tr></table></figure><p>在上面的<code>业务逻辑</code>中如果出现业务异常导致无法触发<code>释放锁</code>的操作，从而导致<code>LOCK_KEY</code>无法释放，</p><p>此时，其他业务线程就会一致等待<code>LOCK_KEY</code>的释放，从而造成<code>死锁</code>。</p><p><code>② 为解决死锁的问题，加锁后立即设置超时时间，降低死锁可能性</code>，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加锁</span></span><br><span class="line">SETNX LOCK_KEY <span class="number">1</span></span><br><span class="line"><span class="comment">// 设置过期时间</span></span><br><span class="line">EXPIRE LOCK_KEY <span class="number">5</span>s</span><br><span class="line"><span class="comment">// 业务逻辑</span></span><br><span class="line"><span class="keyword">do</span> somethind ...</span><br><span class="line"><span class="comment">// 释放锁</span></span><br><span class="line">EXPIRE LOCK_KEY <span class="number">0</span></span><br></pre></td></tr></table></figure><p>与①中不同之处在于<code>新增了[设置默认时间]</code>，避免了业务逻辑异常导致无法执行<code>释放锁</code>的操作，</p><p>但仍然存在<code>执行加锁成功但设置默认时间失败</code>的情况，可理解为<code>加锁与过期设置操作的非原子性</code>，也会造成<code>死锁</code>。</p><p><code>③ 利用时间特性来生成特定的LOCK_KEY来解决非原子性操作</code>，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成特定的时间锁</span></span><br><span class="line">LOCK_KEY = FUNC(LOCK_KEY, TIME)</span><br><span class="line"><span class="comment">// 加锁</span></span><br><span class="line">SETNX LOCK_KEY <span class="number">1</span></span><br><span class="line"><span class="comment">// 业务逻辑</span></span><br><span class="line"><span class="keyword">do</span> somethind ...</span><br><span class="line"><span class="comment">// 释放锁</span></span><br><span class="line">EXPIRE LOCK_KEY <span class="number">0</span></span><br></pre></td></tr></table></figure><p>利用时间来生成特定的时间锁来解决死锁问题，但是会生成大量无效KEY。</p><p>由于与时间相关，<code>业务逻辑的处理时间可能大于锁的有效期</code>，就会造成<code>业务逻辑还没有处理完的同时其他线程就可以竞争『同一把锁』</code>。</p><blockquote><p>『同一把锁』是指原始锁是同样的，也就是未执行<code>FUNC(LOCK_KEY, TIME)</code>之前的<code>LOCK_KEY</code>。</p><p>当执行完<code>LOCK_KEY = FUNC(LOCK_KEY, TIME)</code>后，LOCK_KEY将与TIME相关，也就是说<code>不同时段使用不同的逻辑锁</code>。</p></blockquote><p><code>④ 使用SET EX NX来解决SETNX与EXPIRE非原子性的问题</code>，</p><blockquote><p><a href="https://redis.io/commands/set" target="_blank" rel="noopener">&gt;= 2.6.12: Added the EX, PX, NX and XX options. </a></p></blockquote><p>此方法需要Redis版本大于等于<code>v2.6.12</code>，如下，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加锁并设置过期时间</span></span><br><span class="line">SET LOCK_KEY <span class="number">1</span> EX <span class="number">5</span>s NX</span><br><span class="line"><span class="comment">// 业务逻辑</span></span><br><span class="line"><span class="keyword">do</span> somethind ...</span><br><span class="line"><span class="comment">// 释放锁</span></span><br><span class="line">EXPIRE LOCK_KEY <span class="number">0</span></span><br></pre></td></tr></table></figure><p>通过该命令很好的解决了方法②中的不足，也不许引入③中的复杂逻辑，实现了<code>设置与过期的原子性操作</code>，</p><p>但其仍然没有解决<code>业务逻辑超长的执行时间导致的锁自动过期的问题</code>。</p><hr><p>上面讨论的实际上都是<code>如何解决互斥</code>，那么如何保证<code>分布式锁的容错性</code>并没有讨论。</p><p>假设线程<code>锁定的默认时间 &gt; Master节点宕机恢复时间</code>，考虑以下主备场景，</p><ul><li>A线程尝试加锁并加锁成功；</li><li>B线程尝试加锁并加锁失败；</li><li>Master节点宕机；</li><li>尝试切换Slave为Master提供服务；</li><li>C线程尝试加锁并加锁成功；</li></ul><p>以上步骤中，<code>Master节点宕机</code>是关键，再主备场景下主从存在延时，</p><p>假设<code>Master节点</code>宕机前未将A线程的加锁数据同步至<code>Slave节点</code>，</p><p>那么，此时Slave切换为Master后中缺少A线程的加锁数据，从而C线程获取了锁造成了资源的竞争。</p><blockquote><p>最近由于所谓的政治舆论压力，作者将<code>master-slave</code>改为了<code>master-replica</code>。</p></blockquote><h3 id="Redlock"><a href="#Redlock" class="headerlink" title="Redlock"></a>Redlock</h3><p><code>Redlock</code>主要就是解决分布式场景下<code>互斥</code>、<code>死锁</code>以及<code>容错</code>这三个关键问题。</p><blockquote><p>Redlock核心思想：基于Quorum机制，采用大于一半的投票方式来实现分布式锁。</p></blockquote><p><strong>Redlock具体步骤如下：</strong></p><p>① 采用<code>N(奇数)台相互独立</code>的Redis实例<code>参与投票</code>；</p><p>② Client随机生成<code>random_val</code>，向实例发送<code>set(key, random_val, nx=True, px=TTL)</code>命令的方式获取<code>投票结果</code>；</p><blockquote><p>每次循环调用Redis实例与上面讲到的单实例情况下分布式锁的实现大体相同，其中，<code>TTL是业务方来控制的，不设置的话有可能导致死锁</code>。</p></blockquote><p>③ 由于①中说明存在多个实例，则Client端通过<code>顺序请求</code>的方式来获取多个实例的投票。</p><blockquote><p>为了避免某个实例问题导致的阻塞情况，增加一个<code>默认的超时时间以防止长时间的阻塞</code>。</p></blockquote><p>④ 完成③中的投票后，统计投票结果以及投票过程的耗时，<code>当通过半数(N/2+1)的(设置)成功投票以及超时校验后则认为成功加锁</code>；</p><blockquote><p>不仅仅需要过半的成功投票，还需要校验整个加锁过程的耗时是否超时，其中锁默认的有效期(defaultValidityTime)是业务相关的。</p><p>当④中成功获取锁后，锁的有效期需要减去投票过程的耗时：<code>validityTime = TTL - elapsedTime</code>。</p></blockquote><p>⑤ Client<code>加锁失败</code>的话需要<code>释放掉已经设置成功的实例</code>。</p><blockquote><p>加锁失败的原因有<code>加锁超时</code>、<code>投票未过半</code>两种情况，无论那种情况都需要释放掉已经设置的锁（这里会尝试释放所有实例的锁）。</p></blockquote><h4 id="Safety"><a href="#Safety" class="headerlink" title="Safety"></a>Safety</h4><p>原文<code>Safety arguments</code>中讨论了Redlock是如何保证加锁的安全性。</p><p><strong>锁定策略</strong></p><p>通过<code>半数投票</code>机制来实现锁定策略，具体实现如下，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># N为实例数量，m为投票数量</span></span><br><span class="line"><span class="keyword">if</span> m &gt; N/<span class="number">2</span> + <span class="number">1</span>:</span><br><span class="line">    successed</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    failed</span><br></pre></td></tr></table></figure><p><strong>锁定时间</strong></p><p>锁的实际有效期计算公式如下，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># TTL为锁的过期时间，T1为开始加锁时间，T2为结束加锁时间，CLOCK_DRIFT为时钟偏移</span></span><br><span class="line">MIN_VALIDITY = TTL - (T2 - T1) - CLOCK_DRIFT,</span><br></pre></td></tr></table></figure><blockquote><p>可以理解为：<code>在尝试加锁的开始已经属于锁定时间的一部分</code>，锁的具体锁定时间与加锁过程耗时有关。</p></blockquote><p>此外，如果任务优先执行完会立即释放锁，从而实际锁定时间可能会小于<code>MIN_VALIDITY</code>。</p><h4 id="Liveness"><a href="#Liveness" class="headerlink" title="Liveness"></a>Liveness</h4><p><strong>锁的释放</strong></p><p>锁的释放也包括两种情况：<code>主动释放</code>与<code>自动释放</code>。</p><p>自动释放是利用Redis自动过期实现的，而主动释放是基于Client主动触发来实现的，具体如下，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> processTime &lt; MIN_VALIDITY:</span><br><span class="line">    <span class="keyword">for</span> server <span class="keyword">in</span> servers:</span><br><span class="line">        <span class="keyword">if</span> server.get(LOCK_KEY) == current_val;</span><br><span class="line">            server.<span class="keyword">del</span> LOCK_KEY</span><br></pre></td></tr></table></figure><p>在Client删除实例的LOCK_KEY时会去判断VAL值是否是该节点之前设置过的。</p><h3 id="Unsafety"><a href="#Unsafety" class="headerlink" title="Unsafety"></a>Unsafety</h3><p><strong>STW</strong></p><p><code>Garbage Collector（垃圾回收器）</code>是用于帮助应用自动回收已过期的内存空间的一种辅助工具。</p><p>如何衡量一个垃圾回收器的性能的好坏，大多体现在如何保证更小<code>Stop The World</code>的。</p><p>先看下面这个场景，当STW时间大于持有锁的有效时间时，就会造成分布式锁的异常。</p><p><img src="/images/redis-lock-unsafe-lock.png" alt="STW unsafe lock"></p><p>如图所示，<code>Stop The World</code>导致了线程执行时延，</p><p>线程从暂停中恢复时已经超过了锁的有效期，从而导致锁失效，此时另外一个线程尝试并成功获取锁，造成资源竞争。</p><blockquote><p>原文提到：<code>STW恢复后再次验证锁的有效性</code>来避免锁定超时的情况。</p><p>但这里其实存在一个问题：<code>如果进程执行了一部分逻辑怎么办？</code></p><p>在MySQL中，基于undolog与redview的MVCC实现了事务的功能。</p><p>那么在分布式的场景下业务如何保证锁失效导致的资源竞争的问题，是支持业务回滚？还是支持垃圾数据的容错？</p><p>实际上，无论进程在做什么都应该有一个耗时的上限，而这个上限是由具体的业务场景决定的（甚至需要考虑STW的时间）。</p></blockquote><p><strong>Blocking</strong></p><p>除了垃圾回收造成的长时间STW，进程运行过程中会遇到资源抢占等一系列造成阻塞的问题。</p><p>例如，磁盘容量不足、内存容量不足、IO阻塞、CPU的异常抢占策略等等，都有可能造成进程长时间的Blocking。</p><h3 id="Safety-with-fencing-token"><a href="#Safety-with-fencing-token" class="headerlink" title="Safety with fencing token"></a>Safety with fencing token</h3><p><img src="/images/redis-lock-fencing-tokens.png" alt="fencing-tokens"></p><p>Martin提出<code>fencing token</code>来解决上面延时导致的过期问题。</p><blockquote><p><code>fencing token</code>可以理解为<code>zookeeper中自增的zxid</code>或<code>znode的版本号</code>。</p><p>zookeeper中，zxid是用于实现事务的全局有序，而znode的版本号是用来解决资源竞争的新老问题（也就是fancing token）。</p></blockquote><p><code>fencing token</code>是用于解决新老版本的问题，在分布式锁场景下用于解决锁异常情况下的有效性问题。</p><p><code>fencing token</code>一定是<code>全局唯一</code>且<code>全局有序</code>，</p><ul><li><code>全局唯一</code>是为了保证锁的唯一性，不允许存在两个进程获取到同一把锁；</li><li><code>全局有序</code>是为了保证锁的有效性，总会认为最后持有的锁有效，也就是所谓的ID最大的有效。</li></ul><hr><p>Antirez并不认为Redlock存在这个问题，由于Redlock实现了随机数的VAL机制保证了唯一性，已经满足了锁竞争的场景。</p><p>如果进程获取锁当前的VAL与本地设置的VAL不同，那么自然可以认为锁已经被抢占了。</p><h3 id="Safety-with-timing-assumptions"><a href="#Safety-with-timing-assumptions" class="headerlink" title="Safety with timing assumptions"></a>Safety with timing assumptions</h3><p>Martin提出Redlock锁的有效期与Redis实例的时钟强依赖，而Redis实例的时钟是不可靠的。</p><p>假设一种场景，假设共五个Redis实例1~5，两个客户端A与B参与投票：</p><ul><li>客户端A 在 1、2、3 三个节点抢占成功；</li><li>此时，节点3时钟前跳，导致客户端A的抢占失效（客户端A并无感知）；</li><li>客户端B 在 3、4、5 两个节点抢占成功；</li></ul><p>因此，当时钟发生异常的情况下，客户端A与客户端B均成功获取锁，导致分布式锁失效。</p><p><img src="/images/redis-lock-time-forward.png" alt="time forward"></p><p>此外，linux提供了两种获取系统时间：<code>CLOCK_REALTIME</code>与<code>CLOCK_MONOTONIC</code><a href="https://stackoverflow.com/questions/3523442/difference-between-clock-realtime-and-clock-monotonic" target="_blank" rel="noopener">参考</a>，</p><ul><li><code>CLOCK_REALTIME</code>：会发生向前或向后的时钟跳跃，包括认为修改与NTP的影响；</li><li><code>CLOCK_MONOTONIC</code>：只会收到NTP的影响，合理的运维可以尽量避免此问题。</li></ul><blockquote><p>Redis使用<code>CLOCK_REALTIME</code>，存在时钟跳跃的风险。</p></blockquote><h3 id="Is-Redlock-safe"><a href="#Is-Redlock-safe" class="headerlink" title="Is Redlock safe"></a>Is Redlock safe</h3><p>Redis作者antirez对Martin提出的不安全问题给出了自己的理由。</p><p>Redlock是一种基于客户端实现分布式锁的思路，不仅仅适用于redis。</p><p>Redlock的目标用于是哪些使用原本使用Redis作为分布式锁的用户，提高原有分布式锁的容错性。</p><p>类似于Zookeeper，只要满足半数投票就可以认为加锁成功，允许部分机器出现异常情况。</p><hr><p>Redlock无法保证绝对的安全性，这也是它可以实现高性能的关键。</p><p>常见的共识系统为了避免时钟问题，使用<code>fencing token</code>来的全局有序来保证绝对的安全性，而如何保证全局有序又将成为为系统性能的瓶颈。</p><h3 id="Thoughts"><a href="#Thoughts" class="headerlink" title="Thoughts"></a>Thoughts</h3><p>虽然很久之前就有打算对这块内容整理一下，不过一拖再拖。</p><p>微服务场景下通常会涉及到分布式锁的问题，常用的实现有：</p><ul><li>MySQL</li><li>Redis</li><li>Zookeeper</li><li>Etcd</li></ul><p>其中，基于数据库来实现可以解决了大部分的场景，ZK/ETCD提供了强一致性的保证，Redis提供了更好的性能。</p><p>如何选择还是要看业务场景，分布式锁对于微服务来说等同于JVM的STW、PYTHON中的GIL，无锁话设计才是性能提升的关键。</p><h3 id="Reading"><a href="#Reading" class="headerlink" title="Reading"></a>Reading</h3><p><a href="https://zhuanlan.zhihu.com/p/151436396" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/151436396</a><br><a href="https://dbaplus.cn/news-159-3080-1.html" target="_blank" rel="noopener">https://dbaplus.cn/news-159-3080-1.html</a><br><a href="https://zhuanlan.zhihu.com/p/76294773" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/76294773</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Redlock - 基于Redis的分布式锁。&lt;/p&gt;
    
    </summary>
    
      <category term="中间件" scheme="http://simyy.cn/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
      <category term="中间件" scheme="http://simyy.cn/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
      <category term="Redis" scheme="http://simyy.cn/tags/Redis/"/>
    
      <category term="分布式锁" scheme="http://simyy.cn/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>HTTPS</title>
    <link href="http://simyy.cn/2020/06/29/https/"/>
    <id>http://simyy.cn/2020/06/29/https/</id>
    <published>2020-06-29T04:34:45.000Z</published>
    <updated>2020-07-01T08:13:47.925Z</updated>
    
    <content type="html"><![CDATA[<p>记录HTTPS认证过程。</p><a id="more"></a><p><a href="https://zh.wikipedia.org/wiki/超文本传输安全协议" target="_blank" rel="noopener">HTTPS</a>是基于<code>SSL/TLS</code>来加密的HTTP安全协议。</p><p><img src="/images/https-1.png" alt=""></p><p>如图所示，HTTPS协议可分为两部分：<code>安全认证</code>与<code>加密传输</code>。</p><p><strong>安全认证</strong></p><blockquote><p>Client &amp; Server 利用CA证书验证、RSA非对称加密实现传输密钥的安全传递。</p></blockquote><p>1&gt; Client发起认证申请，向Server请求<code>CA证书</code>及<code>RSA公钥</code>；</p><p>2&gt; Server接收到认证申请，向Client端下发<code>CA证书</code>及<code>RSA公钥</code>；</p><p>3&gt; Client验证<code>CA证书</code>的有效性（签名校验、有效期校验等）；</p><p>4&gt; Client生成<code>AES密钥</code>，向Server发送<code>RSA公钥</code>加密过的<code>AES密钥</code>；</p><p>5&gt; Server接受到加密过的<code>AES密钥</code>，利用<code>RSA私钥</code>解密得到<code>AES密钥</code>。</p><p><strong>加密传输</strong></p><blockquote><p>Client &amp; Server 利用AES对称加密实现数据的加密与解密。</p></blockquote><p>1&gt; Client利用<code>AES密钥</code>加密Request请求；</p><p>2&gt; Server利用<code>AES密钥</code>解密接受到的请求，再次利用<code>AES密钥</code>加密Response返回；</p><p>3&gt; Client端利用<code>AES密钥</code>解密接受到的返回。</p><blockquote><p>那为什么需要使用两种加密方式呢？</p><p>由于RSA适用于不适用于大文件的加密，会导致整个加密过程很缓慢，相反，AES会好很多。</p><p><a href="https://www.quora.com/How-much-faster-is-AES-than-RSA" target="_blank" rel="noopener">How much faster is AES than RSA?</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录HTTPS认证过程。&lt;/p&gt;
    
    </summary>
    
      <category term="计算机原理" scheme="http://simyy.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="网络" scheme="http://simyy.cn/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="计算机原理" scheme="http://simyy.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>InnoDB MVCC</title>
    <link href="http://simyy.cn/2020/06/23/mysql-mvcc/"/>
    <id>http://simyy.cn/2020/06/23/mysql-mvcc/</id>
    <published>2020-06-22T16:25:12.000Z</published>
    <updated>2020-06-23T02:34:33.803Z</updated>
    
    <content type="html"><![CDATA[<p>梳理下MVCC的具体实现。</p><a id="more"></a><p>全文基于MySQLV8.0版本。</p><h3 id="HiddenRow"><a href="#HiddenRow" class="headerlink" title="HiddenRow"></a>HiddenRow</h3><p>InnoDB的每一行数据都隐藏了四个字段，具体如下：</p><ul><li><code>DB_TRX_ID</code>：记录更新该行最后一次的<code>事务ID</code>。</li></ul><blockquote><p>事务ID是不断递增的，最新的事务ID永远大于原有事务ID，便于校验事务是否已经过期。</p></blockquote><ul><li><p><code>DB_ROLL_PTR</code>：记录该行<code>回滚段（Undo Log）的指针</code>，用于查找该行的历史数据。</p></li><li><p><code>DB_ROW_ID</code>：在没有主键的情况下生成的<code>隐藏单调自增ID</code>。</p></li></ul><blockquote><p>被物理删除的DB_ROW_ID会被重用，。</p></blockquote><ul><li><code>DELELE_BIT</code>：用于标识该记录<code>是否被删除</code>。</li></ul><blockquote><p>DELELE_BIT状态位属于逻辑删除，MySQL利用后台运行<code>purge</code>线程来实现异步的物理删除。</p></blockquote><p><img src="/images/mysql-mvcc-1.png" alt=""></p><p>其中，<code>DB_TRX_ID</code>与<code>DB_ROLL_PTR</code>是实现MVCC的关键。</p><h3 id="UndoLog"><a href="#UndoLog" class="headerlink" title="UndoLog"></a>UndoLog</h3><blockquote><p><code>undolog</code>是事务回滚与可重复读的关键。</p></blockquote><p><img src="/images/mysql-mvcc-4.png" alt=""></p><p><code>undolog</code>属于逻辑日志，包含每行数据的所有版本的数据，用于支持事务与MVCC特性。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* undo结构 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trx_undo_t</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/* undo ID */</span></span><br><span class="line">    ulint id;</span><br><span class="line">    <span class="comment">/* 类型：insert or update */</span></span><br><span class="line">    ulint type;  </span><br><span class="line">    <span class="comment">/* 事务ID */</span></span><br><span class="line">    <span class="keyword">trx_id_t</span> trx_id;</span><br><span class="line">    <span class="comment">/* undo对应回滚段 */</span></span><br><span class="line">    <span class="keyword">trx_rseg_t</span> *rseg;</span><br><span class="line">    <span class="comment">/* undo链表 */</span></span><br><span class="line">    UT_LIST_NODE_T(<span class="keyword">trx_undo_t</span>) undo_list;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>undo_list</code>是一个链表结构，链表节点正是<code>trx_undo_t</code>，也就是说UndoLog在内存里是按照链表存储的。</p><p>此外，每一个<code>trx_undo_t</code>都绑定了对应的<code>事务ID</code>、<code>操作类型</code>以及对应的<code>回滚段</code>。</p><blockquote><p><code>redolog</code>属于物理日志，被称为重做日志，记录数据的修改，防止数据丢失，主要用于数据库重启恢复的时候被使用。</p><p>为了提高持久化效率，可用<code>Redo Log Buffer（重做日志缓冲）</code>来缓存变更，达到阈值大小或定期flush到<code>Redo Log File（重做日志文件）</code>。</p><p>为确保每次日志都能写入到事务日志文件，每次日志缓存的写入都会调用操作系统<code>fsync操作</code>（将OS Buffer中的日志刷到磁盘上的Log File中）。</p></blockquote><h3 id="trx-sys-t"><a href="#trx-sys-t" class="headerlink" title="trx_sys_t"></a>trx_sys_t</h3><p><code>trx_sys_t</code>可以被称为事务管理系统，包含<code>MVCC</code>、<code>事务</code>以及<code>回滚段</code>的管理。</p><p><img src="/images/mysql-mvcc-2.png" alt=""></p><p>利用<code>volatile</code>来实现<code>待分配事务max_trx_id的可见性</code>。</p><p>活跃的用户事务存储在<code>mysql_trx_list</code>事务链表中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* trx_t类型为节点的链表 */</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">UT_LIST_BASE_NODE_T</span><span class="params">(<span class="keyword">trx_t</span>)</span> trx_ut_list_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 事务管理系统 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trx_sys_t</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/* 多版本控制器 */</span></span><br><span class="line">    MVCC *mvcc;</span><br><span class="line">    <span class="comment">/* 下一个被分配的事务ID */</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">trx_id_t</span> max_trx_id;</span><br><span class="line">    <span class="comment">/* 最小的活跃事务ID */</span></span><br><span class="line">    <span class="built_in">std</span>::atomic&lt;<span class="keyword">trx_id_t</span>&gt; min_active_id;</span><br><span class="line">    <span class="comment">/* 最大的活跃事务ID */</span></span><br><span class="line">    <span class="keyword">trx_id_t</span> rw_max_trx_id;</span><br><span class="line">    <span class="comment">/* 事务链表, 包含用户事务、系统事务与恢复事务 */</span></span><br><span class="line">    <span class="keyword">trx_ut_list_t</span> rw_trx_list;</span><br><span class="line">    <span class="comment">/* 用户事务链表 */</span></span><br><span class="line">    <span class="keyword">trx_ut_list_t</span> mysql_trx_list;</span><br><span class="line">    <span class="comment">/* 回滚段列表，用于存储UndoLog */</span></span><br><span class="line">    Rsegs rsegs;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Rsegs</code>回滚段是由<code>trx_rseg_t</code>组成的数组，也就是说<code>事务管理系统是由多个回滚段组成的</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* trx_rseg_t类型为节点的数组 */</span></span><br><span class="line"><span class="keyword">using</span> Rsegs_Vector = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">trx_rseg_t</span> *, ut_allocator&lt;<span class="keyword">trx_rseg_t</span> *&gt;&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 回滚段 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rsegs</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="comment">/* 回滚段对应的事务ID */</span></span><br><span class="line">        <span class="keyword">trx_id_t</span> m_trx_no;</span><br><span class="line">        <span class="comment">/* 具体的回滚段数据 */</span></span><br><span class="line">        Rsegs_Vector m_rsegs;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="trx-rseg-t"><a href="#trx-rseg-t" class="headerlink" title="trx_rseg_t"></a>trx_rseg_t</h4><p><code>trx_rseg_t</code>是事务回滚段的基本结构，是组成回滚段的基本单元。</p><blockquote><p>UndoLog的存储是基于Rollback Segment实现的。</p></blockquote><p>从回滚段的结构中可以得到：<code>UndoLog</code>是被分为<code>update</code>与<code>insert</code>两种类型的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 事务回滚段 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trx_rseg_t</span> &#123;</span></span><br><span class="line">    <span class="comment">/* 回滚段id */</span></span><br><span class="line">    ulint id;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/* update undo日志缓存及链表 */</span></span><br><span class="line">    UT_LIST_BASE_NODE_T(<span class="keyword">trx_undo_t</span>) update_undo_list;</span><br><span class="line">    UT_LIST_BASE_NODE_T(<span class="keyword">trx_undo_t</span>) update_undo_cached;</span><br><span class="line">    <span class="comment">/* insert undo日志缓存及链表 */</span></span><br><span class="line">    UT_LIST_BASE_NODE_T(<span class="keyword">trx_undo_t</span>) insert_undo_list;</span><br><span class="line">    UT_LIST_BASE_NODE_T(<span class="keyword">trx_undo_t</span>) insert_undo_cached;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>trx_undo_t</code>的具体结构在上面已经介绍过了，是具体存储UndoLog的结构。</p><h3 id="ReadView"><a href="#ReadView" class="headerlink" title="ReadView"></a>ReadView</h3><p><code>ReadView</code>是用来判断undolog中多版本数据的可见性。</p><blockquote><p>每一个事务都包含一个<code>ReadView</code>。</p></blockquote><p><code>trx_t</code>是事务的结构体，每一个事务都包含一个<code>read_view</code>字段。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 事务 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trx_t</span> &#123;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">/* 事务ID */</span></span><br><span class="line">  <span class="keyword">trx_id_t</span> id;</span><br><span class="line">  <span class="comment">/* 解决可见性 */</span></span><br><span class="line">  ReadView *read_view;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ReadView事务可见范围 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReadView</span> &#123;</span></span><br><span class="line">    <span class="comment">/* 大于该ID的事务不可见（high water mark） */</span></span><br><span class="line">    <span class="keyword">trx_id_t</span> m_low_limit_id;</span><br><span class="line">    <span class="comment">/* 小于该ID的事务不可见（low water mark） */</span></span><br><span class="line">    <span class="keyword">trx_id_t</span> m_up_limit_id;</span><br><span class="line">    <span class="comment">/* 创建ReadView的事务ID */</span></span><br><span class="line">    <span class="keyword">trx_id_t</span> m_creator_trx_id;</span><br><span class="line">    <span class="comment">/* 创建ReadView时活跃事务 */</span></span><br><span class="line">    <span class="keyword">ids_t</span> m_ids;</span><br><span class="line">    <span class="comment">/* 用于记录可被purge清理的事务 */</span></span><br><span class="line">    <span class="keyword">trx_id_t</span> m_low_limit_no;</span><br><span class="line">    <span class="comment">/* 状态 */</span></span><br><span class="line">    <span class="keyword">bool</span> m_closed;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">UT_LIST_NODE_T</span><span class="params">(ReadView)</span> node_t</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 具体view链表 */</span></span><br><span class="line">    byte pad1[<span class="number">64</span> - <span class="keyword">sizeof</span>(<span class="keyword">node_t</span>)];</span><br><span class="line">    <span class="keyword">node_t</span> m_view_list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UT_LIST_NODE_T(TYPE)/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span>/</span><br><span class="line">       TYPE *   prev;       <span class="comment">/* pointer to the previous node, NULL if start of list */</span>/</span><br><span class="line">       TYPE *   next;       <span class="comment">/* pointer to next node, NULL if end of list */</span>/</span><br><span class="line">&#125;/</span><br></pre></td></tr></table></figure><p>InnoDB每次创建一个事务，都会创建一个包含当前活跃事务列表以及保证事务可见性的ReadView。</p><blockquote><p>事务的可见性的判断规则如下：</p><p>① <code>m_ids</code>中大于<code>m_low_limit_id</code>的事务不可见；<br>② <code>m_ids</code>中小于<code>m_up_limit_id</code>的事务不可见。</p></blockquote><p><img src="/images/mysql-mvcc-3.png" alt=""></p><hr><p>针对相同事务的不同隔离级别，<code>m_low_limit_id</code>与<code>m_up_limit_id</code>是不同的，</p><ul><li>对于RC来说，已提交事务的数据对当前事务来说是可见的；</li><li>对于RR来说，事务启动前所有未提交事务的数据对当前事务来说都是不可见的。</li></ul><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-multi-versioning.html" target="_blank" rel="noopener">innodb-multi-versioning</a><br>[trx0sys_8h_source]<a href="https://dev.mysql.com/doc/dev/mysql-server/8.0.12/trx0sys_8h_source.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/dev/mysql-server/8.0.12/trx0sys_8h_source.html</a><br><a href="https://dev.mysql.com/doc/dev/mysql-server/8.0.12/trx0trx_8h_source.html" target="_blank" rel="noopener">trx0trx_8h_source</a><br><a href="https://dev.mysql.com/doc/dev/mysql-server/8.0.12/read0types_8h_source.html" target="_blank" rel="noopener">read0types_8h_source</a><br><a href="http://www.leviathan.vip/2019/02/14/InnoDB%E7%9A%84%E4%BA%8B%E5%8A%A1%E5%88%86%E6%9E%90-Undo-Log/" target="_blank" rel="noopener">InnoDB事务分析-undo log</a><br><a href="http://www.leviathan.vip/2019/03/20/InnoDB%E7%9A%84%E4%BA%8B%E5%8A%A1%E5%88%86%E6%9E%90-MVCC/" target="_blank" rel="noopener">InnoDB的事务分析-MVCC</a><br><a href="https://colinback.github.io/szyblogs/database/2018/06/15/innodb-kernel-12/" target="_blank" rel="noopener">InnoDB 内核阅读笔记（十二）- 事务处理</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;梳理下MVCC的具体实现。&lt;/p&gt;
    
    </summary>
    
      <category term="中间件" scheme="http://simyy.cn/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
      <category term="MySQL" scheme="http://simyy.cn/tags/MySQL/"/>
    
      <category term="数据库" scheme="http://simyy.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="中间件" scheme="http://simyy.cn/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
      <category term="MVCC" scheme="http://simyy.cn/tags/MVCC/"/>
    
  </entry>
  
  <entry>
    <title>线程池的思考</title>
    <link href="http://simyy.cn/2020/06/21/threadpool/"/>
    <id>http://simyy.cn/2020/06/21/threadpool/</id>
    <published>2020-06-20T16:31:38.000Z</published>
    <updated>2020-06-23T02:55:39.070Z</updated>
    
    <content type="html"><![CDATA[<p>到底该如何设计与使用线程池？</p><a id="more"></a><h3 id="线程成本"><a href="#线程成本" class="headerlink" title="线程成本"></a>线程成本</h3><p>线程的创建与消耗释有成本的，大体可以分为：<code>CPU资源的消耗</code>与<code>内存资源的消耗</code>。</p><p><strong>CPU资源的消耗</strong></p><p>CPU资源的消耗是指大量的线程会对CPU进行竞争抢占，<code>大量的线程上下文切换会导致CPU的吞吐量降低</code>。</p><p>那么，该如何设置线程数呢？</p><blockquote><p>Using profiling, you can estimate the ratio of waiting time (WT) to service time (ST) for a typical request.<br>If we call this ratio WT/ST, for an N-processor system, you’ll want to have approximately N*(1+WT/ST) threads<br> to keep the processors fully utilized. <a href="https://www.ibm.com/developerworks/library/j-jtp0730/index.html" target="_blank" rel="noopener">来源</a></p></blockquote><p>假设等待时间为WT，实际运行时间为ST，CPU核心数为N，则最佳线程数Num为：</p><p><code>Num = N * (1 + WT / ST)</code></p><p>考虑两种CPU运算：<code>IO密集型</code>与<code>CPU密集型</code>。</p><hr><p>对于IO密集型来说，线程实际执行的时间很短，假设线程执行时间与线程等待时间近似，</p><p>此时，<code>WT/ST≈1</code>、<code>Num=N*(1+1)=2*N</code>。</p><hr><p>对于CPU密集型来说，线程实际的执行时间很长，会远大于线程等待时间，</p><p>此时，<code>WT/ST≈0</code>、<code>Num=N*(1+0)=N</code>，</p><p>但由于线程切换是基于等待线程的，因此需要增加一个等待线程来避免新线程创建导致的CPU空闲，</p><p>因此，Num = N + 1</p><blockquote><p>上面的计算都是基于CPU充分使用的前提下，那么如果保证CPU性能的冗余来估计线程数量呢？</p><p><code>Num = N * U * (1 + WT / ST)</code>，其中，U为CPU的目标使用率。</p></blockquote><p><strong>内存资源的消耗</strong></p><p>首先，线程的申请包括<code>线程资源的申请</code>、<code>线程资源的初始化</code>以及<code>线程资源的释放</code>。</p><blockquote><p>Java中线程独占的资源有<code>虚拟机栈</code>、<code>本地方法栈</code>与<code>计数器</code>。</p></blockquote><p>除了线程本身的内存占用，线程执行的任务也会占用大量的内存资源。</p><p>线程任务占用的内存与具体的业务逻辑有关，如果使用大量的并发线程必然导致内存资源的不足。</p><hr><p>例如，一个报表系统，通过接收MQ消息，定时触发报表的生成与上传，</p><p>其中，MQ消息接受后会把报表生成与上传的任务放到线程池中异步执行，</p><p>但由于近期数据量翻倍增长，导致报表数据翻倍，从而每个任务占用的内存也翻倍了，</p><p>在使用原有的线程池时，同样的线程数会占用翻倍的内存，从而产生内存不足的情况。</p><blockquote><p>线程执行由于需要资源的申请、初始化，一定会带有一定的时延。</p></blockquote><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><blockquote><p>为什么需要使用线程池？</p><ul><li>线程池降低资源（CPU与内存）消耗；</li><li>线程池提高任务响应速度；</li><li>线程池提供线程的可管理性；</li><li>线程池提供扩展能力（任务拒绝策略）。</li></ul></blockquote><h4 id="核心原理"><a href="#核心原理" class="headerlink" title="核心原理"></a>核心原理</h4><p>线程池的核心原理是<code>线程资源复用</code>与<code>线程资源的隔离与管理</code>。</p><h5 id="线程资源复用"><a href="#线程资源复用" class="headerlink" title="线程资源复用"></a>线程资源复用</h5><blockquote><p>线程池通过保证一定数量存活的线程来实现资源复用。</p></blockquote><p>线程复用的优点：</p><p>① 避免资源的频繁申请与释放，提高CPU与内存的使用效率；</p><p>② 避免资源申请的时延，提高任务响应能力。</p><h5 id="线程资源隔离与管理"><a href="#线程资源隔离与管理" class="headerlink" title="线程资源隔离与管理"></a>线程资源隔离与管理</h5><blockquote><p>线程池通过限制存活线程的数量以及任务队列来实现资源的隔离与管理。</p></blockquote><p><code>资源的隔离</code>是指不同的业务场景使用不同的线程池，从而实现线程资源的隔离。</p><p><code>资源的管理</code>是指线程池可以控制线程的数量、缓存任务的数量以及任务执行的顺序。</p><p>资源隔离与管理的优点：</p><p>① 避免无限的线程申请导致资源耗尽的情况；</p><p>② 协调任务线程与工作线程对CPU资源的竞争，避免大量任务线程对工作线程的资源（CPU与Memory）抢占。</p><h5 id="关键属性"><a href="#关键属性" class="headerlink" title="关键属性"></a>关键属性</h5><p><strong>核心线程数</strong>：默认存活的线程数量<code>CoreSize</code>；</p><p><strong>最大线程数</strong>：最大存活的线程数量<code>MaxPoolSize</code>；</p><p><strong>空闲线程存活时间</strong>：核心线程之外的空闲线程最长存活时间<code>KeepliveTime</code>；</p><p>以上三个参数是用来设置线程池中存活线程的数量，是影响线程池的吞吐量以及任务执行时延的关键。</p><p><strong>任务队列</strong>：队列类型与大小<code>WorkQueue(n)</code>；</p><p><strong>任务拒绝策略</strong>：当线程池无法及时响应任务时的执行策略（仅配置有界队列才会触发）。</p><p>以上两个参数是用来设置线程池可以缓存任务的数量以及过多任务的拒绝策略，是影响线程池的最大响应能力以及降级策略的关键。</p><h5 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h5><p>线程池的实现原理如图所示，</p><p><img src="/images/threadpool-1.png" alt=""></p><p><strong>线程调度策略</strong></p><p>线程池的调度是基于任务队列实现的。</p><blockquote><p>基于任务队列，线程池实现了任务与线程解耦。<br>任务队列负责任务的存储以及分配，工作线程负责任务的执行。 </p></blockquote><p>任务投递到线程池会优先加入任务队列，工作线程会从任务队列竞争获取待处理的任务。</p><p>具体调度规则如下：</p><ul><li>WorkerCount &lt; CoreSize : 创建新线程</li><li>WorkerCount &gt;= CoreSize : 任务添加到阻塞队列</li><li>WorkerCount &gt;= CoreSize &amp; 阻塞队列已满 : 创建新的线程</li><li>WorkerCount &gt;= CoreSize &amp; 阻塞队列已满 &amp; WorkerCount &gt;= MaxPoolSize  : 执行任务拒绝策略</li></ul><p><strong>任务分配策略</strong></p><p>任务分配模式是基于<code>任务队列</code>与<code>拒绝策略</code>组成。</p><p>任务队列可以分为三类：<code>有界队列</code>、<code>无界队列</code>和<code>同步移交队列</code>。</p><p>有界队列是指<code>队列大小有限</code>，缓存任务的数量存在上限，<code>当缓存数量达到上限时会触发拒绝策略</code>。</p><p>无界队列是指<code>队列大小无限</code>，如果线程池的吞吐量不足会导致缓存任务不断增多，由于<code>无界队列不会触发拒绝策略</code>，因此，可能导致<code>内存不足</code>。</p><p>同步队列是指任务直接交给工作线程，<code>不存在任务缓存的情况，提交任务会阻塞至空闲线程的认领</code>。</p><blockquote><p>无界队列：LinkedBlockingQueue、DelayedWorkQueue<br>有界队列：ArrayBlockingQueue、LinkedBlockingQueue、PriorityBlockingQueue<br>同步队列：SynchronousQueue</p></blockquote><h5 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h5><p><strong>newFixedThreadPool</strong></p><p>使用<code>LinkedBlockingQueue</code>作为无界队列（存在OOM的可能），线程数量固定，因此，此线程池的吞吐量有限。</p><p><strong>newCachedThreadPool</strong></p><p>使用<code>SynchronousQueue</code>作为同步队列，虽然不存在无限增大的任务队列，但是存在无限增加的线程，因此，此线程池的线程数量不可控。</p><p><strong>newScheduledThreadPool</strong></p><p>使用<code>DelayedWorkQueue</code>作为无界队列，线程数量无限，任务数量与线程数量均不可控，因此，此线程池也存在很大的安全隐患。</p><blockquote><p>阿里巴巴开发者手册规范：</p><p>线程池不允许使用Executors去创建，而是通过ThreadPoolExecutor的方式，这样的处理方式让写的同学更加明确线程池的运行规则，避免资源耗尽的风险。</p></blockquote><h4 id="衡量标准"><a href="#衡量标准" class="headerlink" title="衡量标准"></a>衡量标准</h4><p><strong>线程分类</strong></p><p>线程一般可以分为两种类型：<code>IO密集型</code>与<code>计算密集型</code>。</p><p>IO密集型不会占用大量的CPU资源，大部分线程处于IO阻塞的情况，因此可以使用更多的线程来处理任务。</p><p>计算密集型会占用大量的CPU资源，线程切换只会影响计算效率，因此不建议使用大量的并发线程。</p><p><strong>CPU与内存使用率</strong></p><p>大量的计算密集型线程会导致CPU的抢占，会降低CPU的使用效率，导致更大的平均时延。</p><p>大量的IO密集型线程由于IO阻塞会占用更多的内存资源，会降低内存的使用效率，可能造成OOM。</p><p><strong>吞吐量</strong></p><p>吞吐量是指线程池在单位时间内可以执行的任务数量。</p><p>工作线程是影响任务并发量的关键因素，也就是如何设计<code>CoreSize</code>与<code>MaxCoreSize</code>是影响线程池吞吐量的关键。</p><p>此外，业务任务往往会占用大量的内存资源，从而也需要考虑<code>是否存在核心线程数过多导致的资源浪费</code>。</p><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><h5 id="并行资源请求"><a href="#并行资源请求" class="headerlink" title="并行资源请求"></a>并行资源请求</h5><p>如果一个业务请求逻辑会涉及多个资源调用，可以使用线程池来并行请求多个资源。</p><p>虽然这种方式一定会降低资源请求的时延，但也会导致线程数量的倍数增长。</p><blockquote><p>队列的选择</p></blockquote><p>一般建议使用有界队列，由于可能触发任务丢弃策略，因此需要自定义实现降级策略。</p><blockquote><p>线程数该如何选择?</p></blockquote><p>吞吐量的计算公式为：<code>TPS = 完成任务数量 / 完成的时间</code></p><p>大量高并发任务请求会造成线程池吞吐量不足的情况，需要考虑降级策略。</p><p>增大线程数量可以提高任务并行能力，从而提供线程池的吞吐量，这种用法其实是很危险的，属于空间换时间的一种策略。</p><p>也存在资源浪费的问题，由于前面集中资源出现问题，导致后面的资源无需加载的情况。</p><blockquote><p>是否采取这样的方式与具体的业务场景有关，线程池是否可控，是否需要考虑降级策略等等。</p></blockquote><h5 id="并行批处理任务"><a href="#并行批处理任务" class="headerlink" title="并行批处理任务"></a>并行批处理任务</h5><p>数据合聚合与处理任务，由于数据量的不断增大，原有顺序执行的方式所需要的时间成倍增加，因此，需要拆分为多个子任务并行执行。</p><p>后台任务一般属于CPU密集型，线程数应该与CPU数量一致，过多线程只会增加CPU的抢占。</p><p>并行任务可能会占用多倍的内存，因此需要仔细计算内存占用情况是否会导致机器内存不足。</p><h4 id="降级策略"><a href="#降级策略" class="headerlink" title="降级策略"></a>降级策略</h4><p>线程池只是一种资源集中管理与优化的手段，它并不能解决资源不足与资源竞争的问题。</p><p>在线程池无法支持当前任务的情况下，需要提前设计适当的降级策略。</p><p>线程池的降级策略实际可以理解为<code>线程池的拒绝策略</code>。</p><blockquote><p>那么如何设计线程池的拒绝策略？</p><p>① 动态调整线程池配置，线程池的配置应该与具体的业务场景有关。</p><p>在高并发的场景下，动态调整线程池的配置对机器CPU、内存会造成不同情况的影响，严重情况下导致系统不可用。</p><p>② 异常报警，是异常监控的必要手段。</p><p>③ 任务持久化到DB、MQ，利用异步线程、延迟消息等方式再次触发。</p></blockquote><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html" target="_blank" rel="noopener">Java线程池实现原理及其在美团业务中的实践</a><br><a href="http://ifeve.com/how-to-calculate-threadpool-size/" target="_blank" rel="noopener">如何合理地估算线程池大小？</a><br><a href="http://xifxiong.online/java-threadpool/" target="_blank" rel="noopener">Java线程池-ThreadPoolExecutor原理分析</a><br><a href="https://www.ibm.com/developerworks/library/j-jtp0730/index.html" target="_blank" rel="noopener">Thread pools and work queues</a><br><a href="https://www.geeksforgeeks.org/thread-pools-java/" target="_blank" rel="noopener">Thread Pools in Java</a><br><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ThreadPoolExecutor.html" target="_blank" rel="noopener">Oracle ThreadPoolExecutor</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;到底该如何设计与使用线程池？&lt;/p&gt;
    
    </summary>
    
      <category term="编程语言" scheme="http://simyy.cn/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="计算机原理" scheme="http://simyy.cn/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="编程语言" scheme="http://simyy.cn/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Java" scheme="http://simyy.cn/tags/Java/"/>
    
      <category term="多线程" scheme="http://simyy.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="线程池" scheme="http://simyy.cn/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>Redis 高可用</title>
    <link href="http://simyy.cn/2020/06/07/redis-ha/"/>
    <id>http://simyy.cn/2020/06/07/redis-ha/</id>
    <published>2020-06-07T08:53:13.000Z</published>
    <updated>2020-06-07T08:54:54.997Z</updated>
    
    <content type="html"><![CDATA[<p>简单记录下Redis高可用方案。</p><a id="more"></a><h4 id="Replication"><a href="#Replication" class="headerlink" title="Replication"></a>Replication</h4><p><code>Replication</code>被称为<code>主从</code>架构，通过增加复制副本来提高数据的容错性与服务的可用性。</p><p><img src="/images/redis-ha-1.png" alt=""></p><p>数据的同步方式有<code>AOF与RDB</code>，其中<code>RDB</code>属于内存镜像的全量同步，<code>AOF</code>属于基于操作日志的增量同步。</p><p><strong>优点</strong></p><ul><li>主从架构解决单节点可用性问题；</li><li>读写分离，提高系统性能。</li></ul><p><strong>缺点</strong></p><ul><li>当主节点出现异常情况下，需要手动调整从节点为主节点；</li><li>写压力全部集中在主节点，造成了并发写入性能的瓶颈；</li><li>由于所有的数据复制都是基于单个主节点完成的，无法支持大量的横向扩展。</li></ul><h4 id="Sentinel"><a href="#Sentinel" class="headerlink" title="Sentinel"></a>Sentinel</h4><p><code>Sentinel</code>被称为<code>哨兵</code>，通过增加额外的监控系统来实现主从的动态切换，解决<code>Replication</code>的问题。</p><p><img src="/images/redis-ha-2.png" alt=""></p><p>由于Sentinel仍然存在这但点问题，因此一般会采用多个Sentinel来实现监控集群，实现高可用的双重保护。</p><p><strong>优点</strong></p><ul><li>解决了Replicaion无法自动切换的问题。</li></ul><p><strong>缺点</strong></p><ul><li>引入了额外的监控系统，系统复杂度增大；</li><li>单点写问题仍然没有解决，无法支撑大量的横向扩展。</li></ul><h4 id="Codis"><a href="#Codis" class="headerlink" title="Codis"></a>Codis</h4><p><code>Codis</code>是第三方实现的一套高可用方案，利用中间件实现Redis的集群功能。</p><p><img src="/images/redis-ha-3.png" alt=""></p><p><img src="/images/redis-ha-4.png" alt=""></p><p>其中，<code>codis proxy</code>被设计为无状态，可利用<code>HAProxy</code>或<code>Zookeeper</code>实现高可用。</p><p><strong>优点</strong></p><ul><li>解决了单节点写入的瓶颈；</li><li>支持大量的很想扩展。</li></ul><p><strong>缺点</strong></p><ul><li>引入了多个中间件，运维成本高；</li><li>每个中间件都存在可用性问题；</li><li>无法支持不同key的事务；</li><li>增加了一层代理影响系统性能。</li></ul><h4 id="Cluster"><a href="#Cluster" class="headerlink" title="Cluster"></a>Cluster</h4><p><code>Cluster</code>是<code>无中心化</code>架构，集群中的各个节点相互通信达成共识，并把客户端请求通过<code>slot</code>路由到目标数据节点。</p><p><img src="/images/redis-ha-5.png" alt=""></p><p><strong>优点</strong></p><ul><li>去中心化，高容错性；</li><li>支持大量横向扩容；</li><li>支持高可用；</li><li>不存在单点问题；</li><li>运维成本低。</li></ul><p><strong>缺点</strong></p><ul><li>client复杂，需要处理slot信息；</li><li>不同key会路由到不同的节点，无法支持事务。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单记录下Redis高可用方案。&lt;/p&gt;
    
    </summary>
    
      <category term="中间件" scheme="http://simyy.cn/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
      <category term="中间件" scheme="http://simyy.cn/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
      <category term="分布式" scheme="http://simyy.cn/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="缓存" scheme="http://simyy.cn/tags/%E7%BC%93%E5%AD%98/"/>
    
      <category term="Redis" scheme="http://simyy.cn/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis AE事件驱动</title>
    <link href="http://simyy.cn/2020/06/05/redis-ae/"/>
    <id>http://simyy.cn/2020/06/05/redis-ae/</id>
    <published>2020-06-05T10:58:39.000Z</published>
    <updated>2020-06-05T11:24:39.893Z</updated>
    
    <content type="html"><![CDATA[<p>AE事件驱动是Redis命令解析处理的基础。</p><a id="more"></a><h4 id="事件驱动"><a href="#事件驱动" class="headerlink" title="事件驱动"></a>事件驱动</h4><p><code>Redis</code>实现了一套事件驱动器<code>AE</code>，理由也很简单，逻辑简单可控。</p><blockquote><p><code>Memcached</code>的事件驱动时基于<code>libevent</code>的。</p></blockquote><h5 id="事件结构"><a href="#事件结构" class="headerlink" title="事件结构"></a>事件结构</h5><p><img src="/images/redis-ae-1.png" alt=""></p><p><code>aeEventLoop</code>是整个事件驱动的核心，事件的注册与触发都基于此。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 事件循环结构体 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">aeEventLoop</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">int</span> setsize;                  <span class="comment">// 支持连接的最大句柄数量</span></span><br><span class="line">    aeFileEvent *events;           <span class="comment">// 已注册的事件</span></span><br><span class="line">    aeFiredEvent *fired;           <span class="comment">// 已触发的事件</span></span><br><span class="line">    aeTimeEvent *timeEventHead;     <span class="comment">// 时间事件(定时触发)</span></span><br><span class="line">    aeBeforeSleepProc *beforesleep; <span class="comment">// 事件循环sleep之前的的执行函数 </span></span><br><span class="line">    aeBeforeSleepProc *aftersleep;  <span class="comment">// 事件循环sleep之后的的执行函数</span></span><br><span class="line">    <span class="keyword">void</span> *apidata;                <span class="comment">// select/poll/epoll的API交互数据</span></span><br><span class="line">    ...</span><br><span class="line">&#125; aeEventLoop;</span><br></pre></td></tr></table></figure><p><code>aeFileEvent</code>是具体的事件结构，其中，包含了<code>事件类型</code>与<code>对应的处理函数</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AE_NONE 0       <span class="comment">// 未注册</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AE_READABLE 1   <span class="comment">// 可读</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AE_WRITABLE 2   <span class="comment">// 可写</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AE_BARRIER 4    <span class="comment">// 强制先写后读</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 文件(IO)事件结构体 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">aeFileEvent</span> &#123;</span></span><br><span class="line">    <span class="comment">/* 读写标记 */</span></span><br><span class="line">    <span class="keyword">int</span> mask; <span class="comment">/* one of AE_(READABLE|WRITABLE|BARRIER) */</span></span><br><span class="line">    aeFileProc *rfileProc; <span class="comment">// 读事件对应的执行函数</span></span><br><span class="line">    aeFileProc *wfileProc; <span class="comment">// 写事件对应的执行函数</span></span><br><span class="line">    <span class="keyword">void</span> *clientData;     <span class="comment">// 事件相关的数据</span></span><br><span class="line">&#125; aeFileEvent;</span><br></pre></td></tr></table></figure><h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><p><img src="/images/redis-ae-2.png" alt=""></p><p><code>aeCreateEventLoop</code>是用于初始化事件循环结构体。</p><p><code>setsize</code>是Redis支持句柄的数量，在eventloop初始化时用于<code>初始化事件的存储大小</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 初始化事件循环 */</span></span><br><span class="line"><span class="function">aeEventLoop *<span class="title">aeCreateEventLoop</span><span class="params">(<span class="keyword">int</span> setsize)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 初始化事件循环</span></span><br><span class="line">    <span class="keyword">if</span> ((eventLoop = zmalloc(<span class="keyword">sizeof</span>(*eventLoop))) == <span class="literal">NULL</span>) <span class="keyword">goto</span> err;</span><br><span class="line">    <span class="comment">// 设置默认支持最大连接的数量（也就是可存储的事件数量）</span></span><br><span class="line">    eventLoop-&gt;events = zmalloc(<span class="keyword">sizeof</span>(aeFileEvent)*setsize);</span><br><span class="line">    <span class="comment">// 已触发的事件的最大数量与注册事件的最大数量相同</span></span><br><span class="line">    eventLoop-&gt;fired = zmalloc(<span class="keyword">sizeof</span>(aeFiredEvent)*setsize);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 创建事件循环触发器（select/epoll/...）</span></span><br><span class="line">    <span class="comment">// 具体参考：IO多路复用的多种实现</span></span><br><span class="line">    <span class="keyword">if</span> (aeApiCreate(eventLoop) == <span class="number">-1</span>) <span class="keyword">goto</span> err;</span><br><span class="line">    <span class="comment">/* Events with mask == AE_NONE are not set. So let's initialize the</span></span><br><span class="line"><span class="comment">     * vector with it. */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; setsize; i++)</span><br><span class="line">        eventLoop-&gt;events[i].mask = AE_NONE;</span><br><span class="line">    <span class="keyword">return</span> eventLoop;</span><br><span class="line">    <span class="keyword">return</span> eventLoop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Redis</code>支持多个地址端口的绑定，文件句柄都存储在<code>server.ipfd</code>，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ipfd[CONFIG_BINDADDR_MAX]; <span class="comment">// 用于监听客户端请求的文件句柄</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 服务器初始化 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initServer</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// socket.listen绑定监听端口</span></span><br><span class="line">    <span class="keyword">if</span> (server.port != <span class="number">0</span> &amp;&amp;</span><br><span class="line">        listenToPort(server.port,server.ipfd,&amp;server.ipfd_count) == C_ERR)</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 每一个fd创建一个可读事件，并设置socket.accept回调</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; server.ipfd_count; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (aeCreateFileEvent(server.el, server.ipfd[j], AE_READABLE,</span><br><span class="line">            acceptTcpHandler,<span class="literal">NULL</span>) == AE_ERR)</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>aeCreateFileEvent</code>是用于为监听的句柄创建事件及其对应的处理器，其中，<code>aeApiAddEvent</code>存在多种IO多路复用的实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 为句柄创建事件 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">aeCreateFileEvent</span><span class="params">(aeEventLoop *eventLoop, <span class="keyword">int</span> fd, <span class="keyword">int</span> mask,</span></span></span><br><span class="line"><span class="function"><span class="params">        aeFileProc *proc, <span class="keyword">void</span> *clientData)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 获取句柄对应的事件</span></span><br><span class="line">    aeFileEvent *fe = &amp;eventLoop-&gt;events[fd];</span><br><span class="line">    <span class="comment">// 将句柄加入到事件监听中（select/epoll/...）</span></span><br><span class="line">    <span class="comment">// 具体参考：IO多路复用的多种实现</span></span><br><span class="line">    <span class="keyword">if</span> (aeApiAddEvent(eventLoop, fd, mask) == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> AE_ERR;</span><br><span class="line">    fe-&gt;mask |= mask;</span><br><span class="line">    <span class="comment">// 设置事件回调（区分读写）</span></span><br><span class="line">    <span class="keyword">if</span> (mask &amp; AE_READABLE) fe-&gt;rfileProc = proc;</span><br><span class="line">    <span class="keyword">if</span> (mask &amp; AE_WRITABLE) fe-&gt;wfileProc = proc;</span><br><span class="line">    <span class="comment">// 设置客户端信息</span></span><br><span class="line">    fe-&gt;clientData = clientData;</span><br><span class="line">    <span class="keyword">return</span> AE_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/redis-ae-3.png" alt=""></p><p><code>acceptTcpHandler</code>是<code>Socket.Accept</code>接收到新的客户端请求的处理器，用于设置后续的可读事件，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 处理监听到的Accept请求 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">acceptTcpHandler</span><span class="params">(aeEventLoop *el, <span class="keyword">int</span> fd, <span class="keyword">void</span> *privdata, <span class="keyword">int</span> mask)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">while</span>(max--) &#123;</span><br><span class="line">        <span class="comment">// Accept句柄fd监听到的请求，返回客户端句柄cfd</span></span><br><span class="line">        cfd = anetTcpAccept(server.neterr, fd, cip, <span class="keyword">sizeof</span>(cip), &amp;cport);</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">/* Accept成功后设置可读事件 */</span></span><br><span class="line">        acceptCommonHandler(cfd,<span class="number">0</span>,cip);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>acceptCommonHandler</code>是用于Accept后用于<code>初始化客户端并设置可读事件</code>的处理器。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">acceptCommonHandler</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> flags, <span class="keyword">char</span> *ip)</span> </span>&#123;</span><br><span class="line">    client *c;</span><br><span class="line">    <span class="comment">/* 创建客户端（内部初始化可读事件） */</span></span><br><span class="line">    <span class="keyword">if</span> ((c = createClient(fd)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化客户端并设置可读事件 */</span></span><br><span class="line"><span class="function">client *<span class="title">createClient</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化客户端</span></span><br><span class="line">    client *c = zmalloc(<span class="keyword">sizeof</span>(client));</span><br><span class="line">    <span class="keyword">if</span> (fd != <span class="number">-1</span>) &#123;</span><br><span class="line">        anetNonBlock(<span class="literal">NULL</span>,fd);                         <span class="comment">// 是否阻塞</span></span><br><span class="line">        anetEnableTcpNoDelay(<span class="literal">NULL</span>,fd);                  <span class="comment">// 是否关闭Nagle算法</span></span><br><span class="line">        <span class="keyword">if</span> (server.tcpkeepalive)</span><br><span class="line">            anetKeepAlive(<span class="literal">NULL</span>,fd,server.tcpkeepalive);   <span class="comment">// 设置keepalive</span></span><br><span class="line">        <span class="comment">// 为当前客户端创建可读事件，并设置读取处理函数readQueryFromClient（下面有详细介绍）</span></span><br><span class="line">        <span class="keyword">if</span> (aeCreateFileEvent(server.el,fd,AE_READABLE,</span><br><span class="line">            readQueryFromClient, c) == AE_ERR)</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>到此，<code>Redis</code>服务端的<code>Socket绑定与监听</code>、<code>客户端初始化</code>等初始化逻辑已经分析完毕。</p></blockquote><h5 id="主流程"><a href="#主流程" class="headerlink" title="主流程"></a>主流程</h5><p>Redis的处理过程是<code>单线程的</code>，事件驱动的核心就在<code>aeMain</code>这个循环体内。</p><blockquote><p>基于内核提供的<code>select/poll/epoll</code>来轮询事件实现循环执行。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">aeMain</span><span class="params">(aeEventLoop *eventLoop)</span> </span>&#123;</span><br><span class="line">    eventLoop-&gt;stop = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 事件循环</span></span><br><span class="line">    <span class="keyword">while</span> (!eventLoop-&gt;stop) &#123;</span><br><span class="line">        <span class="keyword">if</span> (eventLoop-&gt;beforesleep != <span class="literal">NULL</span>)</span><br><span class="line">            <span class="comment">// 触发事件循环的前置处理器</span></span><br><span class="line">            eventLoop-&gt;beforesleep(eventLoop);</span><br><span class="line">        <span class="comment">// 事件处理</span></span><br><span class="line">        aeProcessEvents(eventLoop, AE_ALL_EVENTS|AE_CALL_AFTER_SLEEP);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h5><p><img src="/images/redis-ae-4.png" alt=""></p><p><code>aeProcessEvents</code>是具体的处理逻辑，包括了<code>事件获取</code>、<code>事件分发</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 事件处理函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">aeProcessEvents</span><span class="params">(aeEventLoop *eventLoop, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 处理数量</span></span><br><span class="line">    <span class="keyword">int</span> processed = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// IO多路复用API, 获取并设置等待处理的事件数量（eventloop.fired）</span></span><br><span class="line">    <span class="keyword">int</span> numevents = aeApiPoll(eventLoop, tvp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 触发事件循环的后置处理器</span></span><br><span class="line">    <span class="keyword">if</span> (eventLoop-&gt;aftersleep != <span class="literal">NULL</span> &amp;&amp; flags &amp; AE_CALL_AFTER_SLEEP)</span><br><span class="line">        eventLoop-&gt;aftersleep(eventLoop);</span><br><span class="line">        </span><br><span class="line">    <span class="comment">/* 开始分发事件，执行对应的处理器 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历已触发待处理的事件</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; numevents; j++) &#123;</span><br><span class="line">        aeFileEvent *fe = &amp;eventLoop-&gt;events[eventLoop-&gt;fired[j].fd];</span><br><span class="line">        <span class="keyword">int</span> mask = eventLoop-&gt;fired[j].mask;  <span class="comment">// 事件类型</span></span><br><span class="line">        <span class="keyword">int</span> fd = eventLoop-&gt;fired[j].fd;      <span class="comment">// 事件句柄</span></span><br><span class="line">        <span class="keyword">int</span> fired = <span class="number">0</span>;                        <span class="comment">// 统计事件</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 是否开启强制先写后读</span></span><br><span class="line">        <span class="keyword">int</span> invert = fe-&gt;mask &amp; AE_BARRIER;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果未开启先写后读且为读事件</span></span><br><span class="line">        <span class="keyword">if</span> (!invert &amp;&amp; fe-&gt;mask &amp; mask &amp; AE_READABLE) &#123;</span><br><span class="line">            fe-&gt;rfileProc(eventLoop,fd,fe-&gt;clientData,mask);</span><br><span class="line">            fired++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果为写事件</span></span><br><span class="line">        <span class="keyword">if</span> (fe-&gt;mask &amp; mask &amp; AE_WRITABLE) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!fired || fe-&gt;wfileProc != fe-&gt;rfileProc) &#123;</span><br><span class="line">                fe-&gt;wfileProc(eventLoop,fd,fe-&gt;clientData,mask);</span><br><span class="line">                fired++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果开启先写后读且为读事件</span></span><br><span class="line">        <span class="keyword">if</span> (invert &amp;&amp; fe-&gt;mask &amp; mask &amp; AE_READABLE) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!fired || fe-&gt;wfileProc != fe-&gt;rfileProc) &#123;</span><br><span class="line">                fe-&gt;rfileProc(eventLoop,fd,fe-&gt;clientData,mask);</span><br><span class="line">                fired++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理数量+1</span></span><br><span class="line">        processed++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 处理定时事件</span></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; AE_TIME_EVENTS)</span><br><span class="line">        processed += processTimeEvents(eventLoop);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> processed; <span class="comment">/* return the number of processed file/time events */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>从上面的源码分析得出：<code>事件的收集工作是系统负责的，Redis仅通过每次的循环来不断拿到最新的触发事件</code>。</p></blockquote><p><strong>AE事件驱动的原理：IO多路复用</strong></p><p>在上面的处理过程中，使用了<code>aeApiPoll</code>这个函数，按不同平台的实现方式有：</p><ul><li><code>ae_evport</code>：Solaris 10</li><li><code>ae_kqueue</code>：OS X / FreeBSD</li><li><code>ae_select</code>：通用的</li><li><code>ae_epoll</code>：Linux</li></ul><blockquote><p><a href="https://stackoverflow.com/questions/26420947/what-are-the-underlying-differences-among-select-epoll-kqueue-and-evport" target="_blank" rel="noopener">What are the underlying differences among select, epoll, kqueue, and evport?</a></p></blockquote><p><code>Select</code>最多支持1024个文件句柄，由于每次都需要遍历所有的操作符的状态，因此，时间复杂度是O(n)；</p><p><code>Evport</code>、<code>Epoll</code>、<code>KQueue</code>支持更多的文件句柄，基于系统的实现策略不需要遍历操作符，时间复杂度是O(1)。</p><p>这里仅分析基于<code>epoll</code>的实现。</p><h6 id="事件注册"><a href="#事件注册" class="headerlink" title="事件注册"></a>事件注册</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">aeApiAddEvent</span><span class="params">(aeEventLoop *eventLoop, <span class="keyword">int</span> fd, <span class="keyword">int</span> mask)</span> </span>&#123;</span><br><span class="line">    aeApiState *state = eventLoop-&gt;apidata;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ee</span> = &#123;</span><span class="number">0</span>&#125;;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 识别读写事件，设置EPOLLIN/EPOLLOUT</span></span><br><span class="line">    <span class="keyword">if</span> (mask &amp; AE_READABLE) ee.events |= EPOLLIN;</span><br><span class="line">    <span class="keyword">if</span> (mask &amp; AE_WRITABLE) ee.events |= EPOLLOUT;</span><br><span class="line">    ee.data.fd = fd;</span><br><span class="line">    <span class="comment">// 调用epoll的epoll_ctl注册需要监听的事件</span></span><br><span class="line">    <span class="keyword">if</span> (epoll_ctl(state-&gt;epfd,op,fd,&amp;ee) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="事件获取"><a href="#事件获取" class="headerlink" title="事件获取"></a>事件获取</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AE事件获取</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">aeApiPoll</span><span class="params">(aeEventLoop *eventLoop, struct timeval *tvp)</span> </span>&#123;</span><br><span class="line">    aeApiState *state = eventLoop-&gt;apidata;</span><br><span class="line">    <span class="keyword">int</span> retval, numevents = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用epoll的epoll_wait获取等待事件（类似select调用）</span></span><br><span class="line">    retval = epoll_wait(state-&gt;epfd,state-&gt;events,eventLoop-&gt;setsize,</span><br><span class="line">            tvp ? (tvp-&gt;tv_sec*<span class="number">1000</span> + tvp-&gt;tv_usec/<span class="number">1000</span>) : <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span> (retval &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="comment">// 循环遍历所有已触发的事件</span></span><br><span class="line">        numevents = retval;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; numevents; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> mask = <span class="number">0</span>;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> *<span class="title">e</span> = <span class="title">state</span>-&gt;<span class="title">events</span>+<span class="title">j</span>;</span></span><br><span class="line">            <span class="comment">// 识别事件类型</span></span><br><span class="line">            <span class="keyword">if</span> (e-&gt;events &amp; EPOLLIN) mask |= AE_READABLE;</span><br><span class="line">            <span class="keyword">if</span> (e-&gt;events &amp; EPOLLOUT) mask |= AE_WRITABLE;</span><br><span class="line">            <span class="keyword">if</span> (e-&gt;events &amp; EPOLLERR) mask |= AE_WRITABLE;</span><br><span class="line">            <span class="keyword">if</span> (e-&gt;events &amp; EPOLLHUP) mask |= AE_WRITABLE;</span><br><span class="line">            <span class="comment">// 设置链接的文件句柄</span></span><br><span class="line">            eventLoop-&gt;fired[j].fd = e-&gt;data.fd;</span><br><span class="line">            <span class="comment">// 设置事件类型</span></span><br><span class="line">            eventLoop-&gt;fired[j].mask = mask;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numevents;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="事件处理-1"><a href="#事件处理-1" class="headerlink" title="事件处理"></a>事件处理</h6><p><strong>读取</strong></p><p><img src="/images/redis-ae-5.png" alt=""></p><p><code>readQueryFromClient</code>是从客户端读取请求数据的处理函数，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每次读取Buffer的默认大小：16K</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROTO_IOBUF_LEN         (1024*16)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 读取客户端请求 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readQueryFromClient</span><span class="params">(aeEventLoop *el, <span class="keyword">int</span> fd, <span class="keyword">void</span> *privdata, <span class="keyword">int</span> mask)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 客户端连接的配置信息</span></span><br><span class="line">    client *c = (client*) privdata;</span><br><span class="line">    <span class="comment">// 设置读取大小</span></span><br><span class="line">    readlen = PROTO_IOBUF_LEN;</span><br><span class="line">    <span class="comment">// 获取客户端已经读取过的大小</span></span><br><span class="line">    qblen = sdslen(c-&gt;querybuf);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 扩展客户端请求buffer的大小</span></span><br><span class="line">    c-&gt;querybuf = sdsMakeRoomFor(c-&gt;querybuf, readlen);</span><br><span class="line">    <span class="comment">// 读取数据，追加在原有querybuf内容的后面</span></span><br><span class="line">    nread = read(fd, c-&gt;querybuf+qblen, readlen);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 处理客户端请求buffer中的数据</span></span><br><span class="line">    processInputBufferAndReplicate(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理Buffer</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processInputBufferAndReplicate</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(c-&gt;flags &amp; CLIENT_MASTER)) &#123;</span><br><span class="line">        processInputBuffer(c);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>执行</strong></p><p><img src="/images/redis-ae-6.png" alt=""></p><p><code>processInputBuffer</code>是用于解析客户端请求的Buffer并调用<code>processCommand</code>执行对应的操作，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 处理缓存内的请求数据 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processInputBuffer</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 设置当前处理的客户端</span></span><br><span class="line">    server.current_client = c;</span><br><span class="line">    <span class="comment">// 循环读取Buffer并处理</span></span><br><span class="line">    <span class="keyword">while</span>(c-&gt;qb_pos &lt; sdslen(c-&gt;querybuf)) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 根据不同的请求类型，尝试解析请求命令（数据完整），否则，进入下一次循环</span></span><br><span class="line">        <span class="keyword">if</span> (c-&gt;reqtype == PROTO_REQ_INLINE) &#123;</span><br><span class="line">            <span class="keyword">if</span> (processInlineBuffer(c) != C_OK) <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c-&gt;reqtype == PROTO_REQ_MULTIBULK) &#123;</span><br><span class="line">            <span class="keyword">if</span> (processMultibulkBuffer(c) != C_OK) <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            serverPanic(<span class="string">"Unknown request type"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 无参数，重置客户端</span></span><br><span class="line">        <span class="keyword">if</span> (c-&gt;argc == <span class="number">0</span>) &#123;</span><br><span class="line">            resetClient(c);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 执行命令</span></span><br><span class="line">            <span class="keyword">if</span> (processCommand(c) == C_OK) &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 处理完毕清空当前处理客户端</span></span><br><span class="line">    server.current_client = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>processInlineBuffer</code>与<code>processMultibulkBuffer</code>是用于命令解析的，如果解析成功则执行命令，否则，进入下一轮循环读取剩余Buffer。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 执行命令 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">processCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 处理quit命令</span></span><br><span class="line">    <span class="keyword">if</span> (!strcasecmp(c-&gt;argv[<span class="number">0</span>]-&gt;ptr,<span class="string">"quit"</span>)) &#123;</span><br><span class="line">        addReply(c,shared.ok);</span><br><span class="line">        c-&gt;flags |= CLIENT_CLOSE_AFTER_REPLY;</span><br><span class="line">        <span class="keyword">return</span> C_ERR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查询argv[0]对应的命令</span></span><br><span class="line">    c-&gt;cmd = c-&gt;lastcmd = lookupCommand(c-&gt;argv[<span class="number">0</span>]-&gt;ptr);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/* 此处忽略了命令执行前的条件判断，命令的执行受主从、持久化等问题的影响 */</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 开始执行命令 </span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_MULTI &amp;&amp;</span><br><span class="line">        c-&gt;cmd-&gt;proc != execCommand &amp;&amp; c-&gt;cmd-&gt;proc != discardCommand &amp;&amp;</span><br><span class="line">        c-&gt;cmd-&gt;proc != multiCommand &amp;&amp; c-&gt;cmd-&gt;proc != watchCommand)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// MULTI 开启事务，命令入队列</span></span><br><span class="line">        queueMultiCommand(c);</span><br><span class="line">        addReply(c,shared.queued);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 直接执行命令</span></span><br><span class="line">        call(c,CMD_CALL_FULL);</span><br><span class="line">        c-&gt;woff = server.master_repl_offset;</span><br><span class="line">        <span class="keyword">if</span> (listLength(server.ready_keys))</span><br><span class="line">            handleClientsBlockedOnKeys();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> C_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 命令入队列 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">queueMultiCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 申请空间</span></span><br><span class="line">    c-&gt;mstate.commands = zrealloc(c-&gt;mstate.commands,</span><br><span class="line">            <span class="keyword">sizeof</span>(multiCmd)*(c-&gt;mstate.count+<span class="number">1</span>));</span><br><span class="line">    <span class="comment">// 设置命令</span></span><br><span class="line">    mc = c-&gt;mstate.commands+c-&gt;mstate.count;</span><br><span class="line">    mc-&gt;cmd = c-&gt;cmd;</span><br><span class="line">    mc-&gt;argc = c-&gt;argc;</span><br><span class="line">    mc-&gt;argv = zmalloc(<span class="keyword">sizeof</span>(robj*)*c-&gt;argc);</span><br><span class="line">    <span class="built_in">memcpy</span>(mc-&gt;argv,c-&gt;argv,<span class="keyword">sizeof</span>(robj*)*c-&gt;argc);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>call</code>是在没有事务的情况下，直接执行，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 执行命令 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">call</span><span class="params">(client *c, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 通知监控</span></span><br><span class="line">    <span class="keyword">if</span> (listLength(server.monitors) &amp;&amp;</span><br><span class="line">        !server.loading &amp;&amp;</span><br><span class="line">        !(c-&gt;cmd-&gt;flags &amp; (CMD_SKIP_MONITOR|CMD_ADMIN)))</span><br><span class="line">    &#123;</span><br><span class="line">        replicationFeedMonitors(c,server.monitors,c-&gt;db-&gt;id,c-&gt;argv,c-&gt;argc);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 执行命令</span></span><br><span class="line">    c-&gt;cmd-&gt;proc(c);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 记录慢日志</span></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; CMD_CALL_SLOWLOG &amp;&amp; c-&gt;cmd-&gt;proc != execCommand) &#123;</span><br><span class="line">        <span class="keyword">char</span> *latency_event = (c-&gt;cmd-&gt;flags &amp; CMD_FAST) ?</span><br><span class="line">                              <span class="string">"fast-command"</span> : <span class="string">"command"</span>;</span><br><span class="line">        latencyAddSampleIfNeeded(latency_event,duration/<span class="number">1000</span>);</span><br><span class="line">        slowlogPushEntryIfNeeded(c,c-&gt;argv,c-&gt;argc,duration);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 传播命令</span></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; CMD_CALL_PROPAGATE &amp;&amp;</span><br><span class="line">        (c-&gt;flags &amp; CLIENT_PREVENT_PROP) != CLIENT_PREVENT_PROP)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> propagate_flags = PROPAGATE_NONE;</span><br><span class="line">        <span class="comment">// 传播命令到Slave和AOF</span></span><br><span class="line">        <span class="keyword">if</span> (dirty) propagate_flags |= (PROPAGATE_AOF|PROPAGATE_REPL);</span><br><span class="line">        <span class="comment">// 强制传播命令到Slaver和AOF</span></span><br><span class="line">        <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_FORCE_REPL) propagate_flags |= PROPAGATE_REPL;</span><br><span class="line">        <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_FORCE_AOF) propagate_flags |= PROPAGATE_AOF;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (propagate_flags != PROPAGATE_NONE &amp;&amp; !(c-&gt;cmd-&gt;flags &amp; CMD_MODULE))</span><br><span class="line">            <span class="comment">// 传播命令</span></span><br><span class="line">            propagate(c-&gt;cmd,c-&gt;db-&gt;id,c-&gt;argv,c-&gt;argc,propagate_flags);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 传播命令 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">propagate</span><span class="params">(struct redisCommand *cmd, <span class="keyword">int</span> dbid, robj **argv, <span class="keyword">int</span> argc,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 传播命令给AOF和Slaver</span></span><br><span class="line">    <span class="keyword">if</span> (server.aof_state != AOF_OFF &amp;&amp; flags &amp; PROPAGATE_AOF)</span><br><span class="line">        feedAppendOnlyFile(cmd,dbid,argv,argc);</span><br><span class="line">    <span class="keyword">if</span> (flags &amp; PROPAGATE_REPL)</span><br><span class="line">        replicationFeedSlaves(server.slaves,dbid,argv,argc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>写入</strong></p><p><img src="/images/redis-ae-7.png" alt=""></p><p><code>addReply</code>是用于给客户端返回执行结果，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 请求返回 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addReply</span><span class="params">(client *c, robj *obj)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断是否需要给客户端返回数据</span></span><br><span class="line">    <span class="keyword">if</span> (prepareClientToWrite(c) != C_OK) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sdsEncodedObject(obj)) &#123;</span><br><span class="line">        <span class="comment">// 尝试写入响应Buffer，Buffer无法存储的话写入响应链表</span></span><br><span class="line">        <span class="keyword">if</span> (_addReplyToBuffer(c,obj-&gt;ptr,sdslen(obj-&gt;ptr)) != C_OK)</span><br><span class="line">            _addReplyStringToList(c,obj-&gt;ptr,sdslen(obj-&gt;ptr));</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 判断是否需要给客户端返回数据*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prepareClientToWrite</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 过滤lua脚本</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; (CLIENT_LUA|CLIENT_MODULE)) <span class="keyword">return</span> C_OK;</span><br><span class="line">    <span class="comment">// 过滤不需要返回</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; (CLIENT_REPLY_OFF|CLIENT_REPLY_SKIP)) <span class="keyword">return</span> C_ERR;</span><br><span class="line">    <span class="comment">// 过滤主线程</span></span><br><span class="line">    <span class="keyword">if</span> ((c-&gt;flags &amp; CLIENT_MASTER) &amp;&amp;</span><br><span class="line">        !(c-&gt;flags &amp; CLIENT_MASTER_FORCE_REPLY)) <span class="keyword">return</span> C_ERR;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/* client加入回写队列*/</span></span><br><span class="line">    <span class="keyword">if</span> (!clientHasPendingReplies(c)) clientInstallWriteHandler(c);</span><br><span class="line">    <span class="keyword">return</span> C_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>clientInstallWriteHandler</code>是客户端回写处理器，它仅会把<code>写入命令缓存到写入队列</code>中，并<code>不会直接返回结果</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 把客户端加入等待回写队列 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clientInstallWriteHandler</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    c-&gt;flags |= CLIENT_PENDING_WRITE;</span><br><span class="line">    <span class="comment">// 加入到等待回写队列</span></span><br><span class="line">    listAddNodeHead(server.clients_pending_write,c);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，Redis内部对客户端的请求处理完毕，还没有发现哪里完成了最后结果的写入。</p><blockquote><p>再回头看一下<code>beforeSleep</code>到底做了什么？</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 每次循环一次执行一次 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">beforeSleep</span><span class="params">(struct aeEventLoop *eventLoop)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// flush到AOF</span></span><br><span class="line">    flushAppendOnlyFile(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 处理等待回写的客户端</span></span><br><span class="line">    handleClientsWithPendingWrites();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 用于处理等待回复的客户端 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">handleClientsWithPendingWrites</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 循环遍历回写队列</span></span><br><span class="line">    listRewind(server.clients_pending_write,&amp;li);</span><br><span class="line">    <span class="keyword">while</span>((ln = listNext(&amp;li))) &#123;</span><br><span class="line">        <span class="comment">// 获取并移除客户端</span></span><br><span class="line">        client *c = listNodeValue(ln);</span><br><span class="line">        c-&gt;flags &amp;= ~CLIENT_PENDING_WRITE;</span><br><span class="line">        listDelNode(server.clients_pending_write,ln);</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 尝试向客户端回写数据</span></span><br><span class="line">        <span class="keyword">if</span> (writeToClient(c-&gt;fd,c,<span class="number">0</span>) == C_ERR) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 如果未完成回写数据，则注册异步回写事件</span></span><br><span class="line">        <span class="keyword">if</span> (clientHasPendingReplies(c)) &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">// 创建写入事件</span></span><br><span class="line">            <span class="keyword">if</span> (aeCreateFileEvent(server.el, c-&gt;fd, ae_flags,</span><br><span class="line">                <span class="comment">/* 回写客户端处理器 */</span></span><br><span class="line">                sendReplyToClient, c) == AE_ERR)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 回写客户端处理器 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sendReplyToClient</span><span class="params">(aeEventLoop *el, <span class="keyword">int</span> fd, <span class="keyword">void</span> *privdata, <span class="keyword">int</span> mask)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/* 尝试向客户端回写数据 */</span></span><br><span class="line">    writeToClient(fd,privdata,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/redis-ae-8.png" alt=""></p><p><code>writeToClient</code>是用于回写数据的处理函数，回写数据位于<code>client-&gt;bufpos</code>与<code>client-&gt;reply</code>，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 回写数据 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">writeToClient</span><span class="params">(<span class="keyword">int</span> fd, client *c, <span class="keyword">int</span> handler_installed)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 循环读取并回写数据</span></span><br><span class="line">    <span class="keyword">while</span>(clientHasPendingReplies(c)) &#123;</span><br><span class="line">        <span class="comment">// 1. 检查缓冲区并回写</span></span><br><span class="line">        <span class="keyword">if</span> (c-&gt;bufpos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 调用socket.write来写入数据</span></span><br><span class="line">            nwritten = write(fd,c-&gt;buf+c-&gt;sentlen,c-&gt;bufpos-c-&gt;sentlen);</span><br><span class="line">            ...</span><br><span class="line">        <span class="comment">// 2. 检查reply并回写</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            o = listNodeValue(listFirst(c-&gt;reply));</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">// 同上，写入数据</span></span><br><span class="line">            nwritten = write(fd, o-&gt;buf + c-&gt;sentlen, objlen - c-&gt;sentlen);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 当前节点写入完成后删除</span></span><br><span class="line">            <span class="keyword">if</span> (c-&gt;sentlen == objlen) &#123;</span><br><span class="line">                c-&gt;reply_bytes -= o-&gt;size;</span><br><span class="line">                listDelNode(c-&gt;reply,listFirst(c-&gt;reply));</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当回写字节数超过限制，则暂停回写退出（注册回写事件异步触发）</span></span><br><span class="line">        <span class="keyword">if</span> (totwritten &gt; NET_MAX_WRITES_PER_EVENT &amp;&amp;</span><br><span class="line">            (server.maxmemory == <span class="number">0</span> ||</span><br><span class="line">             zmalloc_used_memory() &lt; server.maxmemory) &amp;&amp;</span><br><span class="line">            !(c-&gt;flags &amp; CLIENT_SLAVE)) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> C_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在看下afterloop到底做了什么，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterSleep</span><span class="params">(struct aeEventLoop *eventLoop)</span> </span>&#123;</span><br><span class="line">    UNUSED(eventLoop);</span><br><span class="line">    <span class="comment">// 如果存在模块，则加全局锁</span></span><br><span class="line">    <span class="keyword">if</span> (moduleCount()) moduleAcquireGIL();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">moduleAcquireGIL</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;moduleGIL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加全局锁的目的是<code>为了避免模块与Redis框架并发读写数据的问题</code>。</p><blockquote><p><code>call</code>命令会自动调用<code>addReply</code>进行数据的回写，</p></blockquote><p>以<code>set</code>命令为例，对应的函数为<code>setGenericCommand</code>，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setGenericCommand</span><span class="params">(redisClient *c, <span class="keyword">int</span> flags, robj *key,</span></span></span><br><span class="line"><span class="function"><span class="params">        robj *val, robj *expire, <span class="keyword">int</span> unit, robj *ok_reply,</span></span></span><br><span class="line"><span class="function"><span class="params">        robj *abort_reply)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//将键值关联到数据库</span></span><br><span class="line">    setKey(c-&gt;db,key,val);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 回写结果</span></span><br><span class="line">    addReply(c, ok_reply ? ok_reply : shared.ok);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;AE事件驱动是Redis命令解析处理的基础。&lt;/p&gt;
    
    </summary>
    
      <category term="中间件" scheme="http://simyy.cn/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
      <category term="中间件" scheme="http://simyy.cn/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
      <category term="缓存" scheme="http://simyy.cn/tags/%E7%BC%93%E5%AD%98/"/>
    
      <category term="Redis" scheme="http://simyy.cn/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>领域驱动设计的理解与实践</title>
    <link href="http://simyy.cn/2020/05/30/domain-driven-design/"/>
    <id>http://simyy.cn/2020/05/30/domain-driven-design/</id>
    <published>2020-05-30T14:33:56.000Z</published>
    <updated>2020-05-30T14:56:10.414Z</updated>
    
    <content type="html"><![CDATA[<p>记录领域驱动设计的理解与实践。</p><a id="more"></a><h3 id="DDD-amp-架构"><a href="#DDD-amp-架构" class="headerlink" title="DDD &amp; 架构"></a>DDD &amp; 架构</h3><p><code>DDD（Domain Driven Design，领域驱动设计）</code>是基于业务领域实现的一种软件架构方法。</p><blockquote><p><code>DDD</code>的作用是将<code>业务架构</code>转变为<code>系统架构和技术架构</code>。</p></blockquote><p>按照架构角度的不同，可分为如下三类：</p><ul><li><code>业务架构</code>：业务视角，描述业务模块以及关系；</li></ul><p>业务架构的原型往往是业务方最先提出的，包含大体的业务需求。</p><p>完整的业务架构图是由业务、产品、技术在不断的需求迭代与架构演进不断完善的。</p><p><img src="/images/domain-driven-design-01.png" alt=""></p><ul><li><code>应用架构</code>：应用（系统）视角，描述应用系统及其依赖关系；</li></ul><p>应用架构图是架构演进的结果。</p><p>随着业务的发展，会带来组织划分与应用拆分，应用架构也在不断演进。</p><p><img src="/images/domain-driven-design-02.png" alt=""></p><ul><li><code>技术架构</code>：技术视角，描述应用技术选型及其功能作用。</li></ul><p>技术架构是当前系统（应用）的技术细节的描述，包括技术选型以及其应用场景。</p><p>技术架构是面向技术人员的，用于了解软件设计的细节。</p><p><img src="/images/domain-driven-design-03.png" alt=""></p><h3 id="Domain-Driven-Design"><a href="#Domain-Driven-Design" class="headerlink" title="Domain Driven Design"></a>Domain Driven Design</h3><p>开发视角的转变：从单纯的<code>技术视角</code>转变为<code>业务视角</code>。</p><p>开发人员往往从技术角度来剖析需求，大部分情况缺少从业务角度的全局思考，对业务与架构的演进缺少前瞻性导致架构的局限性。</p><blockquote><p>尤其在业务开展的初级，开发人员对业务理解不够深入。</p></blockquote><h4 id="领域专家"><a href="#领域专家" class="headerlink" title="领域专家"></a>领域专家</h4><p><code>领域专家</code>是指那些掌握领域内知识的人，对该领域有很深入的理解。</p><p><code>产品</code>、<code>技术</code>、<code>业务</code>都可以是领域专家，其中，<code>业务</code>一般掌握着最真实的领域知识。</p><p>与<code>领域专家</code>沟通学习是架构设计的基础，无论是产品、技术、架构师，都需要与领域专家深入的学习领域知识。</p><h4 id="通用语言"><a href="#通用语言" class="headerlink" title="通用语言"></a>通用语言</h4><p>由于领域专家并不一定是产品、技术，因此与领域专家的沟通必然存在一定问题（行业不同）。</p><p><code>通用语言</code>是解决领域专家与产品开发沟通的关键。</p><blockquote><p>让大家都能听懂的专业名词，例如，SPU是商品，SKU是某种规格的商品。</p></blockquote><h4 id="领域建模"><a href="#领域建模" class="headerlink" title="领域建模"></a>领域建模</h4><p>基于通用语言，与领域专家沟通学习领域知识，抽象出一套领域知识模型。</p><h5 id="领域-amp-限界上下文"><a href="#领域-amp-限界上下文" class="headerlink" title="领域 &amp; 限界上下文"></a>领域 &amp; 限界上下文</h5><p><code>限界上下文</code>是领域的边界，也是领域模型的边界。</p><blockquote><p><code>康威定律</code>可以作为领域划分的一种规则。</p><p>组织与领域按照一一对应的关系来划分，实现领域的高内聚。</p></blockquote><p>领域内可以包含多个<code>限界上下文</code>，此时，可以划分为多个<code>细分子域</code>。</p><p><img src="/images/domain-driven-design-04.png" alt=""></p><p>根据细分子域的不同性质，又可以划分为：</p><ul><li><code>核心子域</code>：领域的核心，包含该领域内的核心领域知识；</li><li><code>支撑子域</code>：用于支撑核心子域；</li><li><code>通用子域</code>：公共的功能模块。</li></ul><p><img src="/images/domain-driven-design-05.png" alt=""></p><h5 id="架构演进"><a href="#架构演进" class="headerlink" title="架构演进"></a>架构演进</h5><p>领域模型需要不断演进来满足业务的迭代。</p><p>业务迭代会造成领域模型的拆分、增加，都会对原有架构产生巨大的挑战。</p><p><img src="/images/domain-driven-design-06.png" alt=""></p><h5 id="细分子域"><a href="#细分子域" class="headerlink" title="细分子域"></a>细分子域</h5><p>领域划分是从全局来考虑架构结构的划分，属于架构顶层功能模块的划分。</p><p>对于开发人员来说，<code>细分子域的领域模型的构建</code>才是软件实现的关键。</p><blockquote><p>开发人员不仅仅不要掌握细分子域，也需要了解和掌握整理领域的划分。</p></blockquote><h5 id="实体-amp-值对象"><a href="#实体-amp-值对象" class="headerlink" title="实体 &amp; 值对象"></a>实体 &amp; 值对象</h5><p><code>实体</code>是指<code>具有唯一标识</code>的对象，例如，User（实体）包含唯一的用户ID。</p><p><code>值对象</code>是指<code>不包含唯一标识</code>的对象且<code>不可修改</code>，例如，Address对于其他用户来说，只是用户的一个属性，不可修改。</p><p>实体与值对象的区别在于<code>唯一性</code>。</p><p>例如，不同规格的商品属于不同实体；规格只是一种属性，对于商品来说属于值对象。</p><h5 id="聚合-amp-聚合根"><a href="#聚合-amp-聚合根" class="headerlink" title="聚合 &amp; 聚合根"></a>聚合 &amp; 聚合根</h5><p><code>聚合</code>是指一组相关对象的集合，<code>聚合根</code>作为聚合根节点，并由<code>实体</code>与<code>值对象</code>组成。</p><p>聚合属于<code>领域内知识的子集</code>，可包含多个子域知识，用于对外提供领域服务。</p><p><img src="/images/domain-driven-design-07.png" alt=""></p><h5 id="领域模型-amp-领域事件-amp-领域服务"><a href="#领域模型-amp-领域事件-amp-领域服务" class="headerlink" title="领域模型 &amp; 领域事件 &amp; 领域服务"></a>领域模型 &amp; 领域事件 &amp; 领域服务</h5><p><code>领域模型</code>是指<code>领域知识的抽象描述</code>，用于指导软件架构设计。</p><p><code>领域事件</code>是指<code>领域内发生事件的描述</code>，用于驱动关联领域的变更，可采用发布订阅模式实现。</p><p><code>领域服务</code>是指<code>领域对外提供的查询或更新服务</code>，用于外部调用。</p><p><strong>领域建模的步骤</strong></p><ul><li>领域边界、界限上下文的划分；</li><li>确认限界上下文中的核心子域、支撑子域、通用子域；</li><li>确定子域内部的实体、值对象；</li><li>划分聚合，确定聚合根；</li><li>确认限界上下文之间的关系。</li></ul><p><strong>康威定律</strong></p><p><code>康威定律</code>是指系统结构应尽量的与组织结构保持一致。</p><p>对于多个团队来说，按照团队划分顶层领域边界；</p><p>对于团队内部来说，按照小组来划分细分子域的边界。</p><h5 id="架构分类"><a href="#架构分类" class="headerlink" title="架构分类"></a>架构分类</h5><p>软件架构上一般包括为<code>CQRS</code>、<code>六边形架构（适配器架构）</code>、<code>分层架构</code>。</p><p><strong>CQRS</strong></p><p><code>CQRS</code>被称为<code>命令和查询责任分离</code>，通过拆分读写模型来实现避免资源竞争。</p><p>CQRS按照<code>读写</code>把模型拆分为：</p><ul><li><code>命令 - 领域模型</code>：用于持久化，包括领域行为，结构相对简单，事务支持；</li><li><code>查询 - 视图模型</code>：用于展示，属于非规范的模型，不包括领域行为；</li><li><code>通知 - 领域事件</code>：用于发布领域变更事件，包含领域行为。</li></ul><p><strong>六边形架构（适配器架构）</strong></p><p><code>六边形架构（适配器架构）</code>是基于适配器的设计模式的架构模型，</p><p>其主要特性如下：</p><ul><li>利用<code>依赖倒置</code>原则来分离技术框架</li><li>功能模块均采用<code>接口来实现相互依赖</code></li><li>用<code>防腐层与适配器</code>来实现外部技术框架的依赖</li></ul><p>六边形架构屏蔽了外部技术框架的细节，<code>内部功能高内聚，外部依赖低耦合</code>。</p><p><strong>分层架构</strong></p><p><code>分层架构</code>是最常见的架构模型，按照功能层级拆分为：</p><ul><li><code>用户层</code>：聚合多个顶层领域的数据，用于用户展示；</li><li><code>应用层</code>：聚合多个细分子域的数据，用于对外提供服务；</li><li><code>领域层</code>：细分子域的领域模型，可发布领域事件、执行领域行为，包括实体阈值对象的定义；</li><li><code>基础设施层</code>：提供持久化、防腐层等基础中间件的功能。</li></ul><p><img src="/images/domain-driven-design-08.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录领域驱动设计的理解与实践。&lt;/p&gt;
    
    </summary>
    
      <category term="架构" scheme="http://simyy.cn/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="架构" scheme="http://simyy.cn/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="领域建模" scheme="http://simyy.cn/tags/%E9%A2%86%E5%9F%9F%E5%BB%BA%E6%A8%A1/"/>
    
      <category term="DDD" scheme="http://simyy.cn/tags/DDD/"/>
    
  </entry>
  
  <entry>
    <title>架构设计与演进</title>
    <link href="http://simyy.cn/2020/05/27/architecture-evolution/"/>
    <id>http://simyy.cn/2020/05/27/architecture-evolution/</id>
    <published>2020-05-27T11:37:57.000Z</published>
    <updated>2020-05-27T06:41:29.492Z</updated>
    
    <content type="html"><![CDATA[<p>架构设计与演进的思考。</p><a id="more"></a><h6 id="架构到底是什么"><a href="#架构到底是什么" class="headerlink" title="架构到底是什么"></a>架构到底是什么</h6><p>架构也被称为<code>软件架构</code>，是<code>软件结构的抽象描述</code>。</p><p>架构是由<code>架构元素</code>与<code>元素之间的关系</code>组成，<code>元素的划分、选型、交互</code>是架构的关键。</p><blockquote><p>架构元素：组件/服务的划分与技术选型。<br>元素之间的关系：组件/服务之间的关联关系与交互方式。</p></blockquote><h6 id="架构的目标"><a href="#架构的目标" class="headerlink" title="架构的目标"></a>架构的目标</h6><p>架构的目标是<code>解决利益相关者的关注点</code>（<a href="https://www.infoq.cn/article/every-architect-should-study-conway-law" target="_blank" rel="noopener">参考</a>）。</p><blockquote><p><code>利益相关者</code>是与当前架构有之间或间接关系的人，也就是当前架构的目标用户，例如，业务方、产品、开发、测试等等。<br><code>关注点</code>是<code>利益相关者</code>对于当前软件的认知及痛点。</p></blockquote><p>解决不仅仅是解决当前的问题，还要有<code>前瞻性（对未来业务变化的考量</code>）。</p><p>这也就是保证架构的可迭代、可演进。</p><blockquote><p><code>架构是有生命的</code>。</p></blockquote><p>好的架构生命周期很长，支持业务的快速迭代，不断演进、进化，</p><p>相反，不好的架构没办法支持业务的迭代，不得不得对架构进行重构、重写。</p><h6 id="架构的基础"><a href="#架构的基础" class="headerlink" title="架构的基础"></a>架构的基础</h6><p><strong>领域建模</strong></p><blockquote><p><code>好的架构离不开好的领域建模</code>。</p></blockquote><p><code>领域建模</code>是架构设计的基础，它确保了架构设计的边界。</p><p>通过领域建模将领域知识转化为软件架构，这里离不开<code>领域专家</code>的配合。</p><blockquote><p>架构不是凭空想象的，是基于<code>对领域知识（领域专家提供）建模</code>的基础之上来设计的。</p></blockquote><p>对于大部分人来说，当提及领域建模时往往觉得时高大上、遥不可及的事情，事实并非如此。</p><p>领域建模是业务高度抽象的产物，范围可大可小，但需要建模者充分理解并调研领域知识。</p><blockquote><p>对领域知识理解不足，造成的建模不准确？</p><p>不要怕，最好的建模通过演进实现的，试错修正、试错优化。</p></blockquote><p><strong>真正的需求</strong></p><p>架构设计的目标是<code>通过构建合理的元素关系来满足用户的需求</code>。</p><p>由于视角的不同，利益相关者的关注点可能各不相同。</p><p>那么，好的架构一定是基于以下两点：</p><p>① 发现所有直接或间接的利益相关者；<br>② 沟通与理解利益相关者的关注点。</p><p><code>尽可能收集利益相关者的关注点</code>作为架构设计的基础。</p><p><code>如何把关注点转换为领域知识</code>是架构设计的必经之路。</p><p><strong>最小化利益冲突</strong></p><p>在沟通过程中，利益关注者之间往往会出现利益冲突的情况。</p><p>如何最小化或避免利益冲突也属于架构设计的一部分。</p><p>好的架构是<code>基于充分的调研与思考，保持利益相关者之间的利益平衡</code>。</p><blockquote><p><code>大中台小前台</code>的架构设计上是存在<code>业务方与技术方的利益冲突</code>。</p><p>前台业务方考虑的是<code>快速迭代试错</code>，而中台技术方考虑的是<code>平台的稳定性与通用性</code>。</p></blockquote><h6 id="合理架构与过渡设计"><a href="#合理架构与过渡设计" class="headerlink" title="合理架构与过渡设计"></a>合理架构与过渡设计</h6><p>什么是<code>合理架构</code>？</p><p>① 满足<code>大多数利益相关者的关注点</code>（功能点）；</p><blockquote><p>大多数意味着存在取舍，<code>合理的取舍</code>也是架构设计的一部分。</p></blockquote><p>② <code>最少的开发成本、最快的上线速度</code>，满足业务方快速迭代试错；</p><blockquote><p>快与质量差没有任何关系，<code>不要以快为不合格的架构设计而找理由</code>。</p></blockquote><p>③ 可<code>持续演进</code>的架构，需要经得起业务的不断演进。</p><p><code>刚好够用且可持续优化</code>即为合理，一切不以现状为基础的设计均属于<code>过渡设计</code>。</p><blockquote><p>开发人员，往往会把追求极致挂在嘴边，但是，<code>追求极致</code>实际上也是一种过渡设计。<br>追求极致必然会增加功能的复杂度，无论是人力成本还是时间成本都是无法容忍的。</p></blockquote><p>架构设计需要<code>从公司当前的业务、人员、成本等多方面考虑</code>，避免吹毛求疵、过渡设计。</p><blockquote><p><code>&quot;技术债&quot;</code>这个词很流行，但不是所有的技术债都是无法避免的。</p><p>架构的演进伴随着技术债的填补，也伴随着新的技术债的产生，但要<code>时刻警惕非必要技术债的产生</code>。</p></blockquote><h6 id="理想架构与架构演进"><a href="#理想架构与架构演进" class="headerlink" title="理想架构与架构演进"></a>理想架构与架构演进</h6><blockquote><p><code>没有理想的架构，只有最合适的架构</code>。</p></blockquote><p>无论哪个公司都会经历<code>从简到繁的架构演变</code>的过程。</p><p><code>架构的演进</code>是建立在合理架构的基础之上。</p><blockquote><p><a href="/2019/12/21/solid-priciple/">SOLID设计原则</a>主要用于解决如何构建可持续性的软件架构。</p></blockquote><p>架构的演进不仅包含<code>业务逻辑上的演进</code>，也包括<code>领域模型的演进</code>。</p><p><code>业务逻辑上的演进</code>是指随着需求的不断迭代对原有业务逻辑的影响。</p><p><code>领域模型的演进</code>是指随着需求的不断迭代对原有领域模型有了更加清晰的定义，它是构建<code>可持续演进架构</code>的基础。</p><p>架构设计的关键问题是<code>划清边界</code>，而架构演进的关键问题是<code>领域模型的不断演进</code>。</p><p><strong>领域演进</strong></p><p>随着业务的演进，领域模型会面临拆分的问题，同时也会产生各个细分领域的领域专家。</p><p><code>细分领域的领域专家</code>是细分领域建模的关键，也是细分领域架构设计的关键。</p><p>与此同时，架构也会面临一次拆分，不同的细分领域负责各自的架构设计，架构设计更加聚焦，这也是架构演进的必然结果。</p><h6 id="架构闭环与优化"><a href="#架构闭环与优化" class="headerlink" title="架构闭环与优化"></a>架构闭环与优化</h6><p><code>闭环</code>是指拥有一套完整的反馈机制，<code>架构闭环</code>是指拥有一套完整的系统监控与预警机制。</p><p>架构演进包括两部分：<code>性能演进</code>与<code>逻辑演进</code>。</p><blockquote><p>逻辑演进与性能演进是不和分割的。</p><p>逻辑的演进会推动性能的演进，性能演进是为了保证逻辑的演进。</p></blockquote><p>架构闭环是性能演进的必要条件。</p><p>评估架构性能瓶颈、监测系统运行情况是<code>性能演进</code>的关键。</p><h6 id="架构与组织"><a href="#架构与组织" class="headerlink" title="架构与组织"></a>架构与组织</h6><blockquote><p><code>康伟定律</code>：架构与组织是一一对应的关系。</p></blockquote><p>好的架构是<code>依赖优秀的人来实现的</code>，而优秀的人是<code>依赖好的文化来吸引的</code>。</p><hr><p>公司中总能听到一些提效的要素，例如，工具、技术、流程。</p><blockquote><p>我们要使用最先进的工具；<br>我们要使用最牛逼的技术；<br>我们要推广最高效的流程。</p><p>真的是这样吗？</p></blockquote><hr><p>架构设计时需要考虑架构维护成本，一般需要按照组织来拆解架构（组织 : 架构 = 1 : 1）。</p><p>按组织拆解架构的好处在于<code>架构的高内聚</code>，也就是说<code>以组织为单位划分架构设计与演进的职责</code>。</p><p>组织内部的架构设计更加聚焦，领域知识也更加聚焦，</p><p>从而，领域模型更加清晰，架构设计也会相对轻松（由于目标更聚焦了）。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;架构设计与演进的思考。&lt;/p&gt;
    
    </summary>
    
      <category term="架构" scheme="http://simyy.cn/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="架构" scheme="http://simyy.cn/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="领域建模" scheme="http://simyy.cn/tags/%E9%A2%86%E5%9F%9F%E5%BB%BA%E6%A8%A1/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 读写分离</title>
    <link href="http://simyy.cn/2020/05/24/mysql-replication-rw-router/"/>
    <id>http://simyy.cn/2020/05/24/mysql-replication-rw-router/</id>
    <published>2020-05-24T01:46:39.000Z</published>
    <updated>2020-05-24T02:31:16.651Z</updated>
    
    <content type="html"><![CDATA[<p>记录下读写分离的使用方式与常见问题。</p><a id="more"></a><h5 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h5><p><code>读写分离</code>是通过<code>分离数据库的读写操作</code>，通过横向扩展的能力来<code>提高读性能</code>。</p><p>如图所示，<code>Master</code>称为主库，仅处理数据库的<code>写操作</code>；<code>Slaver</code>称为从库，仅处理数据库的<code>读操作</code>。</p><p>读写分离的实现可划分为两类：<code>基于客户端实现</code>与<code>基于中间件实现</code>。</p><blockquote><p>与分库分表的实现思路相似。</p></blockquote><p><img src="/images/mysql-replication-rw-router-1.png" alt=""></p><p>两种实现的原理都在于<code>请求的动态路由</code>，根据<code>请求的分类&quot;读、写或事务&quot;</code>来动态的路由到指定的数据库实例。</p><p><strong>基于客户端实现</strong></p><p><code>基于客户端实现</code>是通过嵌入业务层来实现请求路由的功能，</p><p>优点是<code>性能好</code>，</p><p>缺点是<code>升级困难</code>、<code>问题排查难</code>、<code>客户端复杂</code>。</p><blockquote><p>由于路由功能完全内嵌在业务应用，日志也会分散在不同的业务应用，因此，问题的上报与排查都需要业务方深入合作。</p></blockquote><p><strong>基于中间件实现</strong></p><p><code>基于中间件实现</code>是通过<code>中间件拦截请求转发（动态路由）</code>到指定的数据库实例，</p><p>与基于客户端实现相反，</p><p>优点是<code>升级方便</code>、<code>问题排查容易</code>、<code>客户端无感知</code>，</p><p>缺点是<code>性能损耗大</code>、<code>业务方可能存在读异常</code>、<code>引入新的单点问题</code>。</p><blockquote><p>路由功能的实现与业务应用无关，中间件可以做到无感知的升级，而且由于路由日志集中在中间件，排查问题更加容易。</p></blockquote><h4 id="MySQL主从同步"><a href="#MySQL主从同步" class="headerlink" title="MySQL主从同步"></a>MySQL主从同步</h4><p><code>MySQL主从同步</code>是利用<code>同步binlog日志同步以及操作重放实现</code>的数据同步。</p><p><img src="/images/mysql-replication-rw-router-2.png" alt=""></p><blockquote><p><code>binlog</code>：MySQL数据库的二进制日志，用于记录用户对数据库<code>变更操作的SQL语句</code>。</p></blockquote><p><strong>步骤</strong>：</p><p>① 当Slaver连接到Master时，Master会为Slaver开启<code>binlog dump线程</code>；</p><blockquote><p><code>binlog dump线程</code>用于读取binlog信息同步到<code>Slaver</code>。</p></blockquote><p>② Slaver会创建<code>I/O 线程</code>以及来处理<code>binlog dump线程</code>的数据，写入<code>relay log</code>；</p><blockquote><p><code>relay log</code>是为了避免同步数据过程中的异常，导致数据的丢失，在<code>半同步复制</code>中有介绍。</p></blockquote><p>③ Slaver还会创建<code>SQL 线程</code>用来解析<code>relay log</code>重放操作写入数据，完成数据同步。</p><blockquote><p>同步过程中，<code>SQL解析执行一定是单线程的</code>，否则，会造成执行顺序错乱影响数据一致性。</p></blockquote><hr><p>主从同步是通过异步线程同步数据，属于<code>最终一致性</code>的实现方案，因此，必然<code>存在主从不一致的</code>问题。</p><p><strong>异步模式</strong></p><p><code>异步模式</code>是最基础的同步方式，必然存在延迟。</p><p>为了解决<code>异步模式</code>的延时问题，MySQL提出了下面几种方法来解决这个问题。</p><p><strong>半同步模式（semi-sync）</strong></p><p><code>半同步模式</code>是通过<code>强制写入relay log</code>来保证<code>至少有一台从库完成了数据同步</code>。</p><blockquote><p>仅保证写入<code>relay log</code>的延迟，无法保证写入数据的延迟，因此，半同步模式不能彻底解决问题。</p></blockquote><p>对于一主一从的读写分离的情况下，此方法可以使同步延迟的问题忽略不记。</p><p>但在一主多从的读写分离的情况下，此方法就不一定会生效了，可能存在某个从库没有即使同步数据。</p><p><strong>全同步模式</strong></p><p><code>全同步模式</code>是在半同步的基础之上保证全部从库同步数据。</p><blockquote><p>这里的保证是relay log的写入还是数据的写入？</p><p>仍然是relay log（I/O线程与SQL线程不应该再次通信），只要日志flush到磁盘就不会出现数据丢失的情况。</p></blockquote><p><strong>并行模式</strong></p><p><code>并行模式</code>是通过增加<code>SQL线程</code>来实现并行读取<code>relay log</code>实现<code>库级别的并行</code>。</p><h4 id="主从延迟解决方案"><a href="#主从延迟解决方案" class="headerlink" title="主从延迟解决方案"></a>主从延迟解决方案</h4><p><strong>背景</strong></p><p>并发写入数据可能造成主从延迟增大。</p><p><strong>解决</strong></p><p>① 增加<code>数据缓存</code>，更新数据的同时写入缓存（读全部从缓存取数据）。</p><p>② 开启<code>半同步、同步复制</code>，降低时延问题，但会影响写入性能。</p><p>③ 强制<code>路由到主库</code>。</p><p>④ 优化业务逻辑，对于异步操作通过使用<code>延迟队列</code>、<code>重试</code>的机制来解决延迟问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录下读写分离的使用方式与常见问题。&lt;/p&gt;
    
    </summary>
    
      <category term="中间件" scheme="http://simyy.cn/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
      <category term="MySQL" scheme="http://simyy.cn/tags/MySQL/"/>
    
      <category term="数据库" scheme="http://simyy.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="中间件" scheme="http://simyy.cn/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
      <category term="读写分离" scheme="http://simyy.cn/tags/%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/"/>
    
  </entry>
  
  <entry>
    <title>Java GC 调优</title>
    <link href="http://simyy.cn/2020/05/21/java-gc-optimize/"/>
    <id>http://simyy.cn/2020/05/21/java-gc-optimize/</id>
    <published>2020-05-21T12:21:32.000Z</published>
    <updated>2020-05-26T03:12:13.786Z</updated>
    
    <content type="html"><![CDATA[<p>记录Java GC调优的相关问题。</p><a id="more"></a><h4 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h4><p>常用的方式如下，</p><p><strong>第一种：</strong><code>ParNew（新生代）</code>、<code>CMS（老年代）</code></p><p><strong>第二种：</strong><code>G1（新生轻与老年代）</code></p><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><p>按照GC范围的不同，GC可分为：<code>MinorGC（YoungGC）</code>、<code>MajorGC（FullGC）</code>、<code>OldGC</code>、<code>MixedGC</code>。</p><h5 id="MinorGC"><a href="#MinorGC" class="headerlink" title="MinorGC"></a>MinorGC</h5><p><code>MinorGC</code>是<code>新生代GC</code>，在分代回收中负责堆内存年轻代的回收。</p><p><strong>触发条件</strong></p><blockquote><p>当<code>Eden区空间不足</code>就会触发<code>MinorGC</code>。</p></blockquote><p>在分代回收中，如果年轻代的空间不足会导致年轻代的垃圾回收。</p><p><strong>回收算法</strong></p><p>由于新生代的对象生命周期较短，垃圾回收也会相对频繁，因此需要考虑垃圾回收的效率。</p><p>考虑到新生代<code>朝生夕死</code>的特点，新生代采用<code>复制算法</code>，例如，<code>ParNew中仅复制存活数据到Survivor</code>。</p><p><strong>具体步骤</strong></p><p>① 扫描新生代以及老年代；</p><blockquote><p>由于存在<code>跨代引用</code>，因此需要扫描老年代。</p><p>CMS使用CardTable来记录新老代之间的跨代引用，<br>G1使用RememberSet（占堆的20%）来记录Region之间的跨代引用。</p></blockquote><p>② 复制存活对象到Survivor区，增加对象年龄；</p><blockquote><p>复制属于耗时操作，但由于<code>Eden区对象朝生夕死</code>的特点，需要复制的对象并不多。。</p></blockquote><p>③ 年龄达到阈值，晋升至老年代。</p><blockquote><p><strong>注意：</strong><code>单次MinorGC时间更多取决于GC后存活对象的数量</code>。</p></blockquote><h5 id="OldGC"><a href="#OldGC" class="headerlink" title="OldGC"></a>OldGC</h5><p><code>OldGC</code>是<code>老年代GC</code>。</p><p><code>CMS</code>属于<code>OldGC</code>，仅对分代回收中的老年代进行老几回收，一般配合<code>新生代ParNew</code>。</p><p><strong>触发条件</strong></p><p>① 手动触发<code>System.gc()</code>；</p><p>② 老年代的使用率达到阈值；</p><p><strong>回收算法</strong></p><p>由于老年代的对象生命周期较长，存活的对象比例高，因此无法使用复制算法。</p><p><code>CMS</code>采用<code>标记清除算法</code>，同样可以开启<code>内存整理</code>功能来避免内存空间碎片的问题。</p><blockquote><p>标记清除中常见的问题：<code>STW（Stop The World）</code>。</p><p><code>STW（Stop The World）</code>是为了保证标记的一致性，避免标记过程中出现遗漏的情况。</p></blockquote><blockquote><p>STW并不是必须的，但是在极端情况下，遗漏可能会导致大量的内存泄露，甚至导致宕机。</p></blockquote><p><strong>具体步骤</strong></p><p>① <code>Initial Mark</code>：从<code>GC Root</code>开始标记可达对象，触发<code>STW</code>；</p><blockquote><p>什么是<code>GC Root</code>？</p><p><strong>Local variables</strong> are kept alive by the stack of a thread.<br><strong>Active Java threads</strong> are always considered live objects and are therefore GC roots.<br><strong>Static variables</strong> are referenced by their classes.<br><strong>JNI References</strong> are Java objects that the native code has created as part of a JNI call.</p></blockquote><p>② <code>Cocurrent Mark</code>：根据①中标记的可达对象<code>并发遍历标记</code>相关联的对象状态；</p><p>③ <code>Remark</code>：重新标记在并发标记阶段发生变化的对象，触发<code>STW</code>；</p><p>④ <code>Concurrent Sweep</code>：在对象标记的基础之上，清理老年代非可达对象。</p><h5 id="MajorGC"><a href="#MajorGC" class="headerlink" title="MajorGC"></a>MajorGC</h5><p><code>MajorGC</code>是<code>FullGC</code>，不仅会触发<code>OldGC</code>，也会触发<code>YoungGC</code>。</p><blockquote><p><code>MajorGC</code>是收集整个堆内存。</p></blockquote><p><code>MajorGC</code>会自动触发<code>MinorGC</code>。</p><h5 id="MixedGC"><a href="#MixedGC" class="headerlink" title="MixedGC"></a>MixedGC</h5><p><code>MixedGC</code>是<code>新生代与老年代的混合GC</code>，它不属于<code>FullGC</code>。</p><p><code>MixedGC</code>是建立在<code>YoungGC</code>的基础之上再<code>回收部分老年代的内存</code>。</p><p><code>G1</code>属于<code>MixedGC</code>。</p><blockquote><p><code>G1</code>通过划分<code>Region</code>来实现增量回收。</p></blockquote><p><strong>触发条件</strong></p><p>当<code>E区</code>无法分配新的对象内存时会触发G1中的<code>YoungGC</code>。</p><p>当<code>使用率大于InitiatingHeapOccupancyPercent</code>会触发<code>MixedGC</code>。</p><p>当<code>Metaspace内存不足</code>时会触发<code>MixedGC</code>。</p><p><strong>回收算法</strong></p><p><code>YongGC</code>选定<code>所有年轻代Region</code>进行回收，使用<code>复制算法</code>。</p><p><code>MixedGC</code>不仅选定<code>所有年轻代Region</code>，还会根据<code>global concurrent marking</code>统计得出<code>收集后收益高的若干老年代Region</code>来选择，最终采用<code>标记清除算法</code>。</p><blockquote><p><code>G1</code>保证<code>在用户指定的开销目标范围内尽可能选择收益高的老年代Region</code>进行回收。</p><p>因此，<code>MixedGC</code>不是<code>FullGC</code>。</p></blockquote><p>当<code>MixedGC无法解决老年代内存不足</code>时，会降级为<code>SerialGC（FullGC）</code>。</p><p><strong>具体步骤</strong></p><p>① <code>Initial Mark</code>：同CMS的步骤①；</p><p>② <code>Cocurrent Mark</code>：同CMS的步骤②；</p><blockquote><p><code>SATB</code>是GC开始时活着的对象的一个快照（通过<code>Root Tracing</code>得到），用于维持并发GC的正确性。</p></blockquote><p>③ <code>Remark</code>：与CMS的区别在于<code>重新标记的范围不同</code>：G1仅需要扫描<code>SATB（snapshot-at-the-beginning, 起始快照）</code>；</p><blockquote><p><code>CMS Remark</code>的扫描范围不仅包括<code>SATB</code>，而且会扫描整个根集合。</p></blockquote><p>④ <code>Clean up/Copy</code>：在对象标记的基础之上，清理<code>新生代全部非可达</code>对象与<code>老年代部分非可达</code>对象。</p><!-- TODO R大的分析：https://hllvm-group.iteye.com/group/topic/44381#post-272188 --><h3 id="FullGC"><a href="#FullGC" class="headerlink" title="FullGC"></a>FullGC</h3><p>FullGC产生的原因有以下四种，</p><p><strong>MetaSpcae空间不足与自动扩容</strong></p><p>在Java8中，当<code>MetaSpace空间内存不足</code>时，会触发FullGC来尝试清理掉无用的内存。</p><p>为了避免这种情况，可以通过<code>增大MetaSpace空间大小</code>与<code>预设足够大的MetaSpace空间避免动态扩容</code>。</p><p><strong>CMS的promotion failed与concurrent mode failure</strong></p><p><code>MinorGC</code>时，如果<code>Survivor</code>空间不足，对象会直接进入老年代，</p><p>但由于<code>老年代有碎片或者剩余空间不足</code>导致没有足够空间存储晋升对象，就会产生<code>promotion failed</code>。</p><blockquote><p><code>promotion failed</code>会导致<code>GC降级为SerialGC（Old）</code>。</p></blockquote><p><strong><em>解决方法：</em></strong></p><p>① 增大Survivor大小；</p><blockquote><p><code>内存整理</code>属于耗时操作，会造成<code>STW</code>。</p></blockquote><p>② 设置老年代的<code>内存碎片整理</code>功能以及合理的<code>整理周期</code>。</p><hr><p><code>CMS GC</code>时，如果由于某种原因，业务线程直接在老年代内分配对象，但老年代没有足够的空间，就会产生<code>concurrent mode failure</code>。</p><blockquote><p>同样，<code>concurrent mode failure</code>会导致<code>GC降级为SerialGC（Old）</code>。</p></blockquote><p><strong><em>解决方法：</em></strong></p><p>① <code>增大老年代大小</code>，避免老年代的内存不足；</p><p>② 设置<code>老年代的合理回收阈值</code>，尽早释放内存空间，保证老年代的剩余空间大小；</p><p><strong>Young GC晋升的平均大小大于老年代的剩余空间</strong></p><p>当<code>老年代的内存空间存在内存不足的风险</code>时，会触发FullGC，如果频繁出现此类情况，需要<code>关注晋升对象大小</code>以及是<code>否存在内存泄露</code>的情况。</p><p><strong>主动触发Full GC（System.gc）</strong></p><p>应用通过调用<code>System.gc()</code>来触发<code>FullGC</code>。</p><h3 id="配置调优"><a href="#配置调优" class="headerlink" title="配置调优"></a>配置调优</h3><h4 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h4><p><strong>-Xms &amp; -Xmx</strong></p><p><code>-Xms</code>： 初始堆大小。</p><p><code>-Xmx</code>： 最大堆大小。</p><p>一般情况下设置为相同值，避免内存扩展。</p><p><strong>-Xmn</strong></p><p><code>-Xmn</code>： 新生代大小。</p><p>Sun官方推荐配置为<code>整个堆的3/8</code>，但是不同的业务场景应该不同。</p><blockquote><p><code>对于Web应用3/8设置并不合理</code>，原因在于：<br>每个请求的生命周期较小，尤其对于高并发的场景下，大量的并发会导致新生代快速填满；<br>由于新生代内存不足，请求对象直接进入老年代，这部分对象并不会被MinorGC清理，从而造成内存空间的浪费。</p></blockquote><p>① 增大Eden增大触发间隔：</p><ul><li>[Eden <em> 2] 会影响 [Minor GC间隔 </em> 2]:</li><li>内存空间增大一倍，空间被占满的时间也会同步增大一倍。</li></ul><p>② 增大Eden对单次MinorGC时间的影响不大：</p><ul><li>[Eden * 2] 会增加新生代扫描与复制的时间；</li><li>扫描时间占比很小（并发扫描），对MinorGC影响不大；</li></ul><blockquote><p>复制是一个耗时的操作，但Eden区由于对象的生命周期较小，需要复制的对象也不会增加太多。</p></blockquote><ul><li>由于堆中短期对象很多，不需要额外复制一倍的空间；</li></ul><blockquote><p>因此，<code>增加Eden区大小可以提高新生代内存回收（MinorGC）的效率</code>。</p></blockquote><p><strong>-XX:MetaspaceSize &amp; -XX:MaxMetaspaceSize</strong></p><p>该用于设置元空间的大小，存在<code>内存不足</code>与<code>自动扩容</code>的情况，可能造成<code>MajorGC</code>。</p><p>64位JVM默认20M，最大值为宿主机内存大小。</p><h4 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h4><p><strong>-CMSScavengeBeforeRemark</strong></p><p>该配置时用来保证<code>Remark前强制进行一次MinorGC</code>，从而<code>减少Remark的时间</code>。</p><blockquote><p>考虑到新生代对象的生命周期很短，在<code>触发CMS之前强制JVM执行一次Minor GC</code>，清理掉无效的对象，<code>避免大范围的Remark</code>。</p></blockquote><p><strong>-XX:UseCMSCompactAtFullCollection  &amp; -XX:CMSFullGCBeforeCompaction</strong></p><p>该配置是用于解决<code>promotion failed</code>，</p><p>分别为<code>开启开启CMS GC的内存整理功能</code>和<code>设置CMS GC的内存整理频次</code>，</p><p>从而减少内存碎片造成的内存不足。</p><p><strong>-XX:CMSInitiatingOccupancyFraction &amp; -XX:+UseCMSInitiatingOccupancyOnly</strong></p><p>该配置是用于解决<code>cocurrent mode failed</code>，</p><p>分别为<code>设定CMS在对内存占用率达到X%的时候开始GC</code>和<code>设置JVM回收阈值（不基于运行时收集的数据来启动CMS垃圾收集周期）</code>，</p><p>从而避免垃圾回收不及时造成的内存不足。</p><h4 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h4><p><strong>-XX:NewRatio</strong></p><p>该配置是用来<code>设置新生代与老年代的比例</code>（默认2）。</p><p>调整新生代的大小可避免大量短生命周期对象进入老年代。</p><p><strong>-XX:MaxGCPauseMillis=n</strong></p><p>该配置是用来<code>设置最大GC停顿时间的目标</code>，主要是为了<code>降低STW对应用的影响</code>。</p><p>虽然设置了最大GC停顿时间，但这只是JVM自动回收优化的目标，不保证每次都会低于该配置的值。</p><p><strong>-XX:G1ReservePercent</strong></p><p>该配置是用来<code>设置堆内存保留空间的大小</code>，用以<code>降低Eden晋升失败</code>的可能性。</p><p>当对内存空间大小达到堆内存预留值会触发MixedGC。</p><p><strong>-XX:G1HeapRegionSize</strong></p><p>该配置是用来<code>设置堆Region的大小</code>，默认1~32。</p><p>在特殊的业务场景下可能存在小生命周期的大对象的产生，可以通过此设置<code>优化Region大小解决大对象直接进入老年代的问题</code>。</p><p><a href="https://tech.meituan.com/2017/12/29/jvm-optimize.html" target="_blank" rel="noopener">美团的案例</a></p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://tech.meituan.com/2017/12/29/jvm-optimize.html" target="_blank" rel="noopener">美团的案例</a><br><a href="https://www.dynatrace.com/resources/ebooks/javabook/how-garbage-collection-works/" target="_blank" rel="noopener">https://www.dynatrace.com/resources/ebooks/javabook/how-garbage-collection-works/</a><br><a href="https://hllvm-group.iteye.com/group/topic/44381#post-272188" target="_blank" rel="noopener">https://hllvm-group.iteye.com/group/topic/44381#post-272188</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录Java GC调优的相关问题。&lt;/p&gt;
    
    </summary>
    
      <category term="编程语言" scheme="http://simyy.cn/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="计算机原理" scheme="http://simyy.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/"/>
    
      <category term="编程语言" scheme="http://simyy.cn/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Java" scheme="http://simyy.cn/tags/Java/"/>
    
      <category term="垃圾回收" scheme="http://simyy.cn/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    
      <category term="调优" scheme="http://simyy.cn/tags/%E8%B0%83%E4%BC%98/"/>
    
  </entry>
  
  <entry>
    <title>JVM在64位系统上的指针压缩</title>
    <link href="http://simyy.cn/2020/05/14/java-64bit-jvm-compressed-pointer/"/>
    <id>http://simyy.cn/2020/05/14/java-64bit-jvm-compressed-pointer/</id>
    <published>2020-05-14T00:19:23.000Z</published>
    <updated>2020-05-14T02:30:25.516Z</updated>
    
    <content type="html"><![CDATA[<p>记录下JVM在64位系统上的指针压缩。</p><a id="more"></a><p><code>寻址能力不同</code>是32位与64位操作系统的不同之处。</p><p><code>32位</code>操作系统最大支持<code>4G内存（2^32）</code>，而<code>64位</code>操作系理论上最大支持<code>16384PB（2^64）</code>。</p><p><strong>指针占用字节的不同：</strong></p><ul><li>64位JVM占用8个字节</li><li>32位JVM占用4个字节</li></ul><p>同样的指针加载，64位JVM会占用更多的内存，也就是所谓的<code>&quot;64位JVM是32位JVM内存消耗的1.5位&quot;</code>。</p><p><strong>CompressedOops与UseCompressedClassPointers</strong></p><p><code>CompressedOops与UseCompressedClassPointers</code>是用来压缩空间的，用于解决JVM在32位与64位操作系统上内存占用问题。</p><p><code>CompressedOops</code>是指开启普通对象指针的压缩（Ordinary Object Pointer），用于提高堆的使用效率。</p><p><code>UseCompressedClassPointers</code>是指开启类指针压缩。</p><p><code>堆内存在&quot;4G~32G&quot;</code>的范围内，可使用指针压缩技术来提高堆内存的使用效率。</p><hr><p><strong>举例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123; <span class="keyword">int</span> a; &#125;</span><br><span class="line"></span><br><span class="line">`A a = <span class="keyword">new</span> A()`,</span><br></pre></td></tr></table></figure><blockquote><p>HotSpot的对齐方式为<code>8字节对齐</code>:</p><p>对象内存 = 对象头 + 实例数据 + padding，</p><p>其中 0 &lt;= padding &lt; 8。</p></blockquote><p>64位系统的JVM默认（未开启指针压缩）情况下，<code>指针a（引用）</code>占用8个字节，<code>对应的对象</code>占用24个字节：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">24(对象内存, 8字节对齐) = 16（对象头） + 4（int a）+ 4 (padding 补位对齐)</span><br></pre></td></tr></table></figure><p>64位系统的JVM默认（开启指针压缩）情况下，<code>指针a（引用）</code>占用4个字节，<code>对应的对象</code>占用16个字节：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">16(对象内存, 8字节对齐) = 12（对象头） + 4（int a）+ 0 (padding 补位对齐)</span><br></pre></td></tr></table></figure><hr><p><code>CompressedOops</code>与<code>UseCompressedClassPointers</code>必须同时使用（默认开启），否则无法生效。</p><p>Java8默认开启了这个配置，在没有配置<code>MetaspaceSize</code>的情况下，会自动申请<code>1G</code>大小的<code>CompressedClassSpaceSize</code>。</p><blockquote><p><code>MetaSpace</code>用来存储<code>klass（JVM中class的运行时数据结构）</code>的。</p></blockquote><p>无论如何配置，<code>CompressedClassSpaceSize</code>总是小于<code>MetaspaceSize（默认为宿主机的最大内存）</code>。</p><p>开启命令如下，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseCompressedClassPointers</span><br><span class="line">-XX:+UseCompressedOops</span><br><span class="line">-XX:CompressedClassSpaceSize=128m</span><br></pre></td></tr></table></figure><p>但一般我们只需要设置好MetaSpace，如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:MetaspaceSize=128m</span><br><span class="line">-XX:MaxMetaspaceSize=128m</span><br></pre></td></tr></table></figure><p>JVM会默认开启指针压缩，并且自动配置<code>CompressedClassSpaceSize</code>的大小。</p><p><strong>非堆内存划分</strong></p><p><code>CodeCache</code>：用于存储经过<code>JIT编译优化后的代码</code>。</p><p><code>JIT编译器（即时编译器）</code>生成<code>Hot Spot Code（热点代码）</code>，从而提高执行效率。</p><p><code>MetaSpace</code>：用于存储<code>Class在JVM中的数据结构klass</code>，包含类的所有元数据数据（方法、字节码、常量池等）。</p><p><code>CompressedClassSpace</code>：是分配在<code>MetaSpace</code>中，用于指令压缩，只包含类的部分元数据（InstansKlass/ArrayKlass等）。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录下JVM在64位系统上的指针压缩。&lt;/p&gt;
    
    </summary>
    
      <category term="编程语言" scheme="http://simyy.cn/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="编程语言" scheme="http://simyy.cn/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Java" scheme="http://simyy.cn/tags/Java/"/>
    
      <category term="JVM" scheme="http://simyy.cn/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>再谈事务与分布式事务</title>
    <link href="http://simyy.cn/2020/05/08/distributed-transaction-sequel/"/>
    <id>http://simyy.cn/2020/05/08/distributed-transaction-sequel/</id>
    <published>2020-05-08T14:25:00.000Z</published>
    <updated>2020-05-12T07:25:20.303Z</updated>
    
    <content type="html"><![CDATA[<p>时隔两年，再从新学习一下事务以及分布式事务。</p><a id="more"></a><h4 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h4><p><strong>什么是事务?</strong></p><p>事务是<code>恢复和并发控制</code>的基本单位。</p><h5 id="事务的ACID特性"><a href="#事务的ACID特性" class="headerlink" title="事务的ACID特性"></a>事务的ACID特性</h5><ul><li><code>Atomic（原子性）</code>：事务内操作要么全成功要么全失败；</li><li><code>Consistent（一致性）</code>：事务完成后所有数据的状态都是一致的（均发生变更）；</li><li><code>Isolation（隔离性）</code>：事务之间互不影响；</li><li><code>Duration（持久性）</code>：事务的修改被持久化保存。</li></ul><p><strong>原子性</strong></p><blockquote><p>原子是化学中不可再分的最小单位。</p></blockquote><p>事务中的原子性可以理解为事务操作的不可拆分，</p><p>也就是说，同一个事务内部的所有操作不可拆分，要么全部执行成功，要么全部执行失败。</p><p>原子性的另外一层含义是<code>事务内的操作可回滚</code>，也就是存在部分执行失败的情况下恢复数据。</p><p><strong>隔离性</strong></p><p>隔离是用于解决事务并发的资源竞争问题。</p><p><code>锁</code>是用来解决隔离的唯一手段，可分为<code>悲观锁</code>和<code>乐观锁</code>。</p><ul><li>悲观锁：对事务对象加锁，实现顺序执行（Serializable隔离级别属于这种情况）；</li><li>乐观锁：基于多版本冲突检测，实现并发执行；</li></ul><p>多版本数据隔离的实现又可划分：<code>基于物理存储的实现</code>与<code>基于内存存储的实现</code>，</p><ul><li>基于物理存储：多版本数据更新写入磁盘（持久化），支持异常恢复；</li><li>基于内存存储：多版本数据更新仅存储在内存，性能好，异常无法恢复。</li></ul><blockquote><p><code>Undo Log</code>是MySQL事务隔离性的关键。</p></blockquote><p><strong>持久化</strong></p><p>持久化是数据一致性的最终保证。</p><p>数据库的持久化存在两层含义：<code>数据落盘</code>与<code>数据备份</code>。</p><ul><li>数据落盘：事务变更写入磁盘存储；</li><li>数据备份：事务变更不仅进入本地磁盘存储，同时同步到数据库的副本；</li></ul><p>数据落盘一般会包含两个阶段：<code>写入缓存</code>与<code>写入磁盘</code>，</p><blockquote><p>缓存的使用可以带来性能的提高，但也会带来数据丢失的风险。</p></blockquote><p><strong>一致性</strong></p><p>没有解决事务操作的原子性，就无法实现事务数据变更的一致性；</p><p>没有解决事务并发执行的问题，就无法实现事务操作的隔离，也无法实现事务数据变更的一致性；</p><p>没有合理的持久化策略，即使保证了原子性，但没有写入磁盘或无法从异常中恢复，也无法实现事务数据变更的一致性；</p><p>因此，<code>原子性</code>、<code>隔离性</code>与<code>持久化</code>是实现一致性的基础。</p><h5 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h5><ul><li><code>脏读</code>：读取到未提交的数据。</li><li><code>不可重复度</code>：数据的修改。</li><li><code>幻读</code>：数据的增加。</li></ul><p>数据库事务的<code>隔离级别</code>分为4种，由低到高分别为</p><ul><li><code>Read uncommitted（读未提交）</code>，存在问题：<code>脏读、不可重复读、幻读</code>；</li><li><code>Read committed（读已提交）</code> ，存在问题：<code>不可重复读、幻读</code>；</li><li><code>Repeatable read（可重复读）</code>，存在问题：<code>幻读</code>；</li><li><code>Serializable（序列化）</code></li></ul><blockquote><p>在<code>Read committed</code>与<code>Repeatable read</code>隔离级别下，MySQL的InnoDB使用MVCC来解决<code>不可重复读</code>、<code>幻读</code>的问题。</p></blockquote><h5 id="事务的分类"><a href="#事务的分类" class="headerlink" title="事务的分类"></a>事务的分类</h5><p>事务按照<code>一致性的强弱</code>可以划分为：<code>传统事务</code>和<code>柔性事务</code>，</p><p><code>柔性事务</code>允许系统存在中间状态，这个中间状态又不会影响系统整体可用性。</p><p><code>柔性事务</code>的实现方式包括：<code>记录日志+补偿</code>、<code>消息（多次重试，需要幂等处理）</code>、<code>CAS（乐观锁）不断重试</code>。</p><h4 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h4><p><code>分布式事务</code>是指事务的参与者位于分布式系统的不同节点。</p><p>分布式事务主要的关注点在于<code>一致性（分布式系统中不同节点的状态同步）</code>。</p><p><code>原子性</code>、<code>隔离性</code>、<code>持久性</code>是由分布式系统中不同的事务参与节点来保证。</p><p><strong><em>实现方式有</em></strong>：</p><ul><li><code>2PC（两阶段提交）</code></li><li><code>3PC（三阶段提交）</code></li><li><code>TCC（Try Confirm Cancel、补偿事务）</code></li><li><code>本地消息表（BASE）</code></li><li><code>事务消息（BASE）</code>。</li></ul><h5 id="XA"><a href="#XA" class="headerlink" title="XA"></a>XA</h5><p><code>XA</code>是由X/Open组织提出的<code>分布式事务规范</code>，是实现<code>2PC</code>与<code>3PC</code>的基础。</p><p><strong><em>组成</em></strong>：</p><ul><li><code>事务管理器（TM）</code>：分布式事务的协调者，负责各个资源管理器的本地事务的提交与回滚；</li><li><code>资源管理器（RM）</code>：分布式事务的参与者，管理参与者本地事务资源。</li></ul><h5 id="2PC"><a href="#2PC" class="headerlink" title="2PC"></a>2PC</h5><p><code>2PC（两阶段提交）</code>是通过<code>事务执行</code>与<code>事务提交</code>两个阶段来实现分布式事务。</p><p><code>2PC</code>中必然存在一个<code>协调者</code>，用于协调分布式系统中<code>事务的发起</code>与<code>事务提交/回滚</code>。</p><p><img src="/images/distributed_transaction_sequel_1.png" alt="2PC"></p><p><strong><em>步骤如下：</em></strong></p><ul><li><strong>阶段1（PreCommit）</strong>：<code>参与者</code>执行事务操作，并返回执行结果到<code>协调者</code>；</li><li><strong>阶段2（doCommit ）</strong>：<code>协调者</code>等待事务执行结果，如果结果均成功则<code>提交事务</code>，否则<code>回滚事务</code>（存在失败结果）。</li></ul><h6 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h6><p><strong>同步阻塞 &amp; 单点问题*</strong></p><p><code>在进入阶段2前协调者发生异常</code>，没有其他节点可以代替协调者的工作，从而造成协调者的<code>单点问题</code>，</p><p>与此同时，事务参与者由于没有协调者的下一步通知，将会一直阻塞直到协调者的恢复，从而形成<code>同步阻塞问题</code>。</p><p><strong>数据不一致</strong></p><p><code>阶段2中存在部分分布式节点执行失败</code>的情况，将会导致不同事务参与者数据不一致的情况。</p><h5 id="3PC"><a href="#3PC" class="headerlink" title="3PC"></a>3PC</h5><p><code>3PC（三阶段提交）</code>是通过<code>事务请求</code>、<code>事务执行</code>与<code>事务提交</code>三个阶段来实现分布式事务。</p><p><img src="/images/distributed_transaction_sequel_2.png" alt="3PC"></p><p><strong><em>步骤如下：</em></strong></p><ul><li><strong>阶段1（CanCommit）</strong>：<code>询问参与者</code>是否可以事务执行，主要用于检查参与者是否异常（宕机、通信异常）；</li><li><strong>阶段2（PreCommit）</strong>：同<code>2PC</code>，但<code>协调者</code>增加<code>等待超时机制</code>，如果存在超时的参与者则<code>默认参与者执行失败</code>（触发回滚）；</li><li><strong>阶段3（doCommit ）</strong>：同<code>2PC</code>，但<code>参与者</code>增加<code>等待超时机制</code>，如果存在超时的协调者则<code>默认协调者发出提交事务</code>。</li></ul><p><strong>与<code>2PC</code>不同之处</strong></p><ul><li><code>PreCommit</code>拆分为<code>CanCommit</code>和<code>PreCommit</code>，增加一步可达性判断；</li><li><code>协调者</code>与<code>参与者</code>均增加<code>等待超时机制</code>，实现事务的回滚和自动提交，解决了<code>同步阻塞</code>与<code>单点问题</code>。</li></ul><h6 id="存在的问题-1"><a href="#存在的问题-1" class="headerlink" title="存在的问题"></a>存在的问题</h6><p><strong>数据不一致</strong></p><p>在<code>阶段3</code>中，协调者在下发<code>回滚命令</code>的过程中出现异常，部分<code>参与者发生等待超时</code>，参与者会自动提交（与协调者命令不同）。</p><h5 id="BASE"><a href="#BASE" class="headerlink" title="BASE"></a>BASE</h5><blockquote><p><code>BASE</code>允许系统出现短暂性不可用或不一致的状态，只要能够在一定时间范围内最终达到可用或者一致状态即可。</p></blockquote><p><code>BASE</code>是由<code>基本可用（Base Availability）</code>、<code>软状态（Soft-state）</code>和<code>最终一致性（Eventual Consistency</code>。</p><h5 id="TCC"><a href="#TCC" class="headerlink" title="TCC"></a>TCC</h5><p><code>TCC（Try Confirm Cancel）</code>又称<code>补偿事务</code>，是<code>2PC</code>的一种实现，</p><p>其核心思想是：<code>针对每个操作都要注册一个与其对应的确认和补偿操作</code>。</p><p><img src="/images/distributed_transaction_sequel_3.png" alt="TCC"></p><p><strong><em>步骤如下：</em></strong></p><ul><li><strong>Try</strong>： 业务检查（保证事务的一致性）、资源预留（保证事务的隔离性）；</li><li><strong>Confirm</strong>： 执行操作，执行真正的业务逻辑；</li><li><strong>Cancel</strong>： 预留资源取消。</li></ul><p><strong>TCC与XA的不同之处</strong></p><ul><li><code>锁粒度不同</code>：资源锁定具体由业务决定；</li><li><code>最终一致性</code>：通过<code>Confirm</code>与<code>Cancel</code>实现最终的一致性；</li><li><code>业务耦合严重</code>：<code>Confirm</code>、<code>Cancel</code>操作与具体业务强关联；</li></ul><p>由于<code>Confirm</code>操作属于事务提交，因此，<code>TCC</code>中一般<code>不提供回滚操作</code>。</p><p><code>Cancel</code>属于锁定资源的释放，例如，订单预占库存的释放。</p><h5 id="本地消息表"><a href="#本地消息表" class="headerlink" title="本地消息表"></a>本地消息表</h5><p><code>本地消息表</code>是属于<code>BASE</code>理论的一种分布式事务的实现。</p><p><code>本地消息表</code>的主要思想是将<code>分布式事务拆分成本地事务</code>进行处理，分布式之间的通过本地的<code>事务消息表</code>来异步通信来实现。</p><p><strong>特点</strong></p><ul><li><code>最终一致性</code>：通过保证<code>事务消息的写入</code>与<code>事务消息的投递消费</code>来实现；</li><li><code>业务幂等</code>：由于存在异常重试机制来保证事务的一致性，因此业务必须保证幂等；</li><li><code>异步回滚</code>：业务需要支持类似<code>TCC的Cancel</code>操作，用于处理接收到的事务回滚消息；</li><li><code>业务耦合严重</code>：与TCC相同的业务耦合情况。</li></ul><h5 id="事务消息"><a href="#事务消息" class="headerlink" title="事务消息"></a>事务消息</h5><p><code>事务消息</code>是<code>本地消息表</code>的一种实现，解决了业务耦合严重的问题。</p><p><code>事务消息</code>是对本地消息表的封装，构建一套完整的事务消息中间件，保证<code>消息的写入与消费</code>来实现分布式事务。</p><p><img src="/images/distributed_transaction_sequel_4.png" alt="事务消息"></p><p>例如，<code>RocketMQ</code>实现了事务消息，可用于分布式事务。</p><p><strong>特点</strong></p><ul><li><code>最终一致性</code>：同<code>本地消息表</code>；</li><li><code>业务耦合小</code>：事务消息数据独立存储于中间件中；</li></ul><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>首先，分布式事务产生的原因在于<code>应用拆分（微服务）</code>。</p><p>原本本地资源管理器就可以实现的事务，被拆分到多个应用，此时为了保证位于多个应用的事务操作就会想到使用分布式事务。</p><blockquote><p>但是，真的需要分布式事务么？</p></blockquote><p>分布式事务不仅会造成资源锁定，事务操作链路长，排查问题复杂。</p><p>应用的拆分往往都是基于业务（领域）边界的拆分，服务之间的状态也没必要真的实现强一致性。</p><p><code>最终一致性</code>往往是业务架构设计中需要考虑的，因此，业务中常用的分布式事务是类似于<code>RocketMQ</code>这种中间件来实现。</p><p>按照领域拆分不同的领域事件消息，通过可靠的消息写入与消费来实现业务的最终一致性。</p><h4 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h4><p><a href="https://www.zhihu.com/question/3027272" target="_blank" rel="noopener">数据库事务原子性、一致性是怎样实现的？</a>8</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;时隔两年，再从新学习一下事务以及分布式事务。&lt;/p&gt;
    
    </summary>
    
      <category term="架构" scheme="http://simyy.cn/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="架构" scheme="http://simyy.cn/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="分布式" scheme="http://simyy.cn/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="事务" scheme="http://simyy.cn/tags/%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>NoSQL分类</title>
    <link href="http://simyy.cn/2020/05/07/nosql-classify/"/>
    <id>http://simyy.cn/2020/05/07/nosql-classify/</id>
    <published>2020-05-07T15:09:09.000Z</published>
    <updated>2020-05-07T15:36:40.699Z</updated>
    
    <content type="html"><![CDATA[<p>NoSQL分类简介。</p><a id="more"></a><p>NoSQL数据库可分为：<code>键值存储</code>、<code>列存储</code>、<code>文档存储</code>与<code>图存储</code>。</p><p><img src="/images/nosql_classify_01.png" alt=""></p><h5 id="键值存储"><a href="#键值存储" class="headerlink" title="键值存储"></a>键值存储</h5><p><code>键值存储</code>是由KV哈希表来实现，例如，<code>Redis</code>、<code>Memcached</code>。</p><p><strong>优点</strong>：查找速度快，查找数据时间复杂度O(1)。</p><p><strong>缺点</strong>：数据无结构化，通常只被当作字符串或者二进制数据，数据无序。</p><p><code>Redis</code>支持了特殊的数据结构。</p><h5 id="列存储"><a href="#列存储" class="headerlink" title="列存储"></a>列存储</h5><p><code>列存储</code>是按列存储数据的，例如，<code>HBase</code>/<code>Cassandra</code>。</p><p><strong>优点</strong>：针对列的查询性能好；方便存储结构化和半结构化数据，方便做数据压缩与按列扩展（横向扩展）。</p><p><strong>缺点</strong>：功能相对受限。</p><h5 id="文档存储"><a href="#文档存储" class="headerlink" title="文档存储"></a>文档存储</h5><p><code>文档存储</code>是基于键值对的扩展，例如，<code>MongoDB</code>/<code>CouchDB</code>。</p><p><strong>优点</strong>：数据结构要求不严格；表结构可变；不需要预先定义表结构。</p><!-- **缺点**：查询性能不高，缺乏统一的查询语法。 --><h5 id="图存储"><a href="#图存储" class="headerlink" title="图存储"></a>图存储</h5><p><code>图存储</code>是基于节点和关系组成的图，例如，<code>Neo4j</code>。</p><p><strong>优点</strong>：利用图结构相关算法(最短路径、节点度关系查找等)。</p><p><strong>缺点</strong>：可能需要对整个图做计算，不利于图数据分布存储。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;NoSQL分类简介。&lt;/p&gt;
    
    </summary>
    
      <category term="中间件" scheme="http://simyy.cn/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
      <category term="数据库" scheme="http://simyy.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="中间件" scheme="http://simyy.cn/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
      <category term="NoSQL" scheme="http://simyy.cn/tags/NoSQL/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot原理分析</title>
    <link href="http://simyy.cn/2020/04/18/java-springboot/"/>
    <id>http://simyy.cn/2020/04/18/java-springboot/</id>
    <published>2020-04-18T05:03:22.000Z</published>
    <updated>2020-04-23T08:01:28.843Z</updated>
    
    <content type="html"><![CDATA[<p>本文简单分析下SpringBoot的原理设计。 </p><a id="more"></a><h3 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h3><p><code>SpringBoot</code>是为了简化构建应用的复杂度。</p><blockquote><p>SpringBoot到底解决了什么问题？</p></blockquote><hr><p><strong>在SpringBoot出现之前</strong></p><p>应用构建是建立在大量的<code>XML配置</code>之上，功能模块的依赖全部由开发人员自行整合。</p><p>整合的过程复杂不说，还会存在不同的整合方式，稍有不慎就会出现各种奇奇怪怪的问题。</p><p><strong>在SpringBoot出现之后</strong></p><p>应用构建是建立在大量的<code>starter</code>之上，功能模块的依赖通过<code>maven</code>引入后自动整合。</p><hr><h4 id="约定大于配置"><a href="#约定大于配置" class="headerlink" title="约定大于配置"></a>约定大于配置</h4><p><code>约定大于配置</code>是实现SpringBoot的基本原则。</p><p>SpringBoot整合了一套<code>默认配置</code>，不需要开发者手动配置<code>XML</code>，只有当默认配置不满足的情况下才需要手动修改默认配置。</p><h4 id="四大核心"><a href="#四大核心" class="headerlink" title="四大核心"></a>四大核心</h4><p><code>四大核心</code>包括：<code>auto-configuration（自动配置）</code>、<code>starters（起步依赖）</code>、<code>cli</code>和<code>actuator</code>。</p><p><strong>auto-configuration</strong></p><p><code>auto-configuration</code>是SpringBoot自动配置的核心，提供模块自动装配功能。</p><p>常见的<code>Enable**</code>注解属于自动配置的一部分。</p><p><strong>starters</strong></p><p><code>starters</code>是SpringBoot功能整合的关键，按照约定大于配置的原则实现。</p><p>例如，<code>spring-boot-starter-web</code>是<code>Spring MVC</code>的一种整合，不需要再去配置<code>servlet.xml</code>及<code>web.xml</code>，仅需要通过改变配置参数即可满足需求。</p><p><strong>cli</strong></p><p><code>cli</code>是快速创建原型项目的命令行工具，支持项目创建、编译打包等功能。</p><p><code>cli</code>还支持运行<code>Groovy脚本</code>。</p><p><strong>actuator</strong></p><p><code>actuator</code>是用于应用的监控与管理的工具，可以查看应用配置及自身环境属性等信息。</p><p><code>actuator</code>提供<code>REST API</code>来查询应用运行时的内部状态。</p><p><code>actuator</code>虽然提供便利，但也存在一定的安全风险，因此一般与<code>spring-boot-start-security</code>一起使用。</p><h4 id="自动配置的原理"><a href="#自动配置的原理" class="headerlink" title="自动配置的原理"></a>自动配置的原理</h4><blockquote><p><code>auto-configuration（自动配置）</code>是SpringBoot自动配置的核心，包括所有<code>Enable**</code>注解。</p></blockquote><p>首先，<code>starters</code>是SpringBoot模块整合的关键，通过简单的<code>maven</code>引入就可以实现模块的整合。</p><blockquote><p>那么<code>starter</code>是如何被引入的？</p></blockquote><ol><li><p>SpringBoot启动后会去依赖的<code>starter</code>包中查找<code>resources/META-INF/spring.factories</code>文件；</p></li><li><p>按照<code>spring.factories</code>来加载<code>AutoConfiture</code>配置类；</p></li><li><p>扫描<code>@Configuration</code>注解将配置注入到<code>Context</code>容器中。</p></li></ol><p>其中，<code>spring.factories</code>就是一种约定，SpringBoot按照这种约定来是先模块的自动加载配置。</p><h5 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h5><h6 id="启动注解的扫描过程"><a href="#启动注解的扫描过程" class="headerlink" title="启动注解的扫描过程"></a>启动注解的扫描过程</h6><p><code>@SpringBootApplication</code>是SpringBoot项目的启动注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(excludeFilters = &#123;</span><br><span class="line">        <span class="meta">@Filter</span>(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span><br><span class="line">        <span class="meta">@Filter</span>(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<code>@EnableAutoConfiguration</code>是启动自动配置的注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import</span>(AutoConfigurationImportSelector.class)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，涉及到<code>@Import</code>及<code>ImportSelector</code>两个功能点。</p><h6 id="Import-与-ImportSelector"><a href="#Import-与-ImportSelector" class="headerlink" title="@Import 与 ImportSelector"></a>@Import 与 ImportSelector</h6><p><code>@Import</code>注解用于将指定的实例注入到IOC容器中，等同于<code>XML中的import</code>。</p><p><code>@Import</code>支持三种注入方式：<code>直接注入</code>、<code>条件注入</code>和<code>动态注入</code>。</p><p><strong>直接注入</strong></p><p>通过直接引入目标配置<code>@Import({XXXAutoConfig.class})</code>来实现配置加载。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Import</span>(&#123;XXXAutoConfig.class&#125;)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnabletXXX &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>条件注入</strong></p><p>通过实现<code>ImportSelector</code>来选择注入的配置信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Import</span>(&#123;XXXEnableSelector.class&#125;)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnabletXXX &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XXXEnableSelector</span> <span class="keyword">implements</span> <span class="title">ImportSelector</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String[]&#123;XXXAutoConfigConfig.class.getName()&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>动态注入</strong></p><p>通过实现<code>ImportBeanDefinitionRegistrar</code>来实现动态注入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Import</span>(&#123;DynamicConfigEnableRegistrar.class&#125;)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnabletXXX &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要注入的注解</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE, ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> DynamicConfig &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现ImportBeanDefinitionRegistrar来实现动态扫描注册</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicConfigEnableRegistrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span>, <span class="title">ResourceLoaderAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ResourceLoader resourceLoader;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 注册扫码器</span></span><br><span class="line">        DynamicRegisterScanner scanner = <span class="keyword">new</span> DynamicRegisterScanner(registry, <span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">// 设置classloader</span></span><br><span class="line">        scanner.setResourceLoader(resourceLoader);</span><br><span class="line">        scanner.registerFilters();</span><br><span class="line">        <span class="comment">// 设置待扫描注解</span></span><br><span class="line">        scanner.addIncludeFilter(<span class="keyword">new</span> AnnotationTypeFilter(DynamicConfig.class));</span><br><span class="line">        <span class="comment">// 设置待扫描路径</span></span><br><span class="line">        scanner.doScan(<span class="string">"x.y.z.package"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setResourceLoader</span><span class="params">(ResourceLoader resourceLoader)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.resourceLoader = resourceLoader;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>mybatis的mapper扫描</code>就是通过<code>动态注入</code>的方式实现。</p><h6 id="扫描并加载配置"><a href="#扫描并加载配置" class="headerlink" title="扫描并加载配置"></a>扫描并加载配置</h6><p>SpringBoot通过实现<code>ImportSelector</code>接口来扫描并加载配置。</p><ul><li><code>getCandidateConfigurations</code>从<code>META-INF/spring.factories</code>获取待配置的类；</li><li><code>getAutoConfigurationEntry</code>去重并获取已排除的配置类，并出发<code>ImportEvent</code>事件；</li><li>重写<code>selectImports</code>实现配置类的导入。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AutoConfigurationImportSelector</span> ... </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 获取自动配置</span></span><br><span class="line">        AutoConfigurationEntry autoConfigurationEntry = getAutoConfigurationEntry(</span><br><span class="line">                autoConfigurationMetadata, annotationMetadata);</span><br><span class="line">        <span class="keyword">return</span> StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> AutoConfigurationEntry <span class="title">getAutoConfigurationEntry</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            AutoConfigurationMetadata autoConfigurationMetadata,</span></span></span><br><span class="line"><span class="function"><span class="params">            AnnotationMetadata annotationMetadata)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 获取候选配置</span></span><br><span class="line">        List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata,</span><br><span class="line">                attributes);</span><br><span class="line">        configurations = removeDuplicates(configurations);</span><br><span class="line">        Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes);</span><br><span class="line">        checkExcludedClasses(configurations, exclusions);</span><br><span class="line">        configurations.removeAll(exclusions);</span><br><span class="line">        configurations = filter(configurations, autoConfigurationMetadata);</span><br><span class="line">        fireAutoConfigurationImportEvents(configurations, exclusions);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AutoConfigurationEntry(configurations, exclusions);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> List&lt;String&gt; <span class="title">getCandidateConfigurations</span><span class="params">(AnnotationMetadata metadata,</span></span></span><br><span class="line"><span class="function"><span class="params">            AnnotationAttributes attributes)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 从META-INF/spring.factories获取自动配置的类</span></span><br><span class="line">        List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(</span><br><span class="line">                getSpringFactoriesLoaderFactoryClass(), getBeanClassLoader());</span><br><span class="line">        Assert.notEmpty(configurations,</span><br><span class="line">                <span class="string">"No auto configuration classes found in META-INF/spring.factories. If you "</span></span><br><span class="line">                        + <span class="string">"are using a custom packaging, make sure that file is correct."</span>);</span><br><span class="line">        <span class="keyword">return</span> configurations;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>META-INF/spring.factories</code>约定配置格式如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">  x.y.z.starter.StarterAutoConfiguration</span><br></pre></td></tr></table></figure><h4 id="条件注解"><a href="#条件注解" class="headerlink" title="条件注解"></a>条件注解</h4><p>SpringBoot提供了丰富的<code>条件注解</code>来解决依赖加载的问题。</p><hr><p>判断<code>Bean</code>是否注册到<code>IOC容器</code>中来确认是否触发当前逻辑，</p><ul><li><code>@ConditionalOnBean</code></li><li><code>@ConditionalOnMissingBean</code></li></ul><p>用于解决Bean的依赖问题，当存在某一个依赖模块时自动加载对应的依赖。</p><hr><p>判断<code>累加载器</code>中是否存在<code>Class类</code>来确认是否触发当前逻辑，</p><ul><li><code>@ConditionalOnClass</code></li><li><code>@ConditionalOnMissingClass</code></li></ul><hr><p>判断生存指定了<code>资源文件</code>来确认是否触发当前逻辑，</p><ul><li><code>@ConditionalOnResource</code></li></ul><p>可用于从远程拉取配置文件，实现应用的配置集中管理。</p><hr><p>此外，还包括<code>@ConditionalOnJava</code>、<code>ConditionalOnNotWebApplication</code>、<code>ConditionalOnWebApplication</code>等。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文简单分析下SpringBoot的原理设计。 &lt;/p&gt;
    
    </summary>
    
      <category term="编程语言" scheme="http://simyy.cn/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="编程语言" scheme="http://simyy.cn/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Java" scheme="http://simyy.cn/tags/Java/"/>
    
      <category term="Spring" scheme="http://simyy.cn/tags/Spring/"/>
    
      <category term="SpringBoot" scheme="http://simyy.cn/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>Java 表达式引擎分析</title>
    <link href="http://simyy.cn/2020/04/16/java-expression-plugin/"/>
    <id>http://simyy.cn/2020/04/16/java-expression-plugin/</id>
    <published>2020-04-16T13:26:33.000Z</published>
    <updated>2020-04-16T15:00:50.128Z</updated>
    
    <content type="html"><![CDATA[<p>本文将和介绍及分析表达式引擎。</p><a id="more"></a><h3 id="表达式引擎"><a href="#表达式引擎" class="headerlink" title="表达式引擎"></a>表达式引擎</h3><p><code>表达式引擎</code>是把字符串表达式转换为计算机可以理解运行的计算规则。</p><p><code>Groovy</code>就是最常见的基于JVM动态语言的表达式引擎之一。</p><p><code>表达式的引擎</code>是基于编程语言的基础之上<code>编译原理</code>的一种实现。</p><h4 id="常见功能"><a href="#常见功能" class="headerlink" title="常见功能"></a>常见功能</h4><p>表达式引擎常见的功能有<code>操作符</code>、<code>对象</code>、<code>条件语句</code>、<code>循环语句</code>、<code>函数</code>、<code>集合</code>、<code>异常</code>、<code>脚本</code>等。</p><p><img src="/images/java_expression_plugin_01.png" alt="java_expression_plugin_01.png"></p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p><strong>编译型与解释型</strong></p><p>计算机是不能理解高级语言的，更不能直接执行高级语言。</p><p>任何高级语言编写的程序若想被计算机运行，都必须将其转换成计算机语言（<code>机器码</code>）。</p><p><code>编译型</code>是将高级语言源代码<code>一次性编译</code>成可被该平台硬件执行的机器码。</p><p><code>解释型</code>不需要事先编译而直接将源代码<code>解释</code>成机器码并立即执行。</p><blockquote><p>与预编译相比，解释机器码并执行效率较低。</p></blockquote><p>在Java的表达式引擎中，<code>MVEL</code>支持普通的解释运行及编译运行。</p><p><strong>强类型与弱类型</strong></p><p><code>弱类型检查</code>不会对变量类型做任何假设，而是在运行时做类型推断及自动转化。</p><p><code>强类型检查</code>可以保证在编译时就确定变量类型从而才能生成高效和正确的代码。</p><hr><p>在Java的表达式引擎中，</p><p><code>FEL</code>属于强类型检查，它没有自己的类型系统，而是利用Java类型来实现；</p><p><code>QLExpress</code>和<code>Groovy</code>属于弱类型检查，在编译时不会对类型做任何检查，而是在运行期对其推断并转换。</p><hr><p><strong>表达式解析</strong></p><p>表达式可以分为<code>波兰式(前缀表达式)</code>、<code>逆波兰式(后缀表达式)</code>和<code>中缀表达式</code>。</p><p>其中，<code>波兰式</code>和<code>逆波兰式</code>更适合计算机来执行，具体可以<a href="https://blog.csdn.net/lovejay7/article/details/81584402" target="_blank" rel="noopener">参考</a>。</p><p>表达式会首先被解析为<code>语法树AST</code>（中缀表达式），但<code>中缀表达式</code>不适合计算机运算，因此，需要转换为<code>波兰式</code>或<code>逆波兰式</code>。</p><hr><p><strong>Java表达式引擎原理</strong></p><p>表达式引擎的基础是<code>编译原理</code>及<code>Java字节码</code>技术。</p><p>在编译原理中，需要实现<code>解释器</code>和<code>编译器</code>。</p><p>解释器包括<code>语法分析</code>、<code>词法分析</code>及<code>语义分析</code>，而解释器包括<code>中间代码</code>和<code>目标代码</code>。</p><p>Java中的规则引擎一般会把<code>表达式</code>生成<code>.class</code>字节码，并利用JVM加载到内存中来执行，从而达到编译的运行效率。</p><hr><p>目前，规则的引擎的实现大体分为两种：<code>利用Java类运行时动态编译技术</code> 和 <code>利用ASM字节码生成技术</code>。</p><p><strong>利用Java类运行时动态编译技术</strong></p><blockquote><p>核心接口： <code>javax.tools接口JavaCompiler</code>。</p></blockquote><ul><li>使用<code>antlr</code>解析把表达式成<code>AST</code>；</li><li>使用JDK工具(<code>javax.tools.JavaCompiler</code>)动态编译成<code>.class</code>文件；</li><li>利用<code>URLClassLoader</code>把<code>.class</code>文件放入JVM直接运行。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expression string -&gt; antlr -&gt; AST -&gt; comiple -&gt; java source template -&gt; java class -&gt; Expression</span><br></pre></td></tr></table></figure><p>具体可<a href="https://yq.aliyun.com/articles/85362?spm=a2c4e.11153940.0.0.883e6bafJUGsec" target="_blank" rel="noopener">参考</a>。</p><p><strong>利用ASM字节码生成技术</strong></p><blockquote><p>核心技术：<code>antlr语法解析器</code> 与 <code>ASM字节码生成技术</code>。</p></blockquote><ul><li>使用<code>antlr</code>解析把表达式成<code>AST</code>；</li><li>利用<code>AMS</code>把<code>AST</code>的节点重新编排成<code>.class</code>文件或者指令；</li><li>利用<code>URLClassLoader</code>把<code>.class</code>文件放入JVM直接运行。</li></ul><hr><h4 id="Java中的表达式引擎"><a href="#Java中的表达式引擎" class="headerlink" title="Java中的表达式引擎"></a>Java中的表达式引擎</h4><p>表达式引擎的对比介绍可<a href="https://zhuanlan.zhihu.com/p/33927344" target="_blank" rel="noopener">参考</a>。</p><p><strong>基础功能</strong></p><p><code>FEL</code>、<code>SimpleExpress</code>都是仅支持表达式的基础功能，依赖Java类型系统。</p><p>此外，还包括<code>JUEL</code>、<code>JSEL</code>。</p><p><strong>高级功能</strong></p><p><code>Aviator</code>有自己的类型系统，属于若类型检查。</p><p><code>QLExpress</code>是阿里开源的表达式引擎，同样属于若类型检查，强调功能扩展。</p><p><code>Groovy</code>兼容Java语法，同时支持强类型和若类型检查，支持更多的集合操作。</p><p><code>Groovy</code>是<code>Java</code>官方的脚本语言，更适合构建大型规则引擎。</p><hr><p>性能对比：</p><p>表达式：<br><code>foobar * 100 &lt; 200 || foobar &gt; 300 || (foobar &lt; 200 &amp;&amp; foobar + 5 &lt; 300)</code></p><p>循环次数：<br><code>100 * 10000</code></p><p>结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">jsel::exec  Run Time:   2164 ms</span><br><span class="line">jselCompiled::exec  Run Time:   28 ms</span><br><span class="line">mvel::exec  Run Time:   1881 ms</span><br><span class="line">mvelCompiled::exec  Run Time:   120 ms</span><br><span class="line">qlexpress::exec Run Time:   14471 ms</span><br><span class="line">qlexpressCompiled::exec Run Time:   113 ms</span><br><span class="line">juel::exec  Run Time:   159 ms</span><br><span class="line">groovy::exec    Run Time:   680 ms</span><br><span class="line">groovyCompiled::exec    Run Time:   45 ms</span><br><span class="line">aviator::exec   Run Time:   16736 ms</span><br><span class="line">aviatorCompiled::exec   Run Time:   43 ms</span><br></pre></td></tr></table></figure></p><hr><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p><code>流程编排</code>：通过动态脚本来管理流程调度，例如，基于微服务来动态搭建流程。</p><p><code>规则引擎</code>：利用动态表达式来实时修改配置，例如，营销规则配置、审核流条件判断。</p><p><code>脚本引擎</code>：利用动态脚本来实现在线编辑器。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将和介绍及分析表达式引擎。&lt;/p&gt;
    
    </summary>
    
      <category term="编程语言" scheme="http://simyy.cn/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="编程语言" scheme="http://simyy.cn/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Java" scheme="http://simyy.cn/tags/Java/"/>
    
      <category term="表达式引擎" scheme="http://simyy.cn/tags/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%BC%95%E6%93%8E/"/>
    
      <category term="规则引擎" scheme="http://simyy.cn/tags/%E8%A7%84%E5%88%99%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title>Spring AOP 失效的原因</title>
    <link href="http://simyy.cn/2020/04/02/java-spring-aop-ineffective/"/>
    <id>http://simyy.cn/2020/04/02/java-spring-aop-ineffective/</id>
    <published>2020-04-02T10:53:09.000Z</published>
    <updated>2020-04-03T05:54:31.768Z</updated>
    
    <content type="html"><![CDATA[<p>分析AOP在一定情况下会失效的原因。</p><a id="more"></a><h5 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h5><p><code>Spring</code>提供了事务注解<code>Transactional</code>，在一定的使用场景下会发生事务不生效的情况。</p><p><strong>注：</strong>下列场景中，<code>updateInDB</code>为数据库更新操作。</p><h6 id="场景1（事务生效）"><a href="#场景1（事务生效）" class="headerlink" title="场景1（事务生效）"></a>场景1（事务生效）</h6><p>一般的使用方式如下，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">updateA</span><span class="params">(A a)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Update A</span></span><br><span class="line">        updateInDB(a)</span><br><span class="line">        b = ...</span><br><span class="line">        <span class="comment">// Then update B</span></span><br><span class="line">        updateB(b)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">updateB</span><span class="params">(B b)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Update B</span></span><br><span class="line">        updateInDB(b)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ServiceTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Service service;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        A a = <span class="keyword">new</span> A(...);</span><br><span class="line">        service.updateA(a)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于<code>updateA</code>包含了<code>updateB</code>的操作，因此<code>updateB</code>与<code>updateA</code>会在一个事务中。</p><p>此时，<code>updateA</code>与<code>updateB</code>会同时生效或失效。</p><h6 id="场景2（事务失效）"><a href="#场景2（事务失效）" class="headerlink" title="场景2（事务失效）"></a>场景2（事务失效）</h6><p>考虑<code>内部调用</code>的情况如下，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">update</span><span class="params">(A a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> updateA(A)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">updateA</span><span class="params">(A a)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Update A</span></span><br><span class="line">        updateInDB(a)</span><br><span class="line">        b = ...</span><br><span class="line">        <span class="comment">// Then update B</span></span><br><span class="line">        updateB(b)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">updateB</span><span class="params">(B b)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Update B</span></span><br><span class="line">        updateInDB(b)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ServiceTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Service service;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        A a = <span class="keyword">new</span> A(...);</span><br><span class="line">        service.update(a)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与场景1不同，此时通过<code>无事务标识的update</code>调用<code>有事务标识的updateA</code>。</p><p>此时，<code>updateA</code>与<code>updateB</code>的事务会失效。</p><h6 id="场景3（事务失效）"><a href="#场景3（事务失效）" class="headerlink" title="场景3（事务失效）"></a>场景3（事务失效）</h6><p>考虑<code>继承调用</code>的场景如下，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseService</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">updateA</span><span class="params">(A a)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Update A</span></span><br><span class="line">        updateInDB(a)</span><br><span class="line">        b = ...</span><br><span class="line">        <span class="comment">// Then update B</span></span><br><span class="line">        updateB(b)</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">updateB</span><span class="params">(B b)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Update B</span></span><br><span class="line">        updateInDB(b)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Service</span> <span class="keyword">extends</span> <span class="title">BaseService</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">updateA</span><span class="params">(A a)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Invoke super.method</span></span><br><span class="line">        <span class="keyword">super</span>.updateA(a)</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ServiceTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Service service;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        A a = <span class="keyword">new</span> A(...);</span><br><span class="line">        service.updateA(a)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>BaseService.updateA</code>标记了<code>Transactional</code>注解。</p><p><code>Service</code>继承自<code>BaseService</code>，覆盖了<code>updateA</code>，但没有事务标识。</p><p>此时，<code>service.updateA</code>调用<code>super.updateA</code>是无法保证事务的有效性。</p><h5 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h5><p>首先，<code>Spring的核心</code>是<code>IOC控制反转</code>和<code>AOP面向切面编程</code>。</p><p><code>IOC控制反转</code>也被称为<code>DI依赖注入</code>，负责管理Spring项目中所有对象的<code>生命周期</code>与<code>依赖关系</code>。</p><p><code>AOP面向切面编程</code>是通过<code>预编译</code>或<code>动态代理</code>来改变原有模块功能的技术方式。</p><blockquote><p><code>IOC</code>是实现<code>AOP</code>的基础。</p></blockquote><p><code>AOP</code>无论哪种实现方式都会为模块生成新的代理模块，而模块之间的依赖注入是依赖<code>IOC</code>的。</p><p>也就是说，如果希望<code>AOP</code>生效，必须通过<code>IOC</code>管理的对象实例才可以生效。</p><hr><blockquote><p><code>内部调用</code>: 通过<code>this</code>或<code>super</code>的调用。</p></blockquote><p>通过<code>this</code>和<code>super</code>产生的函数调用与<code>Spring IOC</code>无关，因此<code>AOP</code>无效。</p><p>在<code>场景2</code>和<code>场景3</code>中，虽然<code>updateA</code>与<code>super.updateA</code>都带有Spring的<code>Transactional</code>注解，</p><p>但是通过<code>this</code>与<code>super</code>来调用的，因此，<code>Transactional</code>注解无效。</p><blockquote><p>只有通过<code>代理</code>调用，<code>AOP</code>才会生效，而<code>代理</code>是<code>Spring IOC</code>的一部分。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;分析AOP在一定情况下会失效的原因。&lt;/p&gt;
    
    </summary>
    
      <category term="编程语言" scheme="http://simyy.cn/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="编程语言" scheme="http://simyy.cn/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Java" scheme="http://simyy.cn/tags/Java/"/>
    
      <category term="Spring" scheme="http://simyy.cn/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Python Json序列化</title>
    <link href="http://simyy.cn/2020/03/16/python-json-serialize/"/>
    <id>http://simyy.cn/2020/03/16/python-json-serialize/</id>
    <published>2020-03-16T04:10:51.000Z</published>
    <updated>2020-03-16T04:57:53.821Z</updated>
    
    <content type="html"><![CDATA[<p>记录一下Python对象中关于Json的序列化和反序列化。<br><a id="more"></a></p><p><code>Python</code>中常用的<code>Json序列化</code>采用<code>json.dupms</code>以及<code>json.loads</code>来实现。</p><h5 id="json-dumps"><a href="#json-dumps" class="headerlink" title="json.dumps"></a>json.dumps</h5><p><code>json.dumps</code>是我们最为常用的序列化方式，用于<code>dict</code>转换成<code>Json字符串</code>。</p><p>为了解决对象序列化的问题，一般需要利用<code>__dict__</code>来获取对象的所有字段内容。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">json.dumps(obj, default=<span class="keyword">lambda</span> obj: obj.__dict__)</span><br></pre></td></tr></table></figure><blockquote><p>存在问题：如果某一字段的类型为某一个类，在序列过程中就会出现问题。</p></blockquote><p>此时，由于该非基础类型的字段无法直接转化为dict，从而<code>lambda obj: obj.__dict__)</code>会失效。</p><p>为了解决上述问题，一般可以通过定制化每一个类的序列化函数，然后通过<code>default</code>来指定。</p><p>类似这种,</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.name = <span class="keyword">None</span></span><br><span class="line">        self.age = <span class="keyword">None</span></span><br><span class="line">        <span class="comment"># Address</span></span><br><span class="line">        self.address = <span class="keyword">None</span> </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Address</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.city = <span class="keyword">None</span></span><br><span class="line">        self.province = <span class="keyword">None</span></span><br><span class="line">        self.area_code = <span class="keyword">None</span></span><br><span class="line">        self.area_detail = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">student2d</span><span class="params">(student_obj)</span>:</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">json.dumps(obj, default=student2d)</span><br></pre></td></tr></table></figure><h5 id="json-loads"><a href="#json-loads" class="headerlink" title="json.loads"></a>json.loads</h5><p><code>json.loads</code>是我们最为常用的反序列化方式，用于<code>Json字符串</code>转换成<code>dict</code>。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">json.loads(json_str, object_hook=xxxx)</span><br></pre></td></tr></table></figure><blockquote><p>存在同样的问题：如果某一字段的类型为某一个类，在反序列过程中时无法识别到具体的类结构。</p></blockquote><p>存在上述问题的原因在于，<code>Python</code>属于<code>非强类型检查</code>，初始化的类时无法获取字段的具体类型，只有在运行期初始化才确定。</p><p>同样，为了解决上述问题，一般可以通过定制化每一个类的反序列化函数，然后通过<code>object_hook</code>来指定。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.name = <span class="keyword">None</span></span><br><span class="line">        self.age = <span class="keyword">None</span></span><br><span class="line">        <span class="comment"># Address</span></span><br><span class="line">        self.address = <span class="keyword">None</span> </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Address</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.city = <span class="keyword">None</span></span><br><span class="line">        self.province = <span class="keyword">None</span></span><br><span class="line">        self.area_code = <span class="keyword">None</span></span><br><span class="line">        self.area_detail = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">d2student</span><span class="params">(self, d)</span>:</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">json.loads(obj, object_hook=d2student)</span><br></pre></td></tr></table></figure><h5 id="通用序列化"><a href="#通用序列化" class="headerlink" title="通用序列化"></a>通用序列化</h5><p>仍然存在的问题：<code>每个类都需要定义自己的序列化和反序列化函数</code>。</p><p>上面的解决方式会带来大量的重复编码的功能。</p><p>为了解决这个问题，利用<code>abc</code>模块实现序列化的抽象，如下</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> abc</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AbstractJsonSerializer</span><span class="params">(abc.ABC)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>所有带有<code>Json序列化</code>功能的类都需要继<code>AbstractJsonSerializer</code>。</p><p>下面简单介绍下序列化和反序列化的思路。</p><h6 id="serialize"><a href="#serialize" class="headerlink" title="serialize"></a>serialize</h6><p>序列化过程中，为了避免<code>__dict__</code>中特殊类造成的影响，需要对字典值类型做判断。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 循环遍历对象字段</span></span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> self.__dict__.items():</span><br><span class="line">    <span class="comment"># 字段值属于基础类型</span></span><br><span class="line">    <span class="keyword">if</span> isinstance(v, int) <span class="keyword">or</span> isinstance(v, str) \</span><br><span class="line">            <span class="keyword">or</span> isinstance(v, float) <span class="keyword">or</span> isinstance(v, list) \</span><br><span class="line">            <span class="keyword">or</span> isinstance(v, tuple) <span class="keyword">or</span> isinstance(v, set) \</span><br><span class="line">            <span class="keyword">or</span> isinstance(v, dict):</span><br><span class="line">        _d[k] = v</span><br><span class="line">    <span class="comment"># 字段值时特殊类型</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> v <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="comment"># 判断字段值是否实现了AbstractJsonSerializer</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> issubclass(v.__class__, AbstractJsonSerializer):</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">"[%s] must be implemented JsonSerializer"</span> % v.__class__)</span><br><span class="line">        <span class="comment"># 由于特殊类型字段值实现了AbstractJsonSerializer，则直接调用序列化赋值</span></span><br><span class="line">        _d[k] = v.serialize()</span><br></pre></td></tr></table></figure><h6 id="deserialize"><a href="#deserialize" class="headerlink" title="deserialize"></a>deserialize</h6><p>反序列化过程中，为了避免特殊类造成的类型无法确定的问题，需要在类中指定特殊字段类型的映射。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 抽象方法，指定特殊字段类型映射</span></span><br><span class="line"><span class="meta">@abc.abstractmethod</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">field_cls</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="comment"># 返回值例如，return &#123;'address': Address&#125;</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deserialize</span><span class="params">(self, d: dict)</span>:</span></span><br><span class="line">    <span class="comment"># 获取特殊字段类型映射</span></span><br><span class="line">    cls_map = self.field_cls()</span><br><span class="line">    <span class="comment"># 判断特殊字段类型映射是否满足要求</span></span><br><span class="line">    <span class="keyword">if</span> cls_map <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span> <span class="keyword">and</span> <span class="keyword">not</span> isinstance(cls_map, dict):</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">'[%s].special_field_class_map is must be a dict'</span> % self.__class__)</span><br><span class="line">    <span class="comment"># 遍历类对象的字段</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> self.__dict__.keys():</span><br><span class="line">        <span class="keyword">if</span> k <span class="keyword">not</span> <span class="keyword">in</span> d:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="comment"># 非特殊字段类型</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> cls_map <span class="keyword">or</span> k <span class="keyword">not</span> <span class="keyword">in</span> cls_map:</span><br><span class="line">            self.__setattr__(k, d[k])</span><br><span class="line">        <span class="comment"># 特殊字段类型</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cls = cls_map[k]</span><br><span class="line">            <span class="comment"># 判断特殊字段类型是否实现了序列化</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> issubclass(cls, AbstractJsonSerializer):</span><br><span class="line">                <span class="keyword">raise</span> Exception(<span class="string">"[%s] must be implemented JsonSerializer"</span> % cls.__class__)</span><br><span class="line">            <span class="comment"># 由于特殊类型字段值实现了AbstractJsonSerializer，则直接调用反序列化赋值</span></span><br><span class="line">            self.__setattr__(k, cls().deserialize(d[k]))</span><br><span class="line">    <span class="keyword">return</span> self</span><br></pre></td></tr></table></figure><h6 id="驼峰和下划线命名方式的转换"><a href="#驼峰和下划线命名方式的转换" class="headerlink" title="驼峰和下划线命名方式的转换"></a>驼峰和下划线命名方式的转换</h6><p>下面两个方法时用来兼容<code>驼峰</code>和<code>下划线</code>的字段命名的不同。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 字段去除`_`并全部小写</span></span><br><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">format_attr</span><span class="params">(key)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> key.replace(<span class="string">'_'</span>, <span class="string">''</span>).lower()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 代替__setattr__</span></span><br><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_attr</span><span class="params">(d, obj)</span>:</span></span><br><span class="line">    <span class="comment"># 存储对象字段映射，&#123;格式化字段：字段&#125;</span></span><br><span class="line">    obj_key_dict = dict()</span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> obj.__dict__.keys():</span><br><span class="line">        <span class="keyword">if</span> key.startswith(<span class="string">'__'</span>):</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        obj_key_dict[AbstractJsonSerializer.format_attr(key)] = key</span><br><span class="line">    <span class="comment"># 遍历字典中数据</span></span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> d.keys():</span><br><span class="line">        <span class="comment"># 获取字典的格式化key</span></span><br><span class="line">        format_key = AbstractJsonSerializer.format_attr(key)</span><br><span class="line">        <span class="comment"># 判断是否存在于对象字段映射</span></span><br><span class="line">        <span class="keyword">if</span> format_key <span class="keyword">in</span> obj_key_dict:</span><br><span class="line">            obj.__setattr__(obj_key_dict[format_key], d[key])</span><br></pre></td></tr></table></figure><h6 id="完整版实现"><a href="#完整版实现" class="headerlink" title="完整版实现"></a>完整版实现</h6><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> abc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AbstractJsonSerializer</span><span class="params">(abc.ABC)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Json Serializer</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">field_cls</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        return field class map</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">serialize</span><span class="params">(self, need_format=False)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        convert obj to dict</span></span><br><span class="line"><span class="string">        :return: dict</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        _d = dict()</span><br><span class="line">        d = self.__dict__</span><br><span class="line">        <span class="keyword">for</span> k, v <span class="keyword">in</span> d.items():</span><br><span class="line">            <span class="keyword">if</span> isinstance(v, int) <span class="keyword">or</span> isinstance(v, str) \</span><br><span class="line">                    <span class="keyword">or</span> isinstance(v, float) <span class="keyword">or</span> isinstance(v, list) \</span><br><span class="line">                    <span class="keyword">or</span> isinstance(v, tuple) <span class="keyword">or</span> isinstance(v, set) \</span><br><span class="line">                    <span class="keyword">or</span> isinstance(v, dict):</span><br><span class="line">                _d[k] = v</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> v <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> issubclass(v.__class__, AbstractJsonSerializer):</span><br><span class="line">                    <span class="keyword">raise</span> Exception(<span class="string">"[%s] must be implemented JsonSerializer"</span> % v.__class__)</span><br><span class="line">                _d[k] = v.serialize()</span><br><span class="line">        <span class="keyword">return</span> _d</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deserialize</span><span class="params">(self, d: dict)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        convert dict to obj</span></span><br><span class="line"><span class="string">        :param: d: dict</span></span><br><span class="line"><span class="string">        :return: obj</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        cls_map = self.field_cls()</span><br><span class="line">        <span class="keyword">if</span> cls_map <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span> <span class="keyword">and</span> <span class="keyword">not</span> isinstance(cls_map, dict):</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">'[%s].special_field_class_map is must be a dict'</span> % self.__class__)</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> self.__dict__.keys():</span><br><span class="line">            <span class="keyword">if</span> k <span class="keyword">not</span> <span class="keyword">in</span> d:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> cls_map <span class="keyword">or</span> k <span class="keyword">not</span> <span class="keyword">in</span> cls_map:</span><br><span class="line">                self.__setattr__(k, d[k])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cls = cls_map[k]</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> issubclass(cls, AbstractJsonSerializer):</span><br><span class="line">                    <span class="keyword">raise</span> Exception(<span class="string">"[%s] must be implemented JsonSerializer"</span> % cls.__class__)</span><br><span class="line">                self.__setattr__(k, cls().deserialize(d[k]))</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">format_attr</span><span class="params">(key)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        format field for x_y or xY to xy</span></span><br><span class="line"><span class="string">        :param key: field</span></span><br><span class="line"><span class="string">        :return: format field</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> key.replace(<span class="string">'_'</span>, <span class="string">''</span>).lower()</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_attr</span><span class="params">(d, obj)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :param d: dict of obj</span></span><br><span class="line"><span class="string">        :param obj: target obj</span></span><br><span class="line"><span class="string">        :return: None</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        obj_key_dict = dict()</span><br><span class="line">        <span class="keyword">for</span> key <span class="keyword">in</span> obj.__dict__.keys():</span><br><span class="line">            <span class="keyword">if</span> key.startswith(<span class="string">'__'</span>):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            obj_key_dict[AbstractJsonSerializer.format_attr(key)] = key</span><br><span class="line">        <span class="keyword">for</span> key <span class="keyword">in</span> d.keys():</span><br><span class="line">            format_key = AbstractJsonSerializer.format_attr(key)</span><br><span class="line">            <span class="keyword">if</span> format_key <span class="keyword">in</span> obj_key_dict:</span><br><span class="line">                obj.__setattr__(obj_key_dict[format_key], d[key])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(AbstractJsonSerializer)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">field_cls</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">'address'</span>: Address&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.name = <span class="keyword">None</span></span><br><span class="line">        self.age = <span class="keyword">None</span></span><br><span class="line">        self.address = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Address</span><span class="params">(AbstractJsonSerializer)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">field_cls</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.city = <span class="keyword">None</span></span><br><span class="line">        self.province = <span class="keyword">None</span></span><br><span class="line">        self.area_code = <span class="keyword">None</span></span><br><span class="line">        self.area_detail = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    s = Student()</span><br><span class="line">    s.name = <span class="string">'jack'</span></span><br><span class="line">    s.age = <span class="number">11</span></span><br><span class="line">    a = Address()</span><br><span class="line">    a.city = <span class="string">'hangzhou'</span></span><br><span class="line">    a.province = <span class="string">'zhejiang'</span></span><br><span class="line">    a.area_code = <span class="string">'31000'</span></span><br><span class="line">    a.area_detail = <span class="string">'gongshuqu'</span></span><br><span class="line">    s.address = a</span><br><span class="line"></span><br><span class="line">    d = s.serialize()</span><br><span class="line">    print(d)</span><br><span class="line"></span><br><span class="line">    ss = Student().deserialize(d)</span><br><span class="line">    print(ss)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录一下Python对象中关于Json的序列化和反序列化。&lt;br&gt;
    
    </summary>
    
      <category term="编程语言" scheme="http://simyy.cn/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="编程语言" scheme="http://simyy.cn/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Python" scheme="http://simyy.cn/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>ReentrantLock原理分析</title>
    <link href="http://simyy.cn/2020/03/08/java-reentrantlock/"/>
    <id>http://simyy.cn/2020/03/08/java-reentrantlock/</id>
    <published>2020-03-08T10:48:56.000Z</published>
    <updated>2020-05-19T07:13:21.831Z</updated>
    
    <content type="html"><![CDATA[<p>从源码层面分析ReentrantLock原理和实现。</p><a id="more"></a><h4 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h4><p><code>ReentrantLock</code>通过设置<code>ReentrantLock.sync</code>来实现公平与非公平锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="FairSync-amp-NonfairSync"><a href="#FairSync-amp-NonfairSync" class="headerlink" title="FairSync &amp; NonfairSync"></a>FairSync &amp; NonfairSync</h4><p><code>FairSync</code>和<code>NonfairSync</code>是实现公平锁与非公平锁的关键，均继承自<code>Sync</code>。</p><p><code>Sync</code>则是继承自<code>AbstractQueuedSynchronizer</code>，也就是大家常说的<code>AQS</code>。</p><blockquote><p><code>ReentrantLock</code>通过<code>AQS</code>和<code>CAS</code>来实现公平与非公平锁。</p></blockquote><h4 id="AQS的原理"><a href="#AQS的原理" class="headerlink" title="AQS的原理"></a>AQS的原理</h4><p><code>AQS</code>可以被称为<code>队列同步器</code>，作为<code>JUC</code>并发包的基础。</p><p><code>AQS</code>使用<code>state</code>来表示<code>同步状态</code>，也就是当前同步器的<code>加锁</code>情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AbstractQueuedSynchronizer</span> ... </span>&#123;</span><br><span class="line">    <span class="comment">// state = 0, 表示当前锁已经释放，允许线程获取锁；</span></span><br><span class="line">    <span class="comment">// state &gt; 0, 表示当前锁重入的次数；</span></span><br><span class="line">    <span class="comment">// volatile仅保证可见性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 保证原子性更新，使用unsafe调用底层的CAS原子方法</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, expect, update);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>CLH（等待队列）</code>是AQS中线程阻塞的核心，它使用<code>双向队列</code>来管理线程的状态。</p><blockquote><p>队列的优势在于把<code>无序变有序</code>，具有<code>先进先出</code>的特点。</p></blockquote><p><img src="/images/java-reentrantlock-1.png" alt=""></p><p>线程通过获取<code>同步状态（state）</code>来判断是否进入<code>等待队列（CLH）</code>。</p><blockquote><p>CLH等待队列中<code>Head头节点</code>是持有当前同步器锁的线程节点。</p></blockquote><h4 id="lock-amp-tryLock"><a href="#lock-amp-tryLock" class="headerlink" title="lock &amp; tryLock"></a>lock &amp; tryLock</h4><p><code>lock</code>和<code>tryLock</code>的不同在于是否进入线程阻塞。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 请求获取锁，会阻塞</span></span><br><span class="line">    sync.lock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 请求获取锁，不会阻塞（不回考虑CLH等待队列，代码细节在非公平锁中有解析）</span></span><br><span class="line">    <span class="keyword">return</span> sync.nonfairTryAcquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意：<code>sync</code>继承了<code>AbstractQueuedSynchronizer（AQS）</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 抽象类</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 非阻塞抢占式获取锁（失败后直接返回，不参与CLH队列逻辑）</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="comment">// 初始状态尝试加锁</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 已持有锁则增加重入数</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>AbstractQueuedSynchronizer.acquire</code>是公平锁与非公平锁在<code>lock</code>时都会触发的逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AQS</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AbstractQueuedSynchronizer</span> ... </span>&#123;</span><br><span class="line">    <span class="comment">// 获取锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 尝试获取锁</span></span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            <span class="comment">// 如果获取失败，</span></span><br><span class="line">            <span class="comment">// 1. addWaiter创建一个CLH的Node节点加入等待队列，</span></span><br><span class="line">            <span class="comment">// 2. acquireQueued循环等待获取锁</span></span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            <span class="comment">// 如果获取失败并且加入队列成功，则线程阻塞 </span></span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 阻塞（循环）并不断尝试获取锁</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// 循环（线程阻塞）, 直到当前线程获取到锁</span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="comment">// 获取CLH中当前线程节点的前驱节点</span></span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="comment">// 如果前驱节点是头结点，则尝试获取锁</span></span><br><span class="line">                <span class="comment">// 注意：head头节点是持有锁的线程节点</span></span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    <span class="comment">// 获取锁后更新头节点问题（头结点为当前持有锁的线程节点）</span></span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> interrupted;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果无法获取锁，则需要判断是否需要阻塞等待</span></span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    <span class="comment">// 如果需要阻塞的话，触发线程阻塞</span></span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    interrupted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 如果失败，则需要删除CLH中的线程节点</span></span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据前驱节点判断是否应该阻塞等待</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取前驱节点的等待状态</span></span><br><span class="line">        <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">        <span class="comment">// 如果是响应状态，则需要暂停阻塞</span></span><br><span class="line">        <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 如果ws大于0(CANCELLED=1),前驱节点已取消等待，需要向前遍历一个等待中的节点</span></span><br><span class="line">        <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                node.prev = pred = pred.prev;</span><br><span class="line">            &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">            pred.next = node;</span><br><span class="line">        <span class="comment">// 如果ws&lt;=0(需要排除SIGNAL=-1,还有CONDITION=-2和PROPAGATE=-3,为初始状态), 尝试修改为响应状态</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// CAS原子操作</span></span><br><span class="line">            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 线程阻塞</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// LockSupport是JDK提供的用于阻塞线程的工具</span></span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码可以看出来，公平锁和非公平锁的大体流程相似：</p><ul><li>尝试获取锁</li><li>失败的话，加入CLH等待队列</li><li>按照CLH等待队列的逻辑获取锁（队首优先获取）</li><li>非队首节点判断自身是否需要进入线程阻塞</li><li>线程阻塞等待被唤醒（<code>唤醒是在前驱节点锁释放后触发的</code>）</li></ul><blockquote><p>那如何体现出两者的不同之处呢？<br>公平锁和非公平锁的区别在于<code>lock</code>与<code>tryAcquire</code>实现的不同。</p></blockquote><h5 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h5><p>公平锁的核心在于<code>CLH等待队列</code>。</p><p><code>CLH等待队列</code>按照线程入队的先后顺序来分配锁，在获取<code>state同步状态</code>时通过<code>unsafe的CAS</code>来操作来保证更新的原子性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 公平锁    </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用上面提到的AQS.acquire</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 尝试获取锁</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 当前线程</span></span><br><span class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">        <span class="comment">// AQS的同步状态（重入次数）</span></span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="comment">// 锁释放状态(重入次数为0)</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 重点逻辑：是否存在等待线程（与非公平锁的区别所在）</span></span><br><span class="line">            <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                <span class="comment">// 如果不存在等待线程，不需要进入队列，直接尝试CAS设置同步状态</span></span><br><span class="line">                compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                <span class="comment">// 更新锁状态成功的话，设置独占线程</span></span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 锁重入</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">            <span class="comment">// 更新重入次数</span></span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="非公平锁"><a href="#非公平锁" class="headerlink" title="非公平锁"></a>非公平锁</h5><p>非公平锁的核心在于<code>提前的抢占式获取锁</code>，如果提前抢占失败仍然会进入公平锁的锁分配逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 公平锁  </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 不同之处1：在acquire之前，直接尝试获取锁</span></span><br><span class="line">        <span class="comment">// CAS原子操作尝试修改同步状态，成功则更新独占线程</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        <span class="comment">// 获取失败，则继续尝试</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 同公平锁一样的逻辑</span></span><br><span class="line">            acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 不同之处2：tryAcquire中直接尝试获取锁（不考虑CLH队列情况）</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 上面有分析过</span></span><br><span class="line">        <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非公平获取（上面有分析过，这里仅指出与公平锁的不同）</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 不同之处2：不存在hasQueuedPredecessors的判断，缺少CLH队列校验</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>从代码中可以得知，非公平锁的不同之处有两点：</p><ul><li><code>lock</code>时直接使用<code>CAS</code>尝试获取锁 </li><li><code>acquire不考虑CLH等待队列</code>，直接使用<code>CAS</code>尝试获取锁</li></ul></blockquote><h5 id="unlock"><a href="#unlock" class="headerlink" title="unlock"></a>unlock</h5><p><code>锁的释放</code>会唤醒CLH等待队列中后续的阻塞线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 释放锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// AQS</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AbstractQueuedSynchronizer</span> ... </span>&#123;</span><br><span class="line">    <span class="comment">// 释放锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 尝试释放锁成功（重入情况下不一定释放锁，可能仅减少重入次数）</span></span><br><span class="line">        <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">            Node h = head;</span><br><span class="line">            <span class="comment">// CLH等待队列非空，头结点非初始状态（waitStatus=0为节点初始状态）</span></span><br><span class="line">            <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">                <span class="comment">// 唤醒CLH等待队列中的阻塞线程节点</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 尝试释放</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 减少重入数</span></span><br><span class="line">        <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">        <span class="comment">// 判断锁的所有权</span></span><br><span class="line">        <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">        <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 如果重入数为0，则释放锁并清空独占线程</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            free = <span class="keyword">true</span>;</span><br><span class="line">            setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新锁状态</span></span><br><span class="line">        setState(c);</span><br><span class="line">        <span class="keyword">return</span> free;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 唤醒CLH队列中阻塞的线程</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">        <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">            compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line">        Node s = node.next;</span><br><span class="line">        <span class="comment">// 过滤掉空节点与已删除节点（waitStatus=1）</span></span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            s = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 从对尾开始遍历直到对首，找到一个距离头节点最近的节点唤醒</span></span><br><span class="line">            <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">                <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                    s = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">// 与LockSupport.park对应，停止阻塞线程</span></span><br><span class="line">            LockSupport.unpark(s.thread);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>锁释放过程中需要注意：</p><ul><li>每次<code>tryRelease</code>不一定会释放锁，仅可能<code>减少重入次数</code>；</li><li>如果<code>重入次数为0</code>则代表锁可以释放，可以<code>唤醒CLH等待队列中阻塞的线程</code>。</li></ul></blockquote><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>无论是公平锁和非公平锁，CLH等待队列都是存在的。</p><p><code>公平</code>是利用<code>队列的先进先出</code>来实现，而<code>非公平</code>是在加入队列之前尝试获取锁。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从源码层面分析ReentrantLock原理和实现。&lt;/p&gt;
    
    </summary>
    
      <category term="编程语言" scheme="http://simyy.cn/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="编程语言" scheme="http://simyy.cn/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Java" scheme="http://simyy.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>RPC实现原理</title>
    <link href="http://simyy.cn/2020/02/17/rpc/"/>
    <id>http://simyy.cn/2020/02/17/rpc/</id>
    <published>2020-02-17T14:13:16.000Z</published>
    <updated>2020-02-18T10:06:15.958Z</updated>
    
    <content type="html"><![CDATA[<p>本文简单记录下RPC框架的原理。</p><a id="more"></a><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p><code>RPC</code>全称为<code>Remote Procedure Call</code>，译为<code>远程过程调用</code>。</p><p>常见的<code>RPC框架</code>的包括<code>Dubbo</code>、<code>Thrift</code>、<code>Hissan</code>、<code>GRPC</code>等。</p><h4 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h4><p><code>RPC</code>主要是由<code>提供者</code>、<code>消费者</code>和<code>注册中心</code>三部分组成。</p><p><img src="/images/rpc-1.png" alt=""></p><ol><li><p><code>提供者</code>是服务的提供方，需要把自身提供的服务注册到<code>注册中心</code>。</p></li><li><p><code>消费者</code>是服务的消费方，需要从<code>注册中心</code>获取最新的服务提供方的信息。</p></li></ol><p>此外，为了集群消费状态的监控，<code>消费者</code>也需要把自己的地址注册到<code>注册中心</code>。</p><ol start="3"><li><code>注册中心</code>是服务注册和发现的关键，用于保存<code>服务提供者的地址端口</code>以及<code>消费者的地址</code>。</li></ol><h4 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a>注册中心</h4><p>常用的注册中心有<code>Zookeeper</code>、<code>Etcd</code>、<code>Consul</code>和<code>Euerka</code>。</p><p><code>Zookeeper</code>使用<code>zab</code>一致性协议，属于<code>CP</code>。</p><p><code>Etcd</code>和<code>Consul</code>均使用<code>raft</code>一致性协议，属于<code>CP</code>。</p><p><code>Euerka</code>属于<code>AP</code>，主要用于服务发现和注册（存在部分延迟影响不大），因此采用最终一致性。</p><blockquote><p><code>注册中心</code>的中心化问题？</p><p>服务的调用和发现都是依赖<code>注册中心</code>，其高可用尤为重要。</p><p><code>CAP</code>理论是由<code>一致性(C)</code>、<code>可用性(A)</code>、<code>分区备份(P)</code>组成。</p><ul><li><code>可用性(A)</code>：服务是否一直可用，集群环境下选主的方式（多分区）。</li><li><code>一致性(C)</code>：集群环境下的一致性算法包括<code>paxos</code>/<code>zab</code>/<code>raft</code>。</li><li><code>分区备份(P)</code>：数据多分备份。</li></ul></blockquote><h4 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h4><p><code>注册</code>可以分为两种：<code>节点注册</code>和<code>服务注册</code>，</p><ol><li><p><code>节点注册</code>：提供者、消费者，其中，提供者一般需要提供<code>IP</code>和<code>PORT</code>，而消费者仅提供<code>IP</code>；</p></li><li><p><code>服务注册</code>：提供者，仅需要提供当前节点所能提供的rpc服务。</p></li></ol><blockquote><p>注册存在<code>失败</code>的情况，因此需要设置合理的<code>失败重试机制</code>。</p></blockquote><p>注册的具体方式如图所示，</p><p><img src="/images/rpc-2.png" alt=""></p><p><code>/frpc</code>是<code>rpc</code>服务注册的独立命名空间。</p><blockquote><p><code>临时节点</code>的生命周期与注册节点相同，可以用于实现实时监控。</p></blockquote><p><code>非地址节点</code>都属于<code>持久节点</code>，<code>地址节点</code>属于<code>临时节点</code>。</p><p><code>服务隔离</code>是通过<code>/frpc/groupx</code>来实现的，通过把服务注册到不同的节点上来实现服务的隔离。</p><h4 id="发现"><a href="#发现" class="headerlink" title="发现"></a>发现</h4><p><code>发现</code>仅作为<code>消费者</code>的依赖服务获取方式。</p><p><code>发现</code>是通过<code>监控器Watcher</code>的方式来实现服务节点状态的实时更新。</p><h4 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h4><p><code>RPC</code>框架一般采用<code>直连调用</code>的方式来建立消费者和提供者之间的通信。</p><p><code>直连调用</code>的性能最佳，任何代理都会存在性能的损耗。</p><blockquote><p><code>服务网格</code>利用<code>proxy</code>来实现网格之间的调用，为了降低客户端的复杂度，牺牲了网络性能。</p></blockquote><p><code>通信方式</code>包括<code>TCP</code>、<code>UDP</code>、<code>HTTP</code>和<code>HTTP2</code>，常用的是<code>TCP</code>和<code>HTTP2</code>。</p><p><code>TCP</code>是传输层协议，存在粘包问题，需要自定义数据包格式。</p><p><img src="/images/rpc-3.png" alt=""></p><ul><li><code>Magic Number</code>：用于识别数据包的起始位置；</li><li><code>Serialize Type</code>：标识数据的序列化方式；</li><li><code>Packet Type</code>：标识数据包的结构类型；</li><li><code>Data Length</code>：标识数据的大小，用来读取完整的数据包；</li><li><code>Data Bytes</code>：具体数据。</li></ul><p><code>HTTP2</code>是应用层协议，用于取代<code>HTTP</code>，是<code>GRPC</code>中的通信方式。</p><h4 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h4><p><code>路由</code>是指同一服务下不同节点的选择策略，常见的选择策略包括<code>轮询</code>、<code>性能</code>、<code>负载</code>、<code>优先级</code>。</p><p><code>路由</code>一般分为两种：<code>基于客户端的路由</code>与<code>基于代理的路由</code>。</p><p><code>基于客户端的路由</code>是通过消费者自身的客户端来实现节点的选择策略，对消费者自身存在一定的性能消耗。</p><p><code>基于代理的路由</code>是通过部署再消费者环境下的独立存在，不会与消费者产生资源竞争，但存在一层网络性能损耗。</p><p>此外，<code>路由标签</code>可以用于服务的隔离。</p><h4 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h4><p><code>监控的目标</code>可分为两种：</p><ul><li><code>实体</code>：生产者、消费者、服务状态；</li><li><code>性能</code>：接口耗时、接口QPS。</li></ul><p><code>实体数据</code>可以从<code>注册中心</code>直接拉取，不需要提供者和消费者参与。</p><p><code>性能数据的上报</code>采用异步上报的方式，从而避免对服务性能的影响。</p><h4 id="管理"><a href="#管理" class="headerlink" title="管理"></a>管理</h4><p><code>管理</code>可以分为<code>服务管理</code>和<code>节点管理</code>。</p><p><code>服务管理</code>是指服务的<code>生效</code>和<code>失效</code>。</p><p><code>节点管理</code>是指节点的<code>上线</code>、<code>下线</code>和<code>路由权重</code>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文简单记录下RPC框架的原理。&lt;/p&gt;
    
    </summary>
    
      <category term="架构" scheme="http://simyy.cn/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="架构" scheme="http://simyy.cn/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="微服务" scheme="http://simyy.cn/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="RPC" scheme="http://simyy.cn/tags/RPC/"/>
    
  </entry>
  
</feed>
