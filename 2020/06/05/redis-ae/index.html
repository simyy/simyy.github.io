<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>Redis AE事件驱动 | simyy</title>
  <meta name="viewport" content="width=device-width">
  <meta name="description" content="AE事件驱动是Redis命令解析处理的基础。">
<meta name="keywords" content="中间件,缓存,Redis">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis AE事件驱动">
<meta property="og:url" content="http://simyy.cn/2020/06/05/redis-ae/index.html">
<meta property="og:site_name" content="simyy">
<meta property="og:description" content="AE事件驱动是Redis命令解析处理的基础。">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://simyy.cn/images/redis-ae-1.png">
<meta property="og:image" content="http://simyy.cn/images/redis-ae-2.png">
<meta property="og:image" content="http://simyy.cn/images/redis-ae-3.png">
<meta property="og:image" content="http://simyy.cn/images/redis-ae-4.png">
<meta property="og:image" content="http://simyy.cn/images/redis-ae-5.png">
<meta property="og:image" content="http://simyy.cn/images/redis-ae-6.png">
<meta property="og:image" content="http://simyy.cn/images/redis-ae-7.png">
<meta property="og:image" content="http://simyy.cn/images/redis-ae-8.png">
<meta property="og:updated_time" content="2020-06-05T11:24:40.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Redis AE事件驱动">
<meta name="twitter:description" content="AE事件驱动是Redis命令解析处理的基础。">
<meta name="twitter:image" content="http://simyy.cn/images/redis-ae-1.png">
  
    <link rel="alternative" href="/atom.xml" title="simyy" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
</head></html>
<script src="/js/hexo_resize_image.js"></script>
<body>
  <div id="container">
    <div class="mobile-nav-panel">
	<i class="icon-reorder icon-large"></i>
</div>
<header id="header">
	<h1 class="blog-title">
		<a href="/">simyy</a>
	</h1>
	<nav class="nav">
		<ul>
			<li><a href="/">主页</a></li><li><a href="/2014/07/07/book-list">书单</a></li><li><a href="/archives">归档</a></li><li><a href="/tags">标签</a></li>
			<li><a id="nav-search-btn" class="nav-icon" title="Search"></a></li>
			<li><a href="/atom.xml" id="nav-rss-link" class="nav-icon" title="RSS Feed"></a></li>
		</ul>
	</nav>
	<div id="search-form-wrap">
		<form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://simyy.cn"></form>
	</div>
</header>
    <!--div id="main"-->
      <div id="main">


<article id="post-redis-ae" class="post">
	<footer class="entry-meta-header">
		<span class="meta-elements date">
			<a href="/2020/06/05/redis-ae/" class="article-date">
  <time datetime="2020-06-05T10:58:39.000Z" itemprop="datePublished">2020-06-05</time>
</a>

		</span>
        <span class="tags">
	       	
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Redis/">Redis</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/中间件/">中间件</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/缓存/">缓存</a></li></ul>

		</span>
		<!--span class="meta-elements author">simyy</span-->
		<div class="commentscount">
			
		</div>
	</footer>
	
	<header class="entry-header">
		
  
    <h1 class="article-title entry-title" itemprop="name">
      Redis AE事件驱动
    </h1>
  

	</header>
	<div class="entry-content">
		
    	<p>AE事件驱动是Redis命令解析处理的基础。</p>
<a id="more"></a>
<h4 id="事件驱动"><a href="#事件驱动" class="headerlink" title="事件驱动"></a>事件驱动</h4><p><code>Redis</code>实现了一套事件驱动器<code>AE</code>，理由也很简单，逻辑简单可控。</p>
<blockquote>
<p><code>Memcached</code>的事件驱动时基于<code>libevent</code>的。</p>
</blockquote>
<h5 id="事件结构"><a href="#事件结构" class="headerlink" title="事件结构"></a>事件结构</h5><p><img src="/images/redis-ae-1.png" alt=""></p>
<p><code>aeEventLoop</code>是整个事件驱动的核心，事件的注册与触发都基于此。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 事件循环结构体 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">aeEventLoop</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">int</span> setsize;                  <span class="comment">// 支持连接的最大句柄数量</span></span><br><span class="line">    aeFileEvent *events;           <span class="comment">// 已注册的事件</span></span><br><span class="line">    aeFiredEvent *fired;           <span class="comment">// 已触发的事件</span></span><br><span class="line">    aeTimeEvent *timeEventHead;     <span class="comment">// 时间事件(定时触发)</span></span><br><span class="line">    aeBeforeSleepProc *beforesleep; <span class="comment">// 事件循环sleep之前的的执行函数 </span></span><br><span class="line">    aeBeforeSleepProc *aftersleep;  <span class="comment">// 事件循环sleep之后的的执行函数</span></span><br><span class="line">    <span class="keyword">void</span> *apidata;                <span class="comment">// select/poll/epoll的API交互数据</span></span><br><span class="line">    ...</span><br><span class="line">&#125; aeEventLoop;</span><br></pre></td></tr></table></figure>
<p><code>aeFileEvent</code>是具体的事件结构，其中，包含了<code>事件类型</code>与<code>对应的处理函数</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AE_NONE 0       <span class="comment">// 未注册</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AE_READABLE 1   <span class="comment">// 可读</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AE_WRITABLE 2   <span class="comment">// 可写</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AE_BARRIER 4    <span class="comment">// 强制先写后读</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 文件(IO)事件结构体 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">aeFileEvent</span> &#123;</span></span><br><span class="line">    <span class="comment">/* 读写标记 */</span></span><br><span class="line">    <span class="keyword">int</span> mask; <span class="comment">/* one of AE_(READABLE|WRITABLE|BARRIER) */</span></span><br><span class="line">    aeFileProc *rfileProc; <span class="comment">// 读事件对应的执行函数</span></span><br><span class="line">    aeFileProc *wfileProc; <span class="comment">// 写事件对应的执行函数</span></span><br><span class="line">    <span class="keyword">void</span> *clientData;     <span class="comment">// 事件相关的数据</span></span><br><span class="line">&#125; aeFileEvent;</span><br></pre></td></tr></table></figure>
<h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><p><img src="/images/redis-ae-2.png" alt=""></p>
<p><code>aeCreateEventLoop</code>是用于初始化事件循环结构体。</p>
<p><code>setsize</code>是Redis支持句柄的数量，在eventloop初始化时用于<code>初始化事件的存储大小</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 初始化事件循环 */</span></span><br><span class="line"><span class="function">aeEventLoop *<span class="title">aeCreateEventLoop</span><span class="params">(<span class="keyword">int</span> setsize)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 初始化事件循环</span></span><br><span class="line">    <span class="keyword">if</span> ((eventLoop = zmalloc(<span class="keyword">sizeof</span>(*eventLoop))) == <span class="literal">NULL</span>) <span class="keyword">goto</span> err;</span><br><span class="line">    <span class="comment">// 设置默认支持最大连接的数量（也就是可存储的事件数量）</span></span><br><span class="line">    eventLoop-&gt;events = zmalloc(<span class="keyword">sizeof</span>(aeFileEvent)*setsize);</span><br><span class="line">    <span class="comment">// 已触发的事件的最大数量与注册事件的最大数量相同</span></span><br><span class="line">    eventLoop-&gt;fired = zmalloc(<span class="keyword">sizeof</span>(aeFiredEvent)*setsize);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 创建事件循环触发器（select/epoll/...）</span></span><br><span class="line">    <span class="comment">// 具体参考：IO多路复用的多种实现</span></span><br><span class="line">    <span class="keyword">if</span> (aeApiCreate(eventLoop) == <span class="number">-1</span>) <span class="keyword">goto</span> err;</span><br><span class="line">    <span class="comment">/* Events with mask == AE_NONE are not set. So let's initialize the</span></span><br><span class="line"><span class="comment">     * vector with it. */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; setsize; i++)</span><br><span class="line">        eventLoop-&gt;events[i].mask = AE_NONE;</span><br><span class="line">    <span class="keyword">return</span> eventLoop;</span><br><span class="line">    <span class="keyword">return</span> eventLoop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Redis</code>支持多个地址端口的绑定，文件句柄都存储在<code>server.ipfd</code>，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ipfd[CONFIG_BINDADDR_MAX]; <span class="comment">// 用于监听客户端请求的文件句柄</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 服务器初始化 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initServer</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// socket.listen绑定监听端口</span></span><br><span class="line">    <span class="keyword">if</span> (server.port != <span class="number">0</span> &amp;&amp;</span><br><span class="line">        listenToPort(server.port,server.ipfd,&amp;server.ipfd_count) == C_ERR)</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 每一个fd创建一个可读事件，并设置socket.accept回调</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; server.ipfd_count; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (aeCreateFileEvent(server.el, server.ipfd[j], AE_READABLE,</span><br><span class="line">            acceptTcpHandler,<span class="literal">NULL</span>) == AE_ERR)</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>aeCreateFileEvent</code>是用于为监听的句柄创建事件及其对应的处理器，其中，<code>aeApiAddEvent</code>存在多种IO多路复用的实现。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 为句柄创建事件 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">aeCreateFileEvent</span><span class="params">(aeEventLoop *eventLoop, <span class="keyword">int</span> fd, <span class="keyword">int</span> mask,</span></span></span><br><span class="line"><span class="function"><span class="params">        aeFileProc *proc, <span class="keyword">void</span> *clientData)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 获取句柄对应的事件</span></span><br><span class="line">    aeFileEvent *fe = &amp;eventLoop-&gt;events[fd];</span><br><span class="line">    <span class="comment">// 将句柄加入到事件监听中（select/epoll/...）</span></span><br><span class="line">    <span class="comment">// 具体参考：IO多路复用的多种实现</span></span><br><span class="line">    <span class="keyword">if</span> (aeApiAddEvent(eventLoop, fd, mask) == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> AE_ERR;</span><br><span class="line">    fe-&gt;mask |= mask;</span><br><span class="line">    <span class="comment">// 设置事件回调（区分读写）</span></span><br><span class="line">    <span class="keyword">if</span> (mask &amp; AE_READABLE) fe-&gt;rfileProc = proc;</span><br><span class="line">    <span class="keyword">if</span> (mask &amp; AE_WRITABLE) fe-&gt;wfileProc = proc;</span><br><span class="line">    <span class="comment">// 设置客户端信息</span></span><br><span class="line">    fe-&gt;clientData = clientData;</span><br><span class="line">    <span class="keyword">return</span> AE_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/redis-ae-3.png" alt=""></p>
<p><code>acceptTcpHandler</code>是<code>Socket.Accept</code>接收到新的客户端请求的处理器，用于设置后续的可读事件，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 处理监听到的Accept请求 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">acceptTcpHandler</span><span class="params">(aeEventLoop *el, <span class="keyword">int</span> fd, <span class="keyword">void</span> *privdata, <span class="keyword">int</span> mask)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">while</span>(max--) &#123;</span><br><span class="line">        <span class="comment">// Accept句柄fd监听到的请求，返回客户端句柄cfd</span></span><br><span class="line">        cfd = anetTcpAccept(server.neterr, fd, cip, <span class="keyword">sizeof</span>(cip), &amp;cport);</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">/* Accept成功后设置可读事件 */</span></span><br><span class="line">        acceptCommonHandler(cfd,<span class="number">0</span>,cip);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>acceptCommonHandler</code>是用于Accept后用于<code>初始化客户端并设置可读事件</code>的处理器。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">acceptCommonHandler</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> flags, <span class="keyword">char</span> *ip)</span> </span>&#123;</span><br><span class="line">    client *c;</span><br><span class="line">    <span class="comment">/* 创建客户端（内部初始化可读事件） */</span></span><br><span class="line">    <span class="keyword">if</span> ((c = createClient(fd)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化客户端并设置可读事件 */</span></span><br><span class="line"><span class="function">client *<span class="title">createClient</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化客户端</span></span><br><span class="line">    client *c = zmalloc(<span class="keyword">sizeof</span>(client));</span><br><span class="line">    <span class="keyword">if</span> (fd != <span class="number">-1</span>) &#123;</span><br><span class="line">        anetNonBlock(<span class="literal">NULL</span>,fd);                         <span class="comment">// 是否阻塞</span></span><br><span class="line">        anetEnableTcpNoDelay(<span class="literal">NULL</span>,fd);                  <span class="comment">// 是否关闭Nagle算法</span></span><br><span class="line">        <span class="keyword">if</span> (server.tcpkeepalive)</span><br><span class="line">            anetKeepAlive(<span class="literal">NULL</span>,fd,server.tcpkeepalive);   <span class="comment">// 设置keepalive</span></span><br><span class="line">        <span class="comment">// 为当前客户端创建可读事件，并设置读取处理函数readQueryFromClient（下面有详细介绍）</span></span><br><span class="line">        <span class="keyword">if</span> (aeCreateFileEvent(server.el,fd,AE_READABLE,</span><br><span class="line">            readQueryFromClient, c) == AE_ERR)</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>到此，<code>Redis</code>服务端的<code>Socket绑定与监听</code>、<code>客户端初始化</code>等初始化逻辑已经分析完毕。</p>
</blockquote>
<h5 id="主流程"><a href="#主流程" class="headerlink" title="主流程"></a>主流程</h5><p>Redis的处理过程是<code>单线程的</code>，事件驱动的核心就在<code>aeMain</code>这个循环体内。</p>
<blockquote>
<p>基于内核提供的<code>select/poll/epoll</code>来轮询事件实现循环执行。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">aeMain</span><span class="params">(aeEventLoop *eventLoop)</span> </span>&#123;</span><br><span class="line">    eventLoop-&gt;stop = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 事件循环</span></span><br><span class="line">    <span class="keyword">while</span> (!eventLoop-&gt;stop) &#123;</span><br><span class="line">        <span class="keyword">if</span> (eventLoop-&gt;beforesleep != <span class="literal">NULL</span>)</span><br><span class="line">            <span class="comment">// 触发事件循环的前置处理器</span></span><br><span class="line">            eventLoop-&gt;beforesleep(eventLoop);</span><br><span class="line">        <span class="comment">// 事件处理</span></span><br><span class="line">        aeProcessEvents(eventLoop, AE_ALL_EVENTS|AE_CALL_AFTER_SLEEP);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h5><p><img src="/images/redis-ae-4.png" alt=""></p>
<p><code>aeProcessEvents</code>是具体的处理逻辑，包括了<code>事件获取</code>、<code>事件分发</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 事件处理函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">aeProcessEvents</span><span class="params">(aeEventLoop *eventLoop, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 处理数量</span></span><br><span class="line">    <span class="keyword">int</span> processed = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// IO多路复用API, 获取并设置等待处理的事件数量（eventloop.fired）</span></span><br><span class="line">    <span class="keyword">int</span> numevents = aeApiPoll(eventLoop, tvp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 触发事件循环的后置处理器</span></span><br><span class="line">    <span class="keyword">if</span> (eventLoop-&gt;aftersleep != <span class="literal">NULL</span> &amp;&amp; flags &amp; AE_CALL_AFTER_SLEEP)</span><br><span class="line">        eventLoop-&gt;aftersleep(eventLoop);</span><br><span class="line">        </span><br><span class="line">    <span class="comment">/* 开始分发事件，执行对应的处理器 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历已触发待处理的事件</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; numevents; j++) &#123;</span><br><span class="line">        aeFileEvent *fe = &amp;eventLoop-&gt;events[eventLoop-&gt;fired[j].fd];</span><br><span class="line">        <span class="keyword">int</span> mask = eventLoop-&gt;fired[j].mask;  <span class="comment">// 事件类型</span></span><br><span class="line">        <span class="keyword">int</span> fd = eventLoop-&gt;fired[j].fd;      <span class="comment">// 事件句柄</span></span><br><span class="line">        <span class="keyword">int</span> fired = <span class="number">0</span>;                        <span class="comment">// 统计事件</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 是否开启强制先写后读</span></span><br><span class="line">        <span class="keyword">int</span> invert = fe-&gt;mask &amp; AE_BARRIER;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果未开启先写后读且为读事件</span></span><br><span class="line">        <span class="keyword">if</span> (!invert &amp;&amp; fe-&gt;mask &amp; mask &amp; AE_READABLE) &#123;</span><br><span class="line">            fe-&gt;rfileProc(eventLoop,fd,fe-&gt;clientData,mask);</span><br><span class="line">            fired++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果为写事件</span></span><br><span class="line">        <span class="keyword">if</span> (fe-&gt;mask &amp; mask &amp; AE_WRITABLE) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!fired || fe-&gt;wfileProc != fe-&gt;rfileProc) &#123;</span><br><span class="line">                fe-&gt;wfileProc(eventLoop,fd,fe-&gt;clientData,mask);</span><br><span class="line">                fired++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果开启先写后读且为读事件</span></span><br><span class="line">        <span class="keyword">if</span> (invert &amp;&amp; fe-&gt;mask &amp; mask &amp; AE_READABLE) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!fired || fe-&gt;wfileProc != fe-&gt;rfileProc) &#123;</span><br><span class="line">                fe-&gt;rfileProc(eventLoop,fd,fe-&gt;clientData,mask);</span><br><span class="line">                fired++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理数量+1</span></span><br><span class="line">        processed++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 处理定时事件</span></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; AE_TIME_EVENTS)</span><br><span class="line">        processed += processTimeEvents(eventLoop);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> processed; <span class="comment">/* return the number of processed file/time events */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>从上面的源码分析得出：<code>事件的收集工作是系统负责的，Redis仅通过每次的循环来不断拿到最新的触发事件</code>。</p>
</blockquote>
<p><strong>AE事件驱动的原理：IO多路复用</strong></p>
<p>在上面的处理过程中，使用了<code>aeApiPoll</code>这个函数，按不同平台的实现方式有：</p>
<ul>
<li><code>ae_evport</code>：Solaris 10</li>
<li><code>ae_kqueue</code>：OS X / FreeBSD</li>
<li><code>ae_select</code>：通用的</li>
<li><code>ae_epoll</code>：Linux</li>
</ul>
<blockquote>
<p><a href="https://stackoverflow.com/questions/26420947/what-are-the-underlying-differences-among-select-epoll-kqueue-and-evport" target="_blank" rel="noopener">What are the underlying differences among select, epoll, kqueue, and evport?</a></p>
</blockquote>
<p><code>Select</code>最多支持1024个文件句柄，由于每次都需要遍历所有的操作符的状态，因此，时间复杂度是O(n)；</p>
<p><code>Evport</code>、<code>Epoll</code>、<code>KQueue</code>支持更多的文件句柄，基于系统的实现策略不需要遍历操作符，时间复杂度是O(1)。</p>
<p>这里仅分析基于<code>epoll</code>的实现。</p>
<h6 id="事件注册"><a href="#事件注册" class="headerlink" title="事件注册"></a>事件注册</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">aeApiAddEvent</span><span class="params">(aeEventLoop *eventLoop, <span class="keyword">int</span> fd, <span class="keyword">int</span> mask)</span> </span>&#123;</span><br><span class="line">    aeApiState *state = eventLoop-&gt;apidata;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ee</span> = &#123;</span><span class="number">0</span>&#125;;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 识别读写事件，设置EPOLLIN/EPOLLOUT</span></span><br><span class="line">    <span class="keyword">if</span> (mask &amp; AE_READABLE) ee.events |= EPOLLIN;</span><br><span class="line">    <span class="keyword">if</span> (mask &amp; AE_WRITABLE) ee.events |= EPOLLOUT;</span><br><span class="line">    ee.data.fd = fd;</span><br><span class="line">    <span class="comment">// 调用epoll的epoll_ctl注册需要监听的事件</span></span><br><span class="line">    <span class="keyword">if</span> (epoll_ctl(state-&gt;epfd,op,fd,&amp;ee) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="事件获取"><a href="#事件获取" class="headerlink" title="事件获取"></a>事件获取</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AE事件获取</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">aeApiPoll</span><span class="params">(aeEventLoop *eventLoop, struct timeval *tvp)</span> </span>&#123;</span><br><span class="line">    aeApiState *state = eventLoop-&gt;apidata;</span><br><span class="line">    <span class="keyword">int</span> retval, numevents = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用epoll的epoll_wait获取等待事件（类似select调用）</span></span><br><span class="line">    retval = epoll_wait(state-&gt;epfd,state-&gt;events,eventLoop-&gt;setsize,</span><br><span class="line">            tvp ? (tvp-&gt;tv_sec*<span class="number">1000</span> + tvp-&gt;tv_usec/<span class="number">1000</span>) : <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span> (retval &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="comment">// 循环遍历所有已触发的事件</span></span><br><span class="line">        numevents = retval;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; numevents; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> mask = <span class="number">0</span>;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> *<span class="title">e</span> = <span class="title">state</span>-&gt;<span class="title">events</span>+<span class="title">j</span>;</span></span><br><span class="line">            <span class="comment">// 识别事件类型</span></span><br><span class="line">            <span class="keyword">if</span> (e-&gt;events &amp; EPOLLIN) mask |= AE_READABLE;</span><br><span class="line">            <span class="keyword">if</span> (e-&gt;events &amp; EPOLLOUT) mask |= AE_WRITABLE;</span><br><span class="line">            <span class="keyword">if</span> (e-&gt;events &amp; EPOLLERR) mask |= AE_WRITABLE;</span><br><span class="line">            <span class="keyword">if</span> (e-&gt;events &amp; EPOLLHUP) mask |= AE_WRITABLE;</span><br><span class="line">            <span class="comment">// 设置链接的文件句柄</span></span><br><span class="line">            eventLoop-&gt;fired[j].fd = e-&gt;data.fd;</span><br><span class="line">            <span class="comment">// 设置事件类型</span></span><br><span class="line">            eventLoop-&gt;fired[j].mask = mask;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numevents;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="事件处理-1"><a href="#事件处理-1" class="headerlink" title="事件处理"></a>事件处理</h6><p><strong>读取</strong></p>
<p><img src="/images/redis-ae-5.png" alt=""></p>
<p><code>readQueryFromClient</code>是从客户端读取请求数据的处理函数，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每次读取Buffer的默认大小：16K</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROTO_IOBUF_LEN         (1024*16)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 读取客户端请求 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readQueryFromClient</span><span class="params">(aeEventLoop *el, <span class="keyword">int</span> fd, <span class="keyword">void</span> *privdata, <span class="keyword">int</span> mask)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 客户端连接的配置信息</span></span><br><span class="line">    client *c = (client*) privdata;</span><br><span class="line">    <span class="comment">// 设置读取大小</span></span><br><span class="line">    readlen = PROTO_IOBUF_LEN;</span><br><span class="line">    <span class="comment">// 获取客户端已经读取过的大小</span></span><br><span class="line">    qblen = sdslen(c-&gt;querybuf);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 扩展客户端请求buffer的大小</span></span><br><span class="line">    c-&gt;querybuf = sdsMakeRoomFor(c-&gt;querybuf, readlen);</span><br><span class="line">    <span class="comment">// 读取数据，追加在原有querybuf内容的后面</span></span><br><span class="line">    nread = read(fd, c-&gt;querybuf+qblen, readlen);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 处理客户端请求buffer中的数据</span></span><br><span class="line">    processInputBufferAndReplicate(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理Buffer</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processInputBufferAndReplicate</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(c-&gt;flags &amp; CLIENT_MASTER)) &#123;</span><br><span class="line">        processInputBuffer(c);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>执行</strong></p>
<p><img src="/images/redis-ae-6.png" alt=""></p>
<p><code>processInputBuffer</code>是用于解析客户端请求的Buffer并调用<code>processCommand</code>执行对应的操作，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 处理缓存内的请求数据 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processInputBuffer</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 设置当前处理的客户端</span></span><br><span class="line">    server.current_client = c;</span><br><span class="line">    <span class="comment">// 循环读取Buffer并处理</span></span><br><span class="line">    <span class="keyword">while</span>(c-&gt;qb_pos &lt; sdslen(c-&gt;querybuf)) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 根据不同的请求类型，尝试解析请求命令（数据完整），否则，进入下一次循环</span></span><br><span class="line">        <span class="keyword">if</span> (c-&gt;reqtype == PROTO_REQ_INLINE) &#123;</span><br><span class="line">            <span class="keyword">if</span> (processInlineBuffer(c) != C_OK) <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c-&gt;reqtype == PROTO_REQ_MULTIBULK) &#123;</span><br><span class="line">            <span class="keyword">if</span> (processMultibulkBuffer(c) != C_OK) <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            serverPanic(<span class="string">"Unknown request type"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 无参数，重置客户端</span></span><br><span class="line">        <span class="keyword">if</span> (c-&gt;argc == <span class="number">0</span>) &#123;</span><br><span class="line">            resetClient(c);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 执行命令</span></span><br><span class="line">            <span class="keyword">if</span> (processCommand(c) == C_OK) &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 处理完毕清空当前处理客户端</span></span><br><span class="line">    server.current_client = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>processInlineBuffer</code>与<code>processMultibulkBuffer</code>是用于命令解析的，如果解析成功则执行命令，否则，进入下一轮循环读取剩余Buffer。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 执行命令 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">processCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 处理quit命令</span></span><br><span class="line">    <span class="keyword">if</span> (!strcasecmp(c-&gt;argv[<span class="number">0</span>]-&gt;ptr,<span class="string">"quit"</span>)) &#123;</span><br><span class="line">        addReply(c,shared.ok);</span><br><span class="line">        c-&gt;flags |= CLIENT_CLOSE_AFTER_REPLY;</span><br><span class="line">        <span class="keyword">return</span> C_ERR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查询argv[0]对应的命令</span></span><br><span class="line">    c-&gt;cmd = c-&gt;lastcmd = lookupCommand(c-&gt;argv[<span class="number">0</span>]-&gt;ptr);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/* 此处忽略了命令执行前的条件判断，命令的执行受主从、持久化等问题的影响 */</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 开始执行命令 </span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_MULTI &amp;&amp;</span><br><span class="line">        c-&gt;cmd-&gt;proc != execCommand &amp;&amp; c-&gt;cmd-&gt;proc != discardCommand &amp;&amp;</span><br><span class="line">        c-&gt;cmd-&gt;proc != multiCommand &amp;&amp; c-&gt;cmd-&gt;proc != watchCommand)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// MULTI 开启事务，命令入队列</span></span><br><span class="line">        queueMultiCommand(c);</span><br><span class="line">        addReply(c,shared.queued);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 直接执行命令</span></span><br><span class="line">        call(c,CMD_CALL_FULL);</span><br><span class="line">        c-&gt;woff = server.master_repl_offset;</span><br><span class="line">        <span class="keyword">if</span> (listLength(server.ready_keys))</span><br><span class="line">            handleClientsBlockedOnKeys();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> C_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 命令入队列 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">queueMultiCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 申请空间</span></span><br><span class="line">    c-&gt;mstate.commands = zrealloc(c-&gt;mstate.commands,</span><br><span class="line">            <span class="keyword">sizeof</span>(multiCmd)*(c-&gt;mstate.count+<span class="number">1</span>));</span><br><span class="line">    <span class="comment">// 设置命令</span></span><br><span class="line">    mc = c-&gt;mstate.commands+c-&gt;mstate.count;</span><br><span class="line">    mc-&gt;cmd = c-&gt;cmd;</span><br><span class="line">    mc-&gt;argc = c-&gt;argc;</span><br><span class="line">    mc-&gt;argv = zmalloc(<span class="keyword">sizeof</span>(robj*)*c-&gt;argc);</span><br><span class="line">    <span class="built_in">memcpy</span>(mc-&gt;argv,c-&gt;argv,<span class="keyword">sizeof</span>(robj*)*c-&gt;argc);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>call</code>是在没有事务的情况下，直接执行，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 执行命令 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">call</span><span class="params">(client *c, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 通知监控</span></span><br><span class="line">    <span class="keyword">if</span> (listLength(server.monitors) &amp;&amp;</span><br><span class="line">        !server.loading &amp;&amp;</span><br><span class="line">        !(c-&gt;cmd-&gt;flags &amp; (CMD_SKIP_MONITOR|CMD_ADMIN)))</span><br><span class="line">    &#123;</span><br><span class="line">        replicationFeedMonitors(c,server.monitors,c-&gt;db-&gt;id,c-&gt;argv,c-&gt;argc);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 执行命令</span></span><br><span class="line">    c-&gt;cmd-&gt;proc(c);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 记录慢日志</span></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; CMD_CALL_SLOWLOG &amp;&amp; c-&gt;cmd-&gt;proc != execCommand) &#123;</span><br><span class="line">        <span class="keyword">char</span> *latency_event = (c-&gt;cmd-&gt;flags &amp; CMD_FAST) ?</span><br><span class="line">                              <span class="string">"fast-command"</span> : <span class="string">"command"</span>;</span><br><span class="line">        latencyAddSampleIfNeeded(latency_event,duration/<span class="number">1000</span>);</span><br><span class="line">        slowlogPushEntryIfNeeded(c,c-&gt;argv,c-&gt;argc,duration);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 传播命令</span></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; CMD_CALL_PROPAGATE &amp;&amp;</span><br><span class="line">        (c-&gt;flags &amp; CLIENT_PREVENT_PROP) != CLIENT_PREVENT_PROP)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> propagate_flags = PROPAGATE_NONE;</span><br><span class="line">        <span class="comment">// 传播命令到Slave和AOF</span></span><br><span class="line">        <span class="keyword">if</span> (dirty) propagate_flags |= (PROPAGATE_AOF|PROPAGATE_REPL);</span><br><span class="line">        <span class="comment">// 强制传播命令到Slaver和AOF</span></span><br><span class="line">        <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_FORCE_REPL) propagate_flags |= PROPAGATE_REPL;</span><br><span class="line">        <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_FORCE_AOF) propagate_flags |= PROPAGATE_AOF;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (propagate_flags != PROPAGATE_NONE &amp;&amp; !(c-&gt;cmd-&gt;flags &amp; CMD_MODULE))</span><br><span class="line">            <span class="comment">// 传播命令</span></span><br><span class="line">            propagate(c-&gt;cmd,c-&gt;db-&gt;id,c-&gt;argv,c-&gt;argc,propagate_flags);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 传播命令 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">propagate</span><span class="params">(struct redisCommand *cmd, <span class="keyword">int</span> dbid, robj **argv, <span class="keyword">int</span> argc,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 传播命令给AOF和Slaver</span></span><br><span class="line">    <span class="keyword">if</span> (server.aof_state != AOF_OFF &amp;&amp; flags &amp; PROPAGATE_AOF)</span><br><span class="line">        feedAppendOnlyFile(cmd,dbid,argv,argc);</span><br><span class="line">    <span class="keyword">if</span> (flags &amp; PROPAGATE_REPL)</span><br><span class="line">        replicationFeedSlaves(server.slaves,dbid,argv,argc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>写入</strong></p>
<p><img src="/images/redis-ae-7.png" alt=""></p>
<p><code>addReply</code>是用于给客户端返回执行结果，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 请求返回 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addReply</span><span class="params">(client *c, robj *obj)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断是否需要给客户端返回数据</span></span><br><span class="line">    <span class="keyword">if</span> (prepareClientToWrite(c) != C_OK) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sdsEncodedObject(obj)) &#123;</span><br><span class="line">        <span class="comment">// 尝试写入响应Buffer，Buffer无法存储的话写入响应链表</span></span><br><span class="line">        <span class="keyword">if</span> (_addReplyToBuffer(c,obj-&gt;ptr,sdslen(obj-&gt;ptr)) != C_OK)</span><br><span class="line">            _addReplyStringToList(c,obj-&gt;ptr,sdslen(obj-&gt;ptr));</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 判断是否需要给客户端返回数据*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prepareClientToWrite</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 过滤lua脚本</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; (CLIENT_LUA|CLIENT_MODULE)) <span class="keyword">return</span> C_OK;</span><br><span class="line">    <span class="comment">// 过滤不需要返回</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; (CLIENT_REPLY_OFF|CLIENT_REPLY_SKIP)) <span class="keyword">return</span> C_ERR;</span><br><span class="line">    <span class="comment">// 过滤主线程</span></span><br><span class="line">    <span class="keyword">if</span> ((c-&gt;flags &amp; CLIENT_MASTER) &amp;&amp;</span><br><span class="line">        !(c-&gt;flags &amp; CLIENT_MASTER_FORCE_REPLY)) <span class="keyword">return</span> C_ERR;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/* client加入回写队列*/</span></span><br><span class="line">    <span class="keyword">if</span> (!clientHasPendingReplies(c)) clientInstallWriteHandler(c);</span><br><span class="line">    <span class="keyword">return</span> C_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>clientInstallWriteHandler</code>是客户端回写处理器，它仅会把<code>写入命令缓存到写入队列</code>中，并<code>不会直接返回结果</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 把客户端加入等待回写队列 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clientInstallWriteHandler</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    c-&gt;flags |= CLIENT_PENDING_WRITE;</span><br><span class="line">    <span class="comment">// 加入到等待回写队列</span></span><br><span class="line">    listAddNodeHead(server.clients_pending_write,c);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时，Redis内部对客户端的请求处理完毕，还没有发现哪里完成了最后结果的写入。</p>
<blockquote>
<p>再回头看一下<code>beforeSleep</code>到底做了什么？</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 每次循环一次执行一次 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">beforeSleep</span><span class="params">(struct aeEventLoop *eventLoop)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// flush到AOF</span></span><br><span class="line">    flushAppendOnlyFile(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 处理等待回写的客户端</span></span><br><span class="line">    handleClientsWithPendingWrites();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 用于处理等待回复的客户端 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">handleClientsWithPendingWrites</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 循环遍历回写队列</span></span><br><span class="line">    listRewind(server.clients_pending_write,&amp;li);</span><br><span class="line">    <span class="keyword">while</span>((ln = listNext(&amp;li))) &#123;</span><br><span class="line">        <span class="comment">// 获取并移除客户端</span></span><br><span class="line">        client *c = listNodeValue(ln);</span><br><span class="line">        c-&gt;flags &amp;= ~CLIENT_PENDING_WRITE;</span><br><span class="line">        listDelNode(server.clients_pending_write,ln);</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 尝试向客户端回写数据</span></span><br><span class="line">        <span class="keyword">if</span> (writeToClient(c-&gt;fd,c,<span class="number">0</span>) == C_ERR) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 如果未完成回写数据，则注册异步回写事件</span></span><br><span class="line">        <span class="keyword">if</span> (clientHasPendingReplies(c)) &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">// 创建写入事件</span></span><br><span class="line">            <span class="keyword">if</span> (aeCreateFileEvent(server.el, c-&gt;fd, ae_flags,</span><br><span class="line">                <span class="comment">/* 回写客户端处理器 */</span></span><br><span class="line">                sendReplyToClient, c) == AE_ERR)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 回写客户端处理器 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sendReplyToClient</span><span class="params">(aeEventLoop *el, <span class="keyword">int</span> fd, <span class="keyword">void</span> *privdata, <span class="keyword">int</span> mask)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/* 尝试向客户端回写数据 */</span></span><br><span class="line">    writeToClient(fd,privdata,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/redis-ae-8.png" alt=""></p>
<p><code>writeToClient</code>是用于回写数据的处理函数，回写数据位于<code>client-&gt;bufpos</code>与<code>client-&gt;reply</code>，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 回写数据 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">writeToClient</span><span class="params">(<span class="keyword">int</span> fd, client *c, <span class="keyword">int</span> handler_installed)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 循环读取并回写数据</span></span><br><span class="line">    <span class="keyword">while</span>(clientHasPendingReplies(c)) &#123;</span><br><span class="line">        <span class="comment">// 1. 检查缓冲区并回写</span></span><br><span class="line">        <span class="keyword">if</span> (c-&gt;bufpos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 调用socket.write来写入数据</span></span><br><span class="line">            nwritten = write(fd,c-&gt;buf+c-&gt;sentlen,c-&gt;bufpos-c-&gt;sentlen);</span><br><span class="line">            ...</span><br><span class="line">        <span class="comment">// 2. 检查reply并回写</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            o = listNodeValue(listFirst(c-&gt;reply));</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">// 同上，写入数据</span></span><br><span class="line">            nwritten = write(fd, o-&gt;buf + c-&gt;sentlen, objlen - c-&gt;sentlen);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 当前节点写入完成后删除</span></span><br><span class="line">            <span class="keyword">if</span> (c-&gt;sentlen == objlen) &#123;</span><br><span class="line">                c-&gt;reply_bytes -= o-&gt;size;</span><br><span class="line">                listDelNode(c-&gt;reply,listFirst(c-&gt;reply));</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当回写字节数超过限制，则暂停回写退出（注册回写事件异步触发）</span></span><br><span class="line">        <span class="keyword">if</span> (totwritten &gt; NET_MAX_WRITES_PER_EVENT &amp;&amp;</span><br><span class="line">            (server.maxmemory == <span class="number">0</span> ||</span><br><span class="line">             zmalloc_used_memory() &lt; server.maxmemory) &amp;&amp;</span><br><span class="line">            !(c-&gt;flags &amp; CLIENT_SLAVE)) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> C_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在看下afterloop到底做了什么，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterSleep</span><span class="params">(struct aeEventLoop *eventLoop)</span> </span>&#123;</span><br><span class="line">    UNUSED(eventLoop);</span><br><span class="line">    <span class="comment">// 如果存在模块，则加全局锁</span></span><br><span class="line">    <span class="keyword">if</span> (moduleCount()) moduleAcquireGIL();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">moduleAcquireGIL</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;moduleGIL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>加全局锁的目的是<code>为了避免模块与Redis框架并发读写数据的问题</code>。</p>
<blockquote>
<p><code>call</code>命令会自动调用<code>addReply</code>进行数据的回写，</p>
</blockquote>
<p>以<code>set</code>命令为例，对应的函数为<code>setGenericCommand</code>，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setGenericCommand</span><span class="params">(redisClient *c, <span class="keyword">int</span> flags, robj *key,</span></span></span><br><span class="line"><span class="function"><span class="params">        robj *val, robj *expire, <span class="keyword">int</span> unit, robj *ok_reply,</span></span></span><br><span class="line"><span class="function"><span class="params">        robj *abort_reply)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//将键值关联到数据库</span></span><br><span class="line">    setKey(c-&gt;db,key,val);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 回写结果</span></span><br><span class="line">    addReply(c, ok_reply ? ok_reply : shared.ok);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    
	</div>
	
    
<nav id="article-nav">
  
    <a href="/2020/06/07/redis-ha/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Redis 高可用
        
      </div>
    </a>
  
  
    <a href="/2020/05/30/domain-driven-design/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">
        
          领域驱动设计的理解与实践
        
      </div>
    </a>
  
</nav>

  
</article>







</div>

    <!--/div-->
    <div class="mb-search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="Search">
    <input type="hidden" name="q" value="site:simyy.cn">
  </form>
</div>
<footer id="footer">
	<h1 class="footer-blog-title">
		<a href="/">simyy</a>
	</h1>
    &nbsp;&nbsp;
	<span class="copyright">
		&copy; 2022 simyy  Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
	</span>
</footer>

    

<script src="https://cdn.bootcss.com/jquery/2.1.3/jquery.min.js"></script>


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>
