<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[分布式事务]]></title>
      <url>/2017/05/20/distributed-transaction/</url>
      <content type="html"><![CDATA[<p>简单总结下分布式事务相关二段式、三段式提交以及Paxos算法。<br><a id="more"></a></p>
<h2 id="分布式系统的一致性"><a href="#分布式系统的一致性" class="headerlink" title="分布式系统的一致性"></a>分布式系统的一致性</h2><p>在分布式领域中，任何一个分布式系统都无法同时满足<code>一致性</code>、<code>可用性</code>和<code>容错性</code>（也就是CAP理论）。</p>
<p>一般来说系统权衡的结果是达到系统的<code>最终一致</code>，而非强一致性。</p>
<blockquote>
<p>分布式系统中数据不一致的问题？</p>
</blockquote>
<p>为了提高系统的整体性能，往往采用多机进行分布式部署，为了达到数据的同步必然存在着<code>数据复制</code>。但是数据复制在不同的数据节点之间由于网络等异常原因很容易造成数据不一致的情况。</p>
<h3 id="一致性模型"><a href="#一致性模型" class="headerlink" title="一致性模型"></a>一致性模型</h3><p>一致性模型可以分为三种：</p>
<ul>
<li><code>强一致性</code>：当更新操作完成后，任何后续操作访问的结果都是最新更新的值；</li>
<li><code>弱一致性</code>：当更新操作完成后，系统不保证后续操作访问的结构都一致，但会尽可能保证在某个时间点可以让数据达到一致；</li>
<li><code>最终一致性</code>：可以保证最终数据会达到一致。</li>
</ul>
<h2 id="二段式提交"><a href="#二段式提交" class="headerlink" title="二段式提交"></a>二段式提交</h2><p>二段式提交协议主要保证分布式事务的<code>原子性</code>（保证所有节点的操作一致），为了达到操作的一致引入了一个协调者来掌管所有节点。</p>
<p>二段式提交可以分为两个阶段：<code>准备阶段</code>和<code>提交阶段</code>。</p>
<p><code>准备阶段</code>：是一个投票的过程，步骤如下，</p>
<ul>
<li>协调者向所有节点询问是否提交操作，等带所有参与节点响应；</li>
<li>参与者执行询问发起为止的所有事务操作（已经执行了事务），并把是否执行信息写入日志；</li>
<li>各个参与者向协调者回复询问结果（如果执行成功返回同意，否则返回终止）。</li>
</ul>
<p><code>提交阶段</code>：是一个确认的过程，步骤如下，</p>
<ul>
<li>协调者接收到参与者的询问结果，如果包含终止结果，则需要对所有参与者发送回滚操作，否则向所有参与者发送提交命令；</li>
<li>参与者接受者接收到完成操作，释放整个事务期间占用的资源；</li>
<li>协调者接受到所有参与者完成操作，完成事务。</li>
</ul>
<blockquote>
<p>缺点？</p>
</blockquote>
<ul>
<li><code>同步阻塞</code>：所有参与者都是事务阻塞型的，当参与者占用公共资源时，其他节点在访问该公共资源的时候不得不阻塞等待。</li>
<li><code>单点故障</code>：协调者管理所有参与节点，如果协调者异常，参与者都会一直阻塞下去。</li>
<li><code>数据不一致</code>：对于提交阶段，如果协调者和参与者出现网络问题，参与者无法正常完成事务。</li>
</ul>
<h2 id="三段式提交"><a href="#三段式提交" class="headerlink" title="三段式提交"></a>三段式提交</h2><p><code>三段式提交</code>是二段式提交的改进版，主要不同在于：</p>
<ul>
<li>引入超时机制（协调者和参与者）</li>
<li>增加了一个询问阶段（但不会执行）</li>
</ul>
<p>三个阶段：</p>
<ul>
<li><code>can commit</code>：协调者询问参与者是否可以执行事务(投票)</li>
<li><code>pre commit</code>：执行事务，并返回执行结果</li>
<li><code>do commit</code>：提交事务，完成</li>
</ul>
<p>为了避免阻塞，在提交阶段，如果协调者没有接收到参与者的回应，会执行<code>终止事务</code>，另外，如果参与者一直没有接收到协调者的操作命令，那么就会直接提交事务，但是这并不会避免<code>数据不一致</code>的问题。</p>
<h2 id="Paxos算法"><a href="#Paxos算法" class="headerlink" title="Paxos算法"></a>Paxos算法</h2><p><a href="http://www.csdn.net/article/2014-01-20/2818197-distributed-system/2" target="_blank" rel="external">http://www.csdn.net/article/2014-01-20/2818197-distributed-system/2</a></p>
]]></content>
      
        <categories>
            
            <category> 分布式 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 分布式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[java threadlocal]]></title>
      <url>/2017/04/16/java-threadlocal/</url>
      <content type="html"><![CDATA[<p>介绍java中threadlocal的使用方法。<br><a id="more"></a></p>
<h2 id="threadlocal"><a href="#threadlocal" class="headerlink" title="threadlocal"></a>threadlocal</h2><p><code>threadlocal</code>主要解决的是每个线程绑定自己的值，也就是说保证相同变量在不同线程的<code>隔离性</code>。</p>
<p><code>threadlocal</code>保证每一个使用该变量的线程都提供一个变量值得副本，每一个副本的改动不会影响其他副本的值。</p>
<h2 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h2><p>默认情况下，初始化的<code>threadlocal</code>值为<code>null</code>，通过继承<code>threadlocal</code>并重写<code>initialValue</code>实现覆盖初始值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadLocal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal1</span> <span class="keyword">extends</span> <span class="title">ThreadLocal</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Object <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"default value"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ThreadLocal1 t1 = <span class="keyword">new</span> ThreadLocal1();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="SimpleDateFormat安全格式化"><a href="#SimpleDateFormat安全格式化" class="headerlink" title="SimpleDateFormat安全格式化"></a>SimpleDateFormat安全格式化</h2><p><code>SimpleDateFormat</code>类是用来对日期字符串进行解析和格式化输出。</p>
<p><code>DateFormat</code>和<code>SimpleDateFormat</code>类不都是线程安全的，在多线程环境下调用<code>format</code>和<code>parse</code>方法应该使用同步代码来避免问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DateUtil</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用静态变量来存储SimpleDateFormat</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  String <span class="title">formatDate</span><span class="params">(Date date)</span> <span class="keyword">throws</span> ParseException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sdf.format(date);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Date <span class="title">parse</span><span class="params">(String strDate)</span> <span class="keyword">throws</span> ParseException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sdf.parse(strDate);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSimpleDateFormatThreadSafe</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.join(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e1) &#123;</span><br><span class="line">                e1.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="keyword">this</span>.getName()+<span class="string">":"</span>+DateUtil.parse(<span class="string">"2013-05-24 06:02:20"</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">new</span> TestSimpleDateFormatThreadSafe().start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;Thread-1&quot; Exception in thread &quot;Thread-2&quot; java.lang.NumberFormatException: multiple points</span><br><span class="line">	at sun.misc.FloatingDecimal.readJavaFormatString(FloatingDecimal.java:1890)</span><br><span class="line">Thread-0:Fri May 24 06:02:20 CST 2013</span><br><span class="line">	at sun.misc.FloatingDecimal.parseDouble(FloatingDecimal.java:110)</span><br><span class="line">	at java.lang.Double.parseDouble(Double.java:538)</span><br><span class="line">	at java.text.DigitList.getDouble(DigitList.java:169)</span><br><span class="line">	at java.text.DecimalFormat.parse(DecimalFormat.java:2056)</span><br><span class="line">	at java.text.SimpleDateFormat.subParse(SimpleDateFormat.java:1869)</span><br><span class="line">	at java.text.SimpleDateFormat.parse(SimpleDateFormat.java:1514)</span><br><span class="line">	at java.text.DateFormat.parse(DateFormat.java:364)</span><br><span class="line">	at MyThreadLocal$DateUtil.parse(MyThreadLocal.java:28)</span><br><span class="line">	at MyThreadLocal$TestSimpleDateFormatThreadSafe.run(MyThreadLocal.java:42)</span><br></pre></td></tr></table></figure></p>
<p>这正是由于<code>非线程安全的SimpleDateFormat</code>造成的（<a href="http://www.cnblogs.com/peida/archive/2013/05/31/3070790.html" target="_blank" rel="external">详情</a>）。</p>
<p><strong>推荐方法</strong>：使用<code>threadlocal</code>对不同线程使用不同的<code>SimpleDateFormat</code>对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalDateUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String date_format = <span class="string">"yyyy-MM-dd HH:mm:ss"</span>;</span><br><span class="line">    <span class="comment">// 使用threadlocal来为不同线程生成相同参数的不同副本</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;DateFormat&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;DateFormat&gt;(); </span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DateFormat <span class="title">getDateFormat</span><span class="params">()</span>   </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        DateFormat df = threadLocal.get();  </span><br><span class="line">        <span class="comment">// 默认值为null, 可以继承threadlocal重写initialValue来实现默认值</span></span><br><span class="line">        <span class="keyword">if</span>(df==<span class="keyword">null</span>)&#123;  </span><br><span class="line">            df = <span class="keyword">new</span> SimpleDateFormat(date_format);  </span><br><span class="line">            threadLocal.set(df);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> df;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">formatDate</span><span class="params">(Date date)</span> <span class="keyword">throws</span> ParseException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getDateFormat().format(date);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Date <span class="title">parse</span><span class="params">(String strDate)</span> <span class="keyword">throws</span> ParseException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getDateFormat().parse(strDate);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h2><p><code>ThreadLocal</code>有一个<code>ThreadLocalMap</code>静态内部类，这个<code>Map</code>为每个线程复制一个变量的<code>拷贝</code>，每一个内部线程都有一个<code>ThreadLocalMap</code>对象。</p>
<p>当线程调用<code>ThreadLocal.set(T object)</code>方法设置变量时，</p>
<ul>
<li><p>获取当前<code>线程引用</code>，</p>
</li>
<li><p>获取线程内部的<code>ThreadLocalMap</code>对象</p>
</li>
<li><p>设置<code>map</code>的<code>key</code>值为<code>threadLocal</code>对象，<code>value</code>为参数中的<code>object</code></p>
</li>
</ul>
<p>当线程调用<code>ThreadLocal.get()</code>方法获取变量时，</p>
<ul>
<li><p>获取当前<code>线程引用</code></p>
</li>
<li><p>以<code>threadLocal</code>对象为<code>key</code>去获取响应的<code>ThreadLocalMap</code>，</p>
</li>
<li><p>如果此<code>Map</code>不存在则初始化一个，否则返回其中的变量</p>
</li>
</ul>
<p>每个线程内部的<code>ThreadLocalMap</code>对象中的<code>key</code>保存的<code>threadLocal</code>对象的引用，但对<code>threadLocal</code>的对象的引用是<code>WeakReference弱引用</code>。</p>
<blockquote>
<p><code>ThreadLocalMap</code>是使用<code>ThreadLocal的弱引用</code>作为<code>Key</code>的，弱引用的对象在 <code>GC</code> 时会被回收。</p>
</blockquote>
<p>对于一个正常的<code>Map</code>来说，调用<code>Map.clear</code>方法来清空<code>map</code>，所有对象就会释放。调用<code>map.remove(key)</code>方法，会移除<code>key</code>对应的对象整个<code>entry</code>，这样key和value 就不会任何对象引用，被<code>java</code>虚拟机回收。</p>
<blockquote>
<p>内存泄露的原因？</p>
</blockquote>
<p><code>Thread</code>对象里面的<code>ThreadLocalMap</code>中的<code>key</code>是<code>ThreadLocal</code>的对象的<code>弱引用</code>，如果<code>ThreadLocal</code>对象会回收，那个这个对象对应的<code>key</code>就会变为<code>null</code>，那么<code>ThreadLocalMap</code>就无法移除其对应的<code>value</code>，那么<code>value</code>对象就无法被回收，导致<code>内存泄露</code>。</p>
<p>但是如果<code>Thread</code>运行结束，整个线程对象被回收，那么<code>value</code>所引用的对象也就会被垃圾回收。</p>
<p>对于没有使用<code>线程池</code>的方法来说，因为每次线程运行完就退出了，<code>Map</code>里面引用的所有对象都会被垃圾回收，所以没有关系。</p>
<blockquote>
<p>如何避免？</p>
</blockquote>
<p><code>ThreadLocalMap</code>的设计中已经考虑到这种情况，也加上了一些防护措施：在<code>ThreadLocal</code>的<code>get()</code>,<code>set()</code>,<code>remove()</code>的时候都会清除线程<code>ThreadLocalMap</code>里所有<code>key</code>为<code>null</code>的<code>value</code>。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.cnblogs.com/peida/archive/2013/05/31/3070790.html" target="_blank" rel="external">http://www.cnblogs.com/peida/archive/2013/05/31/3070790.html</a><br><a href="http://blog.xiaohansong.com/2016/08/06/ThreadLocal-memory-leak/?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="external">http://blog.xiaohansong.com/2016/08/06/ThreadLocal-memory-leak/?utm_source=tuicool&amp;utm_medium=referral</a></p>
]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[java 多线程]]></title>
      <url>/2017/04/12/java-thread/</url>
      <content type="html"><![CDATA[<p>介绍java中多线程。<br><a id="more"></a></p>
<h2 id="Runnable-amp-Thread"><a href="#Runnable-amp-Thread" class="headerlink" title="Runnable &amp; Thread"></a>Runnable &amp; Thread</h2><p><code>Thread</code>类中的<code>start</code>方法通知<code>线程规划器</code>此线程已经就绪，等待调用线程对象的<code>run</code>方法。</p>
<p>使用<code>run</code>方法是同步的，此线程对象并不会交给<code>线程规划器</code>来进行处理，而是由当前主线程来同步执行。</p>
<p>使用<code>start</code>方法是同步的，但系统调用<code>run</code>方法的过程是异步执行，因此线程执行与<code>start</code>的顺序是不一致的。</p>
<p><code>java</code>不支持多继承，对于已有父类的继承类来说，需要实现<code>Runnable</code>接口来实现线程类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableHello</span> <span class="keyword">extends</span> <span class="title">MyHello</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    RunnableHello runnableHello = <span class="keyword">new</span> RunnableHello();</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(runnableHello);</span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><p><code>synchronized</code>关键字能够保证在同一时刻最多只有一个线程执行该段代码。</p>
<p><code>synchronized</code>可用于标记<code>对象</code>、<code>代码块</code>、<code>函数</code>等。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">synchronized(someObj) &#123; // dosomething &#125;</span><br><span class="line">sychronized(this) &#123; // dosomething&#125;</span><br><span class="line">synchronized public void method() &#123; // dosomething &#125;</span><br></pre></td></tr></table></figure>
<h2 id="interrupt"><a href="#interrupt" class="headerlink" title="interrupt"></a>interrupt</h2><p><code>interrupt</code>：用于停止当前线程，不会立刻停止，而是先给当前线程打一个中断标记。</p>
<p><code>interrupted</code>：测试当前线程是否已经中断状态，执行后清除状态标识为<code>false</code>。</p>
<p><code>isInterrupted</code>：测试当前线程是否已经中断状态，不清除状态标识。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 观察打印结果</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtendsThread1</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.isInterrupted()) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"interrupted"</span>);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ExtendsThread1 thread1 = <span class="keyword">new</span> ExtendsThread1();</span><br><span class="line">    thread1.start();</span><br><span class="line">    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    thread1.interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="suspend"><a href="#suspend" class="headerlink" title="suspend"></a>suspend</h2><p><code>suspend</code>用于暂停线程，但已经<code>废弃</code>了。</p>
<blockquote>
<p><code>废弃原因</code>：使用suspend和resume方法容易因为线程暂定导致数据不同步的情况，会造成死锁。</p>
</blockquote>
<h2 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h2><p><code>yeild</code>用于放弃当前占用的<code>CPU</code>资源，但放弃的时间不确定，下一次获得<code>CPU</code>的占用权的时间同样不能确定。</p>
<p><code>yeild</code>特性：</p>
<ul>
<li>静态的原生(<code>native</code>)方法；</li>
<li>状态切换的<code>非实时性</code>；</li>
<li>当前正在执行的线程把运行机会交给线程池中拥有<code>相同优先级</code>的线程；</li>
<li>它仅能使一个线程从运行状态转到<code>可运行状态</code>，而不是等待或阻塞状态。</li>
</ul>
<h2 id="priority"><a href="#priority" class="headerlink" title="priority"></a>priority</h2><p><code>setPriority</code>方法可以用来设置线程的优先级，优先级高的线程更容易获得<code>CPU的执行权</code>。</p>
<p><code>java</code>中线程优先级分为1~10，默认定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public final static int MIN_PRIORITY = 1;</span><br><span class="line">public final static int NORM_PRIORITY = 5;</span><br><span class="line">public final static int MAX_PRIORITY = 10;</span><br></pre></td></tr></table></figure></p>
<p>线程的优先级是<code>可继承的</code>。</p>
<h2 id="daemon"><a href="#daemon" class="headerlink" title="daemon"></a>daemon</h2><p><code>java</code>中可以通过<code>setDaemon</code>方法设置<code>守护线程</code>。</p>
<blockquote>
<p><code>守护线程</code>是一种特殊的线程，只有当JVM停止运行时，该线程才会被结束。例如，垃圾回收器就是一个用于回收内存对象的<code>守护线程</code>。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[java 异常]]></title>
      <url>/2017/04/08/java-exception/</url>
      <content type="html"><![CDATA[<p>介绍java中的异常处理。<br><a id="more"></a></p>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p><code>java</code>中的异常可分为<code>检查的异常</code>和<code>非检查异常</code>。</p>
<p>在<code>java</code>中，异常的类层次结构如下，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">           Throwable</span><br><span class="line">         /          \</span><br><span class="line">    Error            Exception</span><br><span class="line">    /   \           /         \</span><br><span class="line">VMError AWTError  IOException  RuntimeException</span><br></pre></td></tr></table></figure></p>
<p>所有异常都是继承自<code>Throwable</code>，分为<code>Error</code>和<code>Exception</code>。</p>
<p><code>Error</code>一般是<code>JVM</code>问题导致，也就是说在应用程序控制和处理之外产生的，因此此类异常是<code>不可检查的</code>。</p>
<p><code>Exception</code>是程序自身产生的异常，是可以通过<code>try-catch</code>和<code>throws</code>来控制。</p>
<p><code>Exception</code>可被划分为非检查的<code>RuntimeException</code>和检查的<code>IOException</code>。</p>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><h3 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h3><p>在<code>java</code>中可以用<code>try-catch</code>语句来捕获异常（可捕获检查和非检查异常），<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">try &#123;  </span><br><span class="line">    // 可能会发生异常的程序代码  </span><br><span class="line">&#125; catch (Type1 id1)&#123;  </span><br><span class="line">    // 捕获并处置try抛出的异常类型Type1  </span><br><span class="line">&#125; catch (Type2 id2)&#123;  </span><br><span class="line">    // 捕获并处置try抛出的异常类型Type2  </span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    // 无论是否发生异常需要处理</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>异常是按照<code>catch</code>的顺序依次捕获的，所以需要按照继承关系来决定捕获顺序。</p>
<blockquote>
<p><code>finally</code>一般用来关闭一下IO操作，例如文件、网络连接。</p>
</blockquote>
<h2 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h2><p>在<code>java</code>中可以使用<code>throws</code>来抛出异常，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void method() throws Exception1, Exception2, ... &#123;</span><br><span class="line">    // 执行</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="throwable"><a href="#throwable" class="headerlink" title="throwable"></a>throwable</h2><p><code>throwable</code>作为异常处理的基类，常用的功能函数有,<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">getCause(); <span class="comment">// 获取异常原因</span></span><br><span class="line">getMessage(); <span class="comment">// 异常信息</span></span><br><span class="line">printStackTrace(); <span class="comment">// 堆栈跟踪异常信息</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注意：<code>RuntimeException</code>不需要抛出，并不会造成编译错误。</p>
</blockquote>
<h2 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h2><p>通过继承<code>Exception</code>以及其子类可以实现自定义异常，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class MyException extends Exception &#123;</span><br><span class="line">    public MyException() &#123;&#125;</span><br><span class="line">    public MyException(String message) &#123;</span><br><span class="line">        super(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>由于继承<code>Exception</code>，则需要接口处理该异常时添加<code>throws</code>指明抛出检查异常，否则无法编译通过。</p>
<p>如果是继承<code>RuntimeException</code>，则不需要指定<code>throws</code>抛出异常，但是需要注意外层对于该异常的处理方法，这种异常会被隐藏起来。</p>
<blockquote>
<p>如何选择异常类型，<code>检查</code> or <code>非检查</code>？</p>
</blockquote>
<p>设计异常一般有两种，内部使用和外部使用。</p>
<p>对于外部使用，也就是提供给调用方来处理的异常，一般是由于服务中依赖某不稳定的服务，提供服务方不能处理该异常，需要调用方自行处理该异常情况。</p>
<p>对于内部使用，也就是程序内部自定义的异常，一般是由于跳出当前逻辑处理，直接返回，那么，就需要在逻辑的最外层来统一处理该自定义异常。</p>
<h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><p>在使用异常来做控制流程处理的时候，一般有两种方式：<code>自定义异常</code>和<code>自定义返回结果</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 自定义异常</span><br><span class="line">class BizException extends RuntimeException &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">// 自定义返回结果</span><br><span class="line">class BizResult&lt;T&gt; extends ObjectInfo &#123; ... &#125;</span><br></pre></td></tr></table></figure></p>
<p>如果使用<code>自定义返回结果</code>，需要在每次调用函数时使用<code>if-else</code>来做判断，这样性能必然是<code>最好的</code>，但是在写业务逻辑的时候就会非常繁琐，每次调用都会添加一次<code>if-else</code>逻辑。</p>
<p>如果使用<code>自定义异常</code>，需要在调用服务的最外层都添加一个针对<code>自定义异常</code>的异常处理，业务逻辑看起来好一点，但是这样性能就会差一点。</p>
<blockquote>
<p>如何提高异常性能？</p>
</blockquote>
<p>在参考中的一篇文章中，有提到通过重写<code>fillInStackTrace</code>来提高性能，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public synchronized Throwable fillInStackTrace() &#123;</span><br><span class="line">    if (stackTrace != null ||</span><br><span class="line">        backtrace != null /* Out of protocol state */ ) &#123;</span><br><span class="line">        fillInStackTrace(0);</span><br><span class="line">        stackTrace = UNASSIGNED_STACK;</span><br><span class="line">    &#125;</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>fillInStackTrace</code>函数是一个同步的方法，在多线程的情况下必然会造成性能下降。在测试过程中发现，即使在单线程的情况下，仍然可以提升很大性能。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://niehan.blog.techweb.com.cn/archives/259.html" target="_blank" rel="external">http://niehan.blog.techweb.com.cn/archives/259.html</a><br><a href="http://blog.csdn.net/beijiguangyong/article/details/9080727" target="_blank" rel="external">http://blog.csdn.net/beijiguangyong/article/details/9080727</a><br><a href="http://www.blogjava.net/stone2083/archive/2010/07/09/325649.html" target="_blank" rel="external">http://www.blogjava.net/stone2083/archive/2010/07/09/325649.html</a></p>
]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[java 日志注解]]></title>
      <url>/2017/04/08/java-anotion-log/</url>
      <content type="html"><![CDATA[<p>介绍如何使用java注解来添加日志。<br><a id="more"></a></p>
<h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><p><code>元注解</code>的作用是注解其他注解，</p>
<ul>
<li><p><code>@Target</code>用于描述注解范围。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CONSTRUCTOR:用于描述构造器</span><br><span class="line">FIELD:用于描述域</span><br><span class="line">LOCAL_VARIABLE:用于描述局部变量</span><br><span class="line">METHOD:用于描述方法</span><br><span class="line">PACKAGE:用于描述包</span><br><span class="line">PARAMETER:用于描述参数</span><br><span class="line">TYPE:用于描述类、接口(包括注解类型) 或enum声明</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>@Retention</code>用于描述注解生命周期。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SOURCE:在源文件中有效（即源文件保留）</span><br><span class="line">CLASS:在class文件中有效（即class保留）</span><br><span class="line">RUNTIME:在运行时有效（即运行时保留），可以通过反射获取该注解的属性值</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>@Documented</code>用于生命构建注解文档。</p>
</li>
<li><code>@Inherited</code>用于描述该注解是可被子类继承的。</li>
</ul>
<h3 id="注解格式"><a href="#注解格式" class="headerlink" title="注解格式"></a>注解格式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public @interface 注解名 &#123;定义体&#125;</span><br></pre></td></tr></table></figure>
<h2 id="日志注解"><a href="#日志注解" class="headerlink" title="日志注解"></a>日志注解</h2><p><code>Log</code>注解定义，参数包含<code>type</code>日志类型、<code>desc</code>日志描述、<code>throwable</code>是否catch异常、<code>withResult</code>是否记录打印结果。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(&#123; ElementType.METHOD, ElementType.PARAMETER &#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Log &#123;</span><br><span class="line">    <span class="function">String <span class="title">type</span><span class="params">()</span> <span class="keyword">default</span> LogConst.RUN_LOG</span>; </span><br><span class="line">    <span class="function">String <span class="title">desc</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">throwable</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">withResult</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>需要注意，注解的默认值必须是常量（不可以设置为枚举）</p>
</blockquote>
<p>那么常量如何定义？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogConst</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 日志类型</span></span><br><span class="line">    <span class="comment">/* 访问日志 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String ACCESS_LOG = <span class="string">"ACCESS"</span>;</span><br><span class="line">    <span class="comment">/* 事件日志 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String EVENT_LOG = <span class="string">"EVENT"</span>;</span><br><span class="line">    <span class="comment">/* 运行日志 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String RUN_LOG = <span class="string">"RUN"</span>;</span><br><span class="line">    <span class="comment">/* 异常日志 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String EXCP_LOG = <span class="string">"EXCEPTION"</span>;</span><br></pre></td></tr></table></figure></p>
<p>开启注解和<code>AOP配置</code>，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;context:annotation-config/&gt;</span><br><span class="line">&lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot;/&gt;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>在注解中其实还可以做更多的事？在注解中我们可以增加异常监控，增加事件数量监控等等。</p>
</blockquote>
<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p>通过切片来获取当前获取被注释执行的函数情况，这里使用<code>aroundExec</code>来实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Aspect</span><br><span class="line">@Component</span><br><span class="line">public class LogAop &#123;</span><br><span class="line">@Around(value = &quot;@annotation(com.simyy.web.aop.Log)&quot;)</span><br><span class="line">public Object aroundExec(ProceedingJoinPoint pjp) throws Throwable &#123;</span><br><span class="line">    Method method = ((MethodSignature) pjp.getSignature()).getMethod();</span><br><span class="line">    String logType = method.getAnnotation(Log.class).type();</span><br><span class="line">    boolean throwable = method.getAnnotation(Log.class).throwable();</span><br><span class="line">    boolean withResult = method.getAnnotation(Log.class).withResult();</span><br><span class="line">    // 设置过无允许抛出异常或设置日志类型为异常日志</span><br><span class="line">    if (throwable == false || logType.equals(LogConst.EXCP_LOG)) &#123;</span><br><span class="line">        return withoutExpProcess(pjp, logType , withResult);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return withExpProcess(pjp, logType , withResult);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于异常日志处理方式就是通过增加<code>try-catch</code>来捕获并记录日常情况。<br>其中，<code>getEmptyObjectByClassType</code>是用于在捕获异常后返回空对象或失败对象，<code>getContentByType</code>是用于按固定格式打印日志记录的函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">private Object withoutExpProcess(ProceedingJoinPoint pjp, String logType, boolean withResult) throws Throwable &#123;</span><br><span class="line">    Object[] args = pjp.getArgs();</span><br><span class="line">    Method method = ((MethodSignature) pjp.getSignature()).getMethod();</span><br><span class="line">    Class returnType = ((MethodSignature) pjp.getSignature()).getReturnType();</span><br><span class="line"></span><br><span class="line">    Long start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    Object retVal;</span><br><span class="line">    Exception exp = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        retVal = pjp.proceed();</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        retVal = getEmptyObjectByClassType(returnType);</span><br><span class="line">        exp = e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (exp == null) &#123;</span><br><span class="line">        // 异常日志类型不需要捕获正常运行记录，因此直接返回</span><br><span class="line">        if (logType.equals(LogConst.EXCP_LOG)) &#123;</span><br><span class="line">            return retVal;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Long useTime = System.currentTimeMillis() - start;</span><br><span class="line">        String afterLog;</span><br><span class="line">        if (withResult == true) &#123;</span><br><span class="line">            afterLog = getContentByType(AFTER_WITH_RESULT, method, args, useTime, retVal);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            afterLog = getContentByType(AFTER, method, args, useTime, retVal);</span><br><span class="line">        &#125;</span><br><span class="line">        LOGGER.info(afterLog);</span><br><span class="line"></span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        String errorLog = getContentByType(ERROR, method, args, null, null);</span><br><span class="line">        LOGGER.error(errorLog, exp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return retVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>相反，对于不需要捕获异常的运行日志，只需要记录访问情况，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private Object withExpProcess(ProceedingJoinPoint pjp, String logType, boolean withResult) throws Throwable &#123;</span><br><span class="line">    Object[] args = pjp.getArgs();</span><br><span class="line">    Method method = ((MethodSignature) pjp.getSignature()).getMethod();</span><br><span class="line">    Class returnType = ((MethodSignature) pjp.getSignature()).getReturnType();</span><br><span class="line"></span><br><span class="line">    Long start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    String beforeLog = getContentByType(BEFORE, method, args, null, null);</span><br><span class="line">    LOGGER.info(beforeLog);</span><br><span class="line"></span><br><span class="line">    Object retVal = pjp.proceed();</span><br><span class="line"></span><br><span class="line">    Long useTime = System.currentTimeMillis() - start;</span><br><span class="line">    if (withResult == true) &#123;</span><br><span class="line">        String afterLog = getContentByType(AFTER_WITH_RESULT, method, args, useTime, retVal);</span><br><span class="line">        LOGGER.info(afterLog);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return retVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>用于返回空对象的函数,<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">private Object getEmptyObjectByClassType(Class classType) &#123;</span><br><span class="line">    if (classType.equals(List.class)) &#123;</span><br><span class="line">        return Collections.EMPTY_LIST;</span><br><span class="line">    &#125;</span><br><span class="line">    if (classType.equals(Map.class)) &#123;</span><br><span class="line">        return Collections.EMPTY_MAP;</span><br><span class="line">    &#125;</span><br><span class="line">    if (classType.equals(Set.class)) &#123;</span><br><span class="line">        return Collections.EMPTY_SET;</span><br><span class="line">    &#125;</span><br><span class="line">    if (classType.equals(boolean.class) || classType.equals(Boolean.class)) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    // 对于特殊的执行result对象需要特殊处理</span><br><span class="line">    // do somethind</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>定义日志打印格式用于<code>getContentByType</code>函数，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private final String BEFORE_TMPL = &quot;TYPE=[%s] DESC=[%s] METHOD=[%s] PARAMS=[%s]&quot;;</span><br><span class="line">private final String AFTER_TMPL = &quot;TYPE=[%s] DESC=[%s] METHOD=[%s] PARAMS=[%s] TIME=[%d ms]&quot;;</span><br><span class="line">private final String AFTER_TMPL_WITH_RESULT = &quot;TYPE=[%s] DESC=[%s] METHOD=[%s] PARAMS=[%s] TIME=[%d ms] RESULT=[%s]&quot;;</span><br><span class="line">private final String ERROR_TMPL = BEFORE_TMPL;</span><br><span class="line"></span><br><span class="line">// 获取当前类名+函数名称</span><br><span class="line">private String getClassAndMethodName(Method method) &#123;</span><br><span class="line">    String methodName = method.getName();</span><br><span class="line">    String className = method.getDeclaringClass().getSimpleName();</span><br><span class="line">    return className + &quot;.&quot; + methodName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="More"><a href="#More" class="headerlink" title="More"></a>More</h2><p>日志采用<code>异步</code>打印提高性能；<br>增加异常监控或重要事件处理<code>监控方案</code>；<br>毕竟反射还是带来一定的<code>性能损耗</code>。<br>对于异常error的代码行这样会丢失，那可以通过<code>Throable.getStackTrace()</code>方法获取运行栈进行分析获取需要的错误行和错误原因。</p>
]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[python 定时任务]]></title>
      <url>/2017/04/03/schedule/</url>
      <content type="html"><![CDATA[<p>介绍python中实现定时任务的几种方式。<br><a id="more"></a></p>
<h2 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h2><p><code>Timer</code>是<code>threading</code>提供的一个阻塞函数，用于延迟执行任务。<br>为了利用<code>Timer</code>实现定时任务，需要使用一个<code>递归</code>来实现，如下<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Timer</span><br><span class="line"></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ding</span><span class="params">(period)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> i</span><br><span class="line">    <span class="keyword">print</span> i,  datetime.now().strftime(<span class="string">"%Y-%m-%d %H:%M:%S"</span>)</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line">    t = Timer(period, ding,  (period,))</span><br><span class="line">    t.start()</span><br><span class="line"></span><br><span class="line">ding(<span class="number">3</span>)</span><br></pre></td></tr></table></figure></p>
<h2 id="sched"><a href="#sched" class="headerlink" title="sched"></a>sched</h2><p><code>sched</code>是<code>Python</code>内置的一个调度模块（<a href="https://docs.python.org/2/library/sched.html" target="_blank" rel="external">详情</a>）。<br>创建调度任务：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sched.scheduler(timefunc, delayfunc)</span><br><span class="line"><span class="comment"># timefunc, delayfunc延迟等待指定的函数</span></span><br></pre></td></tr></table></figure></p>
<p><code>sched</code>使用<code>调度队列</code>来管理调度任务，<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 调度任务队列，用来存储未执行的任务</span></span><br><span class="line">scheduler.queue</span><br><span class="line"><span class="comment"># 调度任务队列是否为空</span></span><br><span class="line">scheduler.empty()</span><br><span class="line"><span class="comment"># 执行调度任务</span></span><br><span class="line">scheduler.run()</span><br><span class="line"><span class="comment"># 增加任务，向任务队列中增加任务</span></span><br><span class="line"><span class="comment"># delay延迟时间/priority优先级/action执行函数/argument函数参数</span></span><br><span class="line">scheduler.enter(delay, priority, action, argument)</span><br><span class="line"><span class="comment"># 取消任务，从任务队列中删除任务</span></span><br><span class="line">scheduler.cancel(event)</span><br></pre></td></tr></table></figure></p>
<p>实例，需要注意如果使用<code>delayfunc</code>中包含延时功能，当延时时间大于任务延时时间）可能会增大延时时间。<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> sched</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">schedule = sched.scheduler(time.time, time.sleep)</span><br><span class="line"></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ding</span><span class="params">(period)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> i</span><br><span class="line">    <span class="keyword">print</span> i, datetime.now().strftime(<span class="string">"%Y-%m-%d %H:%M:%S"</span>)</span><br><span class="line">    schedule.enter(period, <span class="number">0</span>, ding, (period,))</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(period=<span class="number">3</span>)</span>:</span></span><br><span class="line">    schedule.enter(<span class="number">0</span>, <span class="number">0</span>, ding, (period,))</span><br><span class="line">    schedule.run()</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure></p>
<h2 id="apscheduler"><a href="#apscheduler" class="headerlink" title="apscheduler"></a>apscheduler</h2><p><code>apscheduler</code>是一个<code>Python</code>定时任务框架，全称<code>Advanced Python Scheduler</code>（<a href="http://apscheduler.readthedocs.io/en/latest/userguide.html#scheduler-events" target="_blank" rel="external">文档</a>）。</p>
<h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><p><code>triggers</code>是用于启动调度逻辑的触发器，每一个任务都拥有自己的触发器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">特定日期`date`、固定间隔`interval`、特定时间定时`cron`</span><br></pre></td></tr></table></figure></p>
<p><code>job stores</code>是用来存储调度任务，可选内存、缓存、数据库作为存储媒介。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MemoryJobStore内存存储(默认)</span><br><span class="line">MongoDBJobStore数据库存储</span><br><span class="line">SQLAlchemyJobStore数据库存储</span><br></pre></td></tr></table></figure></p>
<p><code>executors</code>是用来执行调度任务的，可使用线程或进程池作为执行器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor线程池执行器(默认)</span><br><span class="line">ProcessPoolExecutor进程池执行器</span><br></pre></td></tr></table></figure></p>
<p><code>scheduler</code>主要是用于选择阻塞、异步模型，提供了<code>gevent</code>、<code>Tornador</code>等框架的支持。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BlockingScheduler：阻塞式；</span><br><span class="line">BackgroundScheduler：用于后台执行（需要保证主线程运行，否则关闭）；</span><br><span class="line">AsyncIOScheduler：用于异步IO；</span><br><span class="line">GeventScheduler: 用于gevent；</span><br><span class="line">TornadoScheduler: 用于Tornador;</span><br><span class="line">TwistedScheduler: 用于Twisted;</span><br><span class="line">QtScheduler: 用于Qt;</span><br></pre></td></tr></table></figure></p>
<h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p><code>例1</code>中选择了阻塞调度器<code>BlockingScheduler</code>，并通过设置间隔执行<code>interval</code>，<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 例1</span></span><br><span class="line"><span class="keyword">from</span> apscheduler.schedulers.blocking <span class="keyword">import</span> BlockingScheduler</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ding</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> i</span><br><span class="line">    <span class="keyword">print</span> i, datetime.now().strftime(<span class="string">"%Y-%m-%d %H:%M:%S"</span>)</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">scheduler = BlockingScheduler()</span><br><span class="line">scheduler.add_job(ding, <span class="string">'interval'</span>, seconds=<span class="number">3</span>)</span><br><span class="line">scheduler.start()</span><br></pre></td></tr></table></figure></p>
<p><code>例12</code>中选择了后台调度器<code>BackgroundScheduler</code>，增加两个任务分别使用<code>interval</code>和<code>cron</code>来设置触发器，<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 例2</span></span><br><span class="line"><span class="keyword">from</span> apscheduler.schedulers.background <span class="keyword">import</span> BackgroundScheduler</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ding</span><span class="params">(name)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> i</span><br><span class="line">    <span class="keyword">print</span> i, name, datetime.now().strftime(<span class="string">"%Y-%m-%d %H:%M:%S"</span>)</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">scheduler = BackgroundScheduler()</span><br><span class="line">scheduler.add_job(ding, <span class="string">'interval'</span>, seconds=<span class="number">3</span>, args=(<span class="string">'interval'</span>,))</span><br><span class="line">scheduler.add_job(ding, <span class="string">'cron'</span>, second=<span class="string">'*/1'</span>, args=(<span class="string">'cron'</span>,))</span><br><span class="line">scheduler.start()</span><br><span class="line"><span class="keyword">print</span> <span class="string">'background scheduler start ... sleep'</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">time.sleep(<span class="number">10</span>)</span><br></pre></td></tr></table></figure></p>
<p>更多复杂的<a href="http://apscheduler.readthedocs.io/en/latest/userguide.html#code-examples" target="_blank" rel="external">例子…</a></p>
]]></content>
      
        <categories>
            
            <category> python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[java object]]></title>
      <url>/2017/03/30/java-object/</url>
      <content type="html"><![CDATA[<p>介绍java中的object类。<br><a id="more"></a></p>
<h2 id="RegisterNatives"><a href="#RegisterNatives" class="headerlink" title="RegisterNatives"></a>RegisterNatives</h2><p><a href="http://stackoverflow.com/questions/1010645/what-does-the-registernatives-method-do" target="_blank" rel="external">StackOverflow</a><br>功能：JVM用来寻找本地函数</p>
<h2 id="getClass"><a href="#getClass" class="headerlink" title="getClass"></a>getClass</h2><p><a href="http://stackoverflow.com/questions/30918889/how-to-understand-the-object-getclass-method" target="_blank" rel="external">StackOverflow</a><br>功能：返回对象的运行时类</p>
<h2 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode"></a>hashCode</h2><p>功能：获取给定对象的唯一整数，用于确定对象在<code>HashTable</code>中的位置，默认值为对象内存地址编号</p>
<p>可使用<code>Apache Commons Lang</code>重写<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> PRIME = <span class="number">31</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HashCodeBuilder(getId()%<span class="number">2</span>==<span class="number">0</span>?getId()+<span class="number">1</span>:getId(), PRIME).toHashCode();</span><br><span class="line"> &#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>)</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (o.getClass() != getClass())</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> EqualsBuilder().append(getId(), ((Demo)o).getId()).isEquals();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h2><p>功能：比较两个对象是否相等<br>注意：如果重写<code>equals</code>方法必须重写<code>hashCode</code>方法</p>
<p><code>==</code>：基本类型是比较值，引用类型是比较对象地址，而<code>equals</code>方法无法作用于基本类型，默认情况（未重写）下是比较对象的地址。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="clone"><a href="#clone" class="headerlink" title="clone"></a>clone</h2><p>功能：复制对象<br>复制对象需要先分配一个和源对象同样大小的空间，然后在这个空间中创建一个新的对象。</p>
<p>在JAVA中创建对象的方法有两种：<code>new</code>和<code>clone</code>。<br>new操作符的本意是分配内存。程序执行到new操作符时， 首先去看new操作符后面的类型，因为知道了类型，才能知道要分配多大的内存空间。分配完内存之后，再调用构造函数，填充对象的各个域，这一步叫做对象的初始化，构造方法返回后，一个对象创建完毕，可以把他的引用（地址）发布到外部，在外部就可以使用这个引用操纵这个对象。<br>clone操作符的本意是复制内存。在第一步是和new相似的， 都是分配内存，调用clone方法时，分配的内存和源对象（即调用clone方法的对象）相同，然后再使用原对象中对应的各个域，填充新对象的域， 填充完成之后，clone方法返回，一个新的相同的对象被创建，同样可以把这个新对象的引用发布到外部。</p>
<p>注意：<code>clone</code>是浅拷贝，也就是只拷贝基本类型的值以及对象的引用。</p>
<p>为了实现深拷贝，需要实现Clonable接口，覆盖并实现clone方法，除了调用父类中的clone方法得到新的对象， 还要将该类中的引用变量也clone出来，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Body</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;  </span><br><span class="line">    <span class="keyword">public</span> Head head;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Body</span><span class="params">()</span> </span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Body</span><span class="params">(Head head)</span> </span>&#123;<span class="keyword">this</span>.head = head;&#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;  </span><br><span class="line">        Body newBody =  (Body) <span class="keyword">super</span>.clone();  </span><br><span class="line">        newBody.head = (Head) head.clone();  </span><br><span class="line">        <span class="keyword">return</span> newBody;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Head</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;  </span><br><span class="line">    <span class="keyword">public</span>  Face face;  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Head</span><span class="params">()</span> </span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Head</span><span class="params">(Face face)</span></span>&#123;<span class="keyword">this</span>.face = face;&#125;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果在拷贝一个对象时，要想让这个拷贝的对象和源对象完全彼此独立，那么在引用链上的每一级对象都要被显式的拷贝，因此，彻底的深拷贝是非常困难的。</p>
<h2 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a>toString</h2><p>默认情况下，返回格式如下,<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getClass().getName() + <span class="string">'@'</span> + Integer.toHexString(hashCode())</span><br></pre></td></tr></table></figure></p>
<p>一般建议每一个类都重写该方法，便于开发和调试。</p>
<h2 id="object-lock"><a href="#object-lock" class="headerlink" title="object lock"></a>object lock</h2><p>所有对象都自动含有单一的锁。</p>
<p>JVM负责跟踪对象被加锁的次数。如果一个对象被解锁，其计数变为0。在任务（线程）第一次给对象加锁的时候，计数变为1。每当这个相同的任务（线程）在此对象上获得锁时，计数会递增。</p>
<p>只有首先获得锁的任务（线程）才能继续获取该对象上的多个锁。</p>
<p>每当任务离开一个<code>synchronized</code>方法，计数递减，当计数为0的时候，锁被完全释放，此时别的任务就可以使用此资源。</p>
<p>而<code>wait</code>、<code>notify</code>、<code>notifyAll</code>是<code>Java</code>语言提供的实现线程间阻塞(<code>Blocking</code>)和控制进程内调度(<code>inter-process communication</code>)的底层机制。</p>
<h2 id="wait"><a href="#wait" class="headerlink" title="wait"></a>wait</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Causes the current thread to wait until another thread invokes the notify() method or the notifyAll() method for this object.</span><br></pre></td></tr></table></figure>
<p><code>wait</code>方法用来将当前线程置入<code>等待状态</code>，直到接到通知或被中断为止。<br>在调用<code>wait</code>方法之前，线程必须要获得该对象的对象级别锁，即只能在同步方法或同步块中调用<code>wait</code>方法。进入<code>wait</code>方法后，当前线程释放锁。在从<code>wait</code>方法返回前，线程与其他线程竞争重新获得锁。如果调用<code>wait</code>方法时，没有持有适当的锁，则抛出<code>IllegalMonitorStateException</code>，它是<code>RuntimeException</code>的一个子类，因此，不需要<code>try-catch</code>结构。</p>
<h2 id="notify"><a href="#notify" class="headerlink" title="notify"></a>notify</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Wakes up a single thread that is waiting on this object&apos;s monitor.</span><br></pre></td></tr></table></figure>
<p><code>notify</code>方法也要在同步方法或同步块中调用，即在调用前，线程也必须要获得该对象的对象级别锁，如果调用<code>notify</code>方法时没有持有适当的锁，也会抛出<code>IllegalMonitorStateException</code>。<br><code>notify</code>方法用来通知那些可能等待该对象的对象锁的其他线程。如果有多个线程等待，则线程规划器任意挑选出其中一个<code>等待状态</code>的线程来发出通知，并使它等待获取该对象的对象锁。其他处于<code>等待状态</code>的线程在未收到<code>notify</code>或<code>notifyAll</code>通知之前，会一直阻塞在<code>等待状态</code>（即使对象已经空闲）。</p>
<blockquote>
<p>注意：处于<code>等待状态</code>的线程等待的是<code>notify</code>或<code>notifyAll</code>的通知而不是对象锁，也就是说<code>notify</code>和<code>notifyAll</code>只是回复竞争的机会。</p>
</blockquote>
<h2 id="notifyAll"><a href="#notifyAll" class="headerlink" title="notifyAll"></a>notifyAll</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Wakes up all threads that are waiting on this object&apos;s monitor.</span><br></pre></td></tr></table></figure>
<p> <code>notifyAll</code>方法与<code>notify</code>方法的工作方式相同，重要的一点差异是：<code>全部被唤醒</code>。<code>notifyAll</code>会唤醒所有处于<code>等待状态</code>的线程，变成等待获取该对象上的锁，一旦该对象锁被释放，他们就会去竞争对象锁。如果其中一个线程获得了该对象锁，它就会继续往下执行，在它退出synchronized代码块，释放锁后，其他的已经被唤醒的线程将会继续竞争获取该锁，一直进行下去，直到所有被唤醒的线程都执行完毕。</p>
<h2 id="finalize"><a href="#finalize" class="headerlink" title="finalize"></a>finalize</h2><p><code>finalize</code>是GC在回收对象之前最先调用的方法。<br><code>C++</code>中的析构函数调用的时机是确定的（对象离开作用域或delete掉），但<code>Java</code>中的<code>finalize</code>的调用具有不确定性，只有当JVM发生GC时才会回收这部分对象的内存。</p>
]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[flex]]></title>
      <url>/2017/03/27/flex/</url>
      <content type="html"><![CDATA[<p><code>flex</code>属性用于设置或检索弹性盒模型对象的子元素如何分配空间。<br><a id="more"></a><br><code>flex</code>属性是<code>flex-grow</code>、<code>flex-shrink</code>和<code>flex-basis</code>属性的简写属性。</p>
<blockquote>
<p><strong>注意</strong>：如果元素不是弹性盒模型对象的子元素，则 flex 属性不起作用。</p>
</blockquote>
<p>属性包括<code>flex-basis</code>、<code>flex-direction</code>、<code>flex-flow</code>、<code>flex-shrink</code>、<code>flex-grow</code>、<code>flex-wrap</code>。</p>
<h2 id="flex-basis"><a href="#flex-basis" class="headerlink" title="flex-basis"></a><a href="http://www.runoob.com/cssref/css3-pr-flex-basis.html" target="_blank" rel="external">flex-basis</a></h2><p><code>flex-basis</code>属性用于设置或检索弹性盒伸缩基准值，默认值<code>auto</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">可选：number|auto|initial|inherit;</span><br><span class="line">其中，number表示长度单位或百分比，auto表示根据内容决定当前盒子长度。</span><br><span class="line"></span><br><span class="line">//实例：指定class=&quot;test&quot;元素下，第二个div元素的宽度</span><br><span class="line">.test div:nth-of-type(2) &#123;</span><br><span class="line">    -webkit-flex-basis: 80px; /* Safari 6.1+ */</span><br><span class="line">    flex-basis: 80px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>nth-of-type()选择器？</p>
</blockquote>
<p><code>nth-of-type(n)</code> 选择器匹配属于父元素的特定类型的第 N 个子元素的每个元素。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//实例1：按奇偶顺序改变子元素颜色</span><br><span class="line">p:nth-of-type(odd)</span><br><span class="line">&#123;</span><br><span class="line">  background:#ff0000;</span><br><span class="line">&#125;</span><br><span class="line">p:nth-of-type(even)</span><br><span class="line">&#123;</span><br><span class="line">  background:#0000ff;</span><br><span class="line">&#125;</span><br><span class="line">//实例2：按3n+1的顺序添加背景颜色</span><br><span class="line">p:nth-of-type(3n+0)</span><br><span class="line">&#123;</span><br><span class="line">  background:#ff0000;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="flex-direction"><a href="#flex-direction" class="headerlink" title="flex-direction"></a><a href="http://www.runoob.com/cssref/css3-pr-flex-direction.html" target="_blank" rel="external">flex-direction</a></h2><p><code>flex-direction</code>属性用于指定子元素的排列方向。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可选：row|row-reverse|column|column-reverse|initial|inherit</span><br></pre></td></tr></table></figure></p>
<h2 id="flex-wrap"><a href="#flex-wrap" class="headerlink" title="flex-wrap"></a><a href="http://www.runoob.com/cssref/css3-pr-flex-wrap.html" target="_blank" rel="external">flex-wrap</a></h2><p><code>flex-wrap</code>属性用于指定flex容器内子元素的排列方式：单行或多行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可选：nowarp单行|warp多行|warp-reverse反向多行</span><br></pre></td></tr></table></figure></p>
<h2 id="flex-flow"><a href="#flex-flow" class="headerlink" title="flex-flow"></a><a href="http://www.runoob.com/cssref/css3-pr-flex-flow.html" target="_blank" rel="external">flex-flow</a></h2><p><code>flex-flow</code>属性用于设置子元素的排列顺序，是<code>flex-direction</code>和<code>flex-wrap</code>复合属性。</p>
<h2 id="flex-grow"><a href="#flex-grow" class="headerlink" title="flex-grow"></a><a href="http://www.runoob.com/cssref/css3-pr-flex-grow.html" target="_blank" rel="external">flex-grow</a></h2><p><code>flex-grow</code>属性用于设置子元素扩大的比率。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可选：比例（当小于1时缩小）|initial|inherit</span><br></pre></td></tr></table></figure></p>
<h2 id="flex-shrink"><a href="#flex-shrink" class="headerlink" title="flex-shrink"></a><a href="http://www.runoob.com/cssref/css3-pr-flex-shrink.html" target="_blank" rel="external">flex-shrink</a></h2><p><code>flex-shrink</code>属性用于设置子元素缩小的比率。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可选：比例（当大于1时扩小）|initial|inherit</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><code>flex-grow</code>和<code>flex-shrink</code>其实可以实现同样的效果。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> fe </category>
            
        </categories>
        
        
        <tags>
            
            <tag> css </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[垃圾回收GC]]></title>
      <url>/2017/01/25/gc/</url>
      <content type="html"><![CDATA[<p>现代语言中，大多数都实现了垃圾回收功能，不再需要开发者自己来释放无用的内存资源，大大提高了开发效率。<br><a id="more"></a></p>
<p><img src="/images/gc-1.jpg" alt=""></p>
<h2 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h2><p>1960 年前后诞生于 MIT 的 <code>Lisp</code> 语言是第一种高度依赖于动态内存分配技术的语言。Lisp 中几乎所有数据都以“表”的形式出现，而“表”所占用的空间则是在堆中动态分配得到的。 Lisp 语言先天就具有的动态内存管理特性要求Lisp 语言的设计者必须解决堆中每一个内存块的自动释放问题，否则，Lisp 程序员就必然被程序中不计其数的 <code>free / delete</code> 语句淹没，这直接导致了垃圾收集技术的诞生和发展。</p>
<p>在学校和工作中，我使用过<code>c/c++</code>这种需要开发者自己来维护内存，时时刻刻需要小心内存泄露的问题，也使用过<code>python</code>、<code>golang</code>、<code>js</code>以及<code>java</code>这种不需要关系内存资源的释放，让自己更加专注于程序的设计和开发，但是也带来了性能的损耗。</p>
<p><code>垃圾回收GC</code>并不是万能的，如果你接受了它的便利，那么你也需要接受<code>GC</code>带来的性能开销。</p>
<h2 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h2><p>内存分配大概分为三种：静态分配、局部分配以及动态分配。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">静态分配（ Static Allocation ）：</span><br><span class="line">静态变量和全局变量的分配形式。通常，它们无需释放和回收。</span><br><span class="line"></span><br><span class="line">自动分配（ Automatic Allocation ）：</span><br><span class="line">在栈中为局部变量分配内存的方法。栈中的内存可以随着代码块退出时的出栈操作被自动释放。</span><br><span class="line"></span><br><span class="line">动态分配（ Dynamic Allocation ）：</span><br><span class="line">在堆中动态分配内存空间以存储数据的方式。堆中的内存需要开发者自己来管理，谨慎对待每一个动态分配的对象，避免造成内存泄露。</span><br><span class="line">在软件开发中，如果你懒得释放内存，那么你也需要一台类似的机器人——这其实就是一个由特定算法实现的垃圾收集器。</span><br></pre></td></tr></table></figure></p>
<p>因此，垃圾回收的目的是<code>回收动态分配的内存</code>。</p>
<h2 id="垃圾回收GC"><a href="#垃圾回收GC" class="headerlink" title="垃圾回收GC"></a>垃圾回收GC</h2><p>垃圾回收技术主要包括：引用计数、跟踪式以及分代。</p>
<h3 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h3><p><code>引用计数Reference Counting</code>为每个内存对象维护一个引用计数器,<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 新的引用指向某对象时，该对象引用计数器加1</span><br><span class="line">if add refrence:</span><br><span class="line">    counter +=1</span><br><span class="line"></span><br><span class="line">// 对象的引用被销毁时，该对象引用计数器减1</span><br><span class="line">if remove refrence:</span><br><span class="line">   counter -= 1</span><br><span class="line"></span><br><span class="line">// 对象的计数器归零时，回收该对象所占用的内存资源</span><br><span class="line">if counter == 0:</span><br><span class="line">   free object</span><br></pre></td></tr></table></figure></p>
<p>每个计数器只记录了其对应对象的局部信息-<code>被引用的次数</code>，而没有全局的应用信息。</p>
<p>由于只维护局部信息，所以不需要扫描全局对象图就可以识别并释放死对象，但也因为缺乏全局对象图信息，所以无法处理<code>循环引用</code>的状况。</p>
<blockquote>
<p>循环引用？</p>
</blockquote>
<p>A引用B，B又引用了A，那么A和B引用计数器的值均为1，无法释放该资源。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A &lt;- B</span><br><span class="line">B &lt;- A</span><br></pre></td></tr></table></figure></p>
<p><code>优点 &amp; 缺点</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">优点</span><br><span class="line">- 每次创建和销毁都要更新引用计数值，会引起额外的开销</span><br><span class="line">- 计数简单，只需要记录自身被引用次数</span><br><span class="line">- 实时的垃圾回收，不会造成中断</span><br><span class="line"></span><br><span class="line">缺点</span><br><span class="line">- 无法处理循环引用</span><br><span class="line">- 多线程对同一对象计数更新产设个竞争</span><br></pre></td></tr></table></figure></p>
<p><code>Python</code>使用了引用计数算法，为了解决循环引用的问题还设计了其他GC模块(<code>标记清除</code>和<code>分代收集</code>)。<br>此外，<code>Python</code>为了解决引用技术的性能问题还引入了内存池机制。</p>
<h3 id="跟踪式"><a href="#跟踪式" class="headerlink" title="跟踪式"></a>跟踪式</h3><p><code>跟踪式垃圾回收</code>是比较常见的垃圾回收技术，主要原则是从程序栈的若干个根对象出发，构造一个可达链，对于那些不可达的内存对象，做回收。</p>
<p> 如果一个内存对象有被程序中的至少一个变量引用（直接指向或间接指向），则认为该对象可达，否则认为该对象不可达，可以被垃圾回收。</p>
<h4 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h4><p><code>标记清除Mark-Sweep</code>的基本思路是遍历以对象为节点、以引用为边构成的图，把所有可以访问到的对象打上标记，然后清扫一遍内存空间，把所有没标记的对象释放。</p>
<p>具体过程分两步：</p>
<ul>
<li>从根（Root）开始遍历，被根引用了的对象标记为非垃圾对象，非垃圾对象引用的对象同样标记为非垃圾对象，以此递归直到标记完所有对象；</li>
<li>再次从根节点开始，对已被标记为垃圾的对象清除释放。</li>
</ul>
<p><img src="/images/gc-2.png" alt=""></p>
<p>如图，红色代表垃圾对象，黄色代表非垃圾对象，绿色代表未使用空间。</p>
<blockquote>
<p>缺点：内存碎片</p>
</blockquote>
<p>由于标记清除不需要移动对象的位置，直接回收垃圾对象必然会造成<code>内存碎片</code>。</p>
<h4 id="标记复制"><a href="#标记复制" class="headerlink" title="标记复制"></a>标记复制</h4><p><code>标记复制 Mark-Copy</code>只需要对对象进行一次遍历。</p>
<p>它的基本思想是利用空间换时间，从根开始开始遍历对象，如果对象仍然存在引用，就把它复制到新的内存空间中，一次遍历结束之后，所有存在于新空间的对象就是所有的非垃圾对象，可直接释放掉原有内存空间，不会造成内存碎片。</p>
<p><img src="/images/gc-3.png" alt=""></p>
<p>如图，红色代表垃圾对象，黄色代表非垃圾对象，绿色代表未使用空间。</p>
<blockquote>
<p>缺点：浪费内存</p>
</blockquote>
<p>标记复制更快速但是需要额外开辟一块用来复制的内存，对垃圾比例较大的情况占优势。</p>
<p>此外，内存空间切换过程中需要暂停程序运行（也就是常说GC停顿）。</p>
<h4 id="标记压缩"><a href="#标记压缩" class="headerlink" title="标记压缩"></a>标记压缩</h4><p><code>标记压缩Mark-Compact</code>是在标记清除算法的基础之上增加对象的移动，从而解决内存碎片的问题。</p>
<p>在压缩阶段，由于要移动可达对象，那么需要考虑移动对象时的顺序，一般分为下面三种：</p>
<ul>
<li><p>任意顺序 - 即不考虑原先对象的排列顺序，也不考虑对象间的引用关系，随意的移动可达对象，这样可能会有内存访问的局部性问题。</p>
</li>
<li><p>线性顺序 - 在重新排列对象时，会考虑对象间的引用关系，比如A对象引用了B对象，那么就会尽可能的将A，B对象排列在一起。</p>
</li>
<li><p>滑动顺序 - 顾名思义，就是在重新排列对象时，将对象按照原先堆内存中的排列顺序滑动到堆的一端。</p>
</li>
</ul>
<p>现在大多数的垃圾收集算法都是按照任意顺序或滑动顺序去实现的(由于线性顺序需要考虑对象的引用关系所以实现复杂)。</p>
<p><code>Two-Finger 算法</code>数据移动过程类似快排，分别用两个指针指向内存的两端，分别向中心移动。如果右侧指针遇到垃圾数据直接回收，否则，移动左侧指针直到遇到可替换垃圾对象，然后替换左右指针的对象。</p>
<p><img src="/images/gc-4.png" alt=""></p>
<blockquote>
<p>缺点：移动对象的代价</p>
</blockquote>
<p>为了避免内存碎片，移动对象需要遍历整个内存空间，还需要暂停程序更换映射地址空间。</p>
<h3 id="分代回收"><a href="#分代回收" class="headerlink" title="分代回收"></a>分代回收</h3><p><code>分代回收</code>是根据对象的存活周期的不同将内存划分为几块。一般把java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。</p>
<p><img src="/images/gc-5.png" alt=""></p>
<h4 id="年轻代垃圾回收"><a href="#年轻代垃圾回收" class="headerlink" title="年轻代垃圾回收"></a>年轻代垃圾回收</h4><p><img src="/images/gc-6.png" alt=""></p>
<p>年轻代回收特点：</p>
<ul>
<li>新对象的内存分配都是先在Eden区域中进行的；</li>
<li>当Eden区域的空间不足于分配新对象时，就会触发年轻代上的垃圾回收<code>minor gc</code>（minor garbage collection）；</li>
<li>每个对象都有一个<code>年龄</code>，代表对象经历过的<code>minor gc</code>的次数；</li>
<li>当触发<code>minor gc</code>后，所有存活的对象都会被拷贝到一个新的<code>survivor</code>区域，并且年龄增加1；当对象的年龄足够大，它会从survivor内存区域升级到老年代中。</li>
</ul>
<h4 id="年老代垃圾回收"><a href="#年老代垃圾回收" class="headerlink" title="年老代垃圾回收"></a>年老代垃圾回收</h4><p>当老年代内存区域（图中<code>Tenured</code>）无法容纳新对象时，这时候就会触发老年代的垃圾回收<code>major gc</code>（major garbage collection”）。</p>
<blockquote>
<p>垃圾回收算法<code>PS</code>和<code>CMS</code></p>
</blockquote>
<p>常用的垃圾回收算法有<code>Parallel Scavenge(PS)</code> 和<code>Concurrent Mark Sweep(CMS)</code>，它们的不同之处体现在年老代的垃圾回收过程中，而年轻代的垃圾回收过程在这两种垃圾回收器中基本上是一致的。<code>PS</code>在执行垃圾回收时使用了<code>多线程</code>来一起进行垃圾回收，这样可以提高垃圾回收的效率，<code>CMS</code>在进行垃圾回收时，应用程序可以同时运行。</p>
<p>在年轻代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对他进行分配担保，就必须使用“标记-整理”算法进行回收。</p>
<h3 id="Parallel-Scavenge"><a href="#Parallel-Scavenge" class="headerlink" title="Parallel Scavenge"></a>Parallel Scavenge</h3><p><code>PS垃圾回收</code>是由<code>标记清除</code>和<code>标记压缩</code>算法组成。</p>
<p>标记清除算法的一个缺陷就是它会引起内存碎片问题。继而有可能会引发连续的major gc。假设当前存在的内存碎片有10M，但最大的内存碎片只能容纳2M的对象，这个时候如果有一个3M的对象从Survivor区域升级到Tenured区域，那Tenured区域也没有办法存放这个3M的对象。结果就是不断的触发major gc，直到Out of Memory。所以，PS垃圾回收器在清除非可达对象后，还会进行一次compact，来消除内存碎片。</p>
<h3 id="Concurrent-Mark-Sweep"><a href="#Concurrent-Mark-Sweep" class="headerlink" title="Concurrent Mark Sweep"></a>Concurrent Mark Sweep</h3><p><code>CMS</code>在进行垃圾收集时，应用程序是可以并行运行的，因此，它减少了垃圾收集时暂停应用程序的时间。<br>垃圾回收的四个阶段如下，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1. Initial Mark阶段</span><br><span class="line">程序暂停运行`Stop-The-Word`，标记到根对象的第一层孩子节点即停止 ，然后程序恢复运行。由于只标记一层节点，所以暂停时间很短。</span><br><span class="line"></span><br><span class="line">2. Concurrent Mark阶段</span><br><span class="line">以Initial Mark阶段标记的节点为根对象，重新开始标记Tenured区域中的可达对象（不需要暂停应用程序，因此称为&quot;Concurrent Mark&quot;）。</span><br><span class="line">由于CMS垃圾回收器和应用程序同时运行，Concurrent Mark阶段它并不保证在Tenured区域的可达对象都被标记了（分配新对象）。</span><br><span class="line"></span><br><span class="line">3. Remark阶段</span><br><span class="line">暂停应用程序，确保所有的可达对象都被标记（Concurrent Mark阶段未标记的，`可多线程标记`）。</span><br><span class="line"></span><br><span class="line">4. Concurrent Sweep阶段</span><br><span class="line">恢复应用程序的执行，执行sweep来清除所有非可达对象所占用的内存空间。</span><br></pre></td></tr></table></figure></p>
<p>与<code>PS</code>相比，<code>CS</code>垃圾回收算法可以减少程序暂停的时间。</p>
<p><img src="/images/gc-7.png" alt=""></p>
<h3 id="Garbage-First"><a href="#Garbage-First" class="headerlink" title="Garbage First"></a>Garbage First</h3><p>CMS垃圾收集器虽然减少了暂停应用程序的运行时间，但是由于它没有Compact阶段，它还是存在着内存碎片问题。于是，为了去除内存碎片问题，同时又保留CMS垃圾收集器低暂停时间的优点，JAVA7发布了一个新的垃圾收集器 - G1垃圾收集器。</p>
<p><img src="/images/gc-8.png" alt=""></p>
<p>G1垃圾收集器和CMS垃圾收集器有几点不同，最大的不同是内存的组织方式变了。Eden，Survivor和Tenured等内存区域不再是连续的了，而是变成了一个个大小一样的region - 每个region从1M到32M不等。</p>
<p><code>G1</code>垃圾回收的四个阶段如下，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1. Initial Mark阶段</span><br><span class="line">同CMS垃圾收集器的Initial Mark阶段一样，程序暂停运行`Stop-The-Word`，标记到根对象的第一层孩子节点即停止 ，然后程序恢复运行。</span><br><span class="line">由于只标记一层节点。但它不会单独暂停应用程序的执行，而是在G1触发minor gc是发生。</span><br><span class="line"></span><br><span class="line">2. Concurrent Mark阶段</span><br><span class="line">同CMS垃圾收集器的Concurrent Mark阶段一样，重新开始标记Tenured区域中的可达对象（不需要暂停应用程序）。</span><br><span class="line">但G1还会回收掉Tenured region中对象的存活率很小或者基本没有对象存活的内存区域（不需要等待clean up阶段，因此成为Garbage First），并计算每个 region的对象存活率以供clean up阶段使用 。</span><br><span class="line"></span><br><span class="line">3. Remark阶段 </span><br><span class="line">同CMS垃圾收集器的Remark阶段一样, 但G1采用一种叫做SATB(snapshot-at-the-begining)的算法能够在Remark阶段更快的标记可达对象。</span><br><span class="line"></span><br><span class="line">4. Clean up/Copy阶段</span><br><span class="line">与CMS中不同，它有一个Clean up/Copy阶段，在minor gc发生的同时G1会挑选出那些对象存活率低的region进行回收。</span><br></pre></td></tr></table></figure></p>
<p>由于Initial Mark阶段和Clean up/Copy阶段都是跟minor gc同时发生的，相比于CMS，G1暂停应用程序的时间更少，从而提高了垃圾回收的效率。</p>
]]></content>
      
        <categories>
            
            <category> cs </category>
            
        </categories>
        
        
        <tags>
            
            <tag> gc </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[单点登录]]></title>
      <url>/2016/12/13/sso/</url>
      <content type="html"><![CDATA[<p>单点登录全称Single Sign On（简称SSO），是指在多系统中用户只需要登录一个系统，便可在其他所有系统中得到授权而无需再次登录。<br><a id="more"></a></p>
<h2 id="传统方法"><a href="#传统方法" class="headerlink" title="传统方法"></a>传统方法</h2><p>对于小型站点来说，可以直接通过cookie和session在多个页面下实现登录状态的共享。<br>session常被保存在redis/memcache集群中，以便提高访问效率。<br><strong>使用cookie和session有哪些问题？</strong><br>cookie不安全，需要通过加密算法来处理；<br>使用cookie不能跨域。</p>
<h2 id="单点登录"><a href="#单点登录" class="headerlink" title="单点登录"></a>单点登录</h2><p>主要思想是设计一个独立于各个系统的登录系统，也即是说要把用户登录的权限验证统一管理。</p>
<h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>单点登录需要一个独立的认证中心，只有认证中心能接受用户的用户名密码等安全信息，其他系统不提供登录入口，只接受认证中心的间接授权。</p>
<h3 id="认证步骤"><a href="#认证步骤" class="headerlink" title="认证步骤"></a>认证步骤</h3><p>通过SSO认证登录，然后把授权信息发送给各个系统，具体步骤如下：</p>
<ul>
<li>用户登录某一系统，未登录则跳转到sso认证中心</li>
<li>用户在sso输入用户名密码，认证通过，生成授权令牌</li>
<li>sso把授权令牌发送到各个子系统和用户</li>
<li>用户重新访问原有系统， 通过验证授权令牌，登入系统</li>
<li><h3 id="注销步骤"><a href="#注销步骤" class="headerlink" title="注销步骤"></a>注销步骤</h3>由于单点登录的状态是统一管理的，那么用户在任何一个系统中注销登录状态的同时需要保证其他系统的授权令牌同时失效，具体步骤如下：</li>
<li>用户在某一个系统注销登录</li>
<li>注销信息会传递给sso认证中心</li>
<li>认证中心再通知各个系统销毁授权令牌</li>
</ul>
<h3 id="系统特点"><a href="#系统特点" class="headerlink" title="系统特点"></a>系统特点</h3><ul>
<li>sso需要保存一份全局的用户登录状态（也就是授权令牌和登录用户的关系）；</li>
<li>sso作为登录状态的唯一管理者，每次授权和销毁都需要同步最新的授权令牌的状态到各个子系统；</li>
<li>sso和其他系统之间需要建立一套数据同步机制。</li>
</ul>
<h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><p><strong>大量授权请求如何处理？</strong><br>大量授权请求会带来大量的授权数据，由于授权数据的临时性，可将这些授权信息存储的缓存系统中，常见memcache/redis等；<br>大量的授权请求会产生大量的授权令牌的生成，常见的授权令牌都需要加密处理，必然影响系统性能，可通过预生成授权令牌的方式来降低批量生成令牌造成的资源竞争。</p>
<p><strong>全局和局部的授权令牌如何同步处理？</strong><br>SSO和系统发生认证和注销操作都需要同步给系统中的每一个系统；<br>授权令牌采用按时间过期的方式，定期更新授权令牌到各个子系统；<br>至少保证登录注销的信息传递到SSO认证中心。</p>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>常见的单点登录包括一些网站或应用的微信认证登录、QQ认证登录、微博认证登录；<br>淘宝、360、微博、网易、美团的登录认证方式。</p>
<h2 id="其他类似系统"><a href="#其他类似系统" class="headerlink" title="其他类似系统"></a>其他类似系统</h2><p>全局唯一ID生成器（不仅仅是UUID），可参考微信消息的唯一ID的生成方式</p>
]]></content>
      
        <categories>
            
            <category> web </category>
            
        </categories>
        
        
        <tags>
            
            <tag> web </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[redis 跳跃表]]></title>
      <url>/2016/12/06/redis-skiplist/</url>
      <content type="html"><![CDATA[<p>本文介绍redis中的跳跃表的原理和实现。<br><a id="more"></a></p>
<h2 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h2><p>跳跃表通过在每个节点维护多个指向其他节点的指针来提高节点的访问效率。</p>
]]></content>
      
        <categories>
            
            <category> cache </category>
            
        </categories>
        
        
        <tags>
            
            <tag> redis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[redis 字典]]></title>
      <url>/2016/12/03/redis-dict/</url>
      <content type="html"><![CDATA[<p>本文将介绍redis字典的具体实现。<br><a id="more"></a></p>
<h2 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h2><p>redis字典和python的字典（java中的map）的性质是一样的，也被称为关联数组或映射，是一种保存键值对的数据结构。</p>
<p>redis字典使用哈希表作为底层实现，字典中的键不允许相同。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">    dictEntry **table; <span class="comment">// 哈希表</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size; <span class="comment">// 哈希表大小</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask; <span class="comment">// 哈希表大小掩码</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used; <span class="comment">// 已使用大小</span></span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure>
<p>哈希表中每一个键值对用<code>dictEntry</code>来表示，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *key; <span class="comment">// 键</span></span><br><span class="line">    <span class="keyword">union</span> &#123; <span class="comment">// 值</span></span><br><span class="line">        <span class="keyword">void</span> *val;</span><br><span class="line">        <span class="keyword">uint64_t</span> u64;</span><br><span class="line">        <span class="keyword">int64_t</span> s64;</span><br><span class="line">        <span class="keyword">double</span> d;</span><br><span class="line">    &#125; v;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span> <span class="comment">// 链表指针</span></span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure>
<p>其中，next<code>指针是用来解决哈希表的键冲突的，所有key的哈希值相同的节点都会添加在链表上。</code>v`值支持4种格式：指针、unit64_t、int64_t、double类型。</p>
<p><img src="/images/redis-hash.png" alt=""></p>
<h2 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h2><p>添加新的键值对时，需要先计算键的哈希值和索引值，然后按照索引值把键值对插入到对应的位置。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查找key在索引中的位置</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> _dictKeyIndex(dict *d, <span class="keyword">const</span> <span class="keyword">void</span> *key, <span class="keyword">unsigned</span> <span class="keyword">int</span> hash, dictEntry **existing)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> idx, table;</span><br><span class="line">    dictEntry *he;</span><br><span class="line">    <span class="keyword">if</span> (existing) *existing = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Expand the hash table if needed */</span></span><br><span class="line">    <span class="keyword">if</span> (_dictExpandIfNeeded(d) == DICT_ERR) <span class="comment">// 哈希表扩展</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (table = <span class="number">0</span>; table &lt;= <span class="number">1</span>; table++) &#123; <span class="comment">// 遍历两个哈希table</span></span><br><span class="line">        idx = hash &amp; d-&gt;ht[table].sizemask; <span class="comment">// 获取table上索引位置</span></span><br><span class="line">        <span class="comment">/* Search if this slot does not already contain the given key */</span></span><br><span class="line">        he = d-&gt;ht[table].table[idx];</span><br><span class="line">        <span class="keyword">while</span>(he) &#123; <span class="comment">// 遍历桶内数据（冲突链）</span></span><br><span class="line">            <span class="keyword">if</span> (key==he-&gt;key || dictCompareKeys(d, key, he-&gt;key)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (existing) *existing = he;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            he = he-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!dictIsRehashing(d)) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> idx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加键值对</span></span><br><span class="line"><span class="function">dictEntry *<span class="title">dictAddRaw</span><span class="params">(dict *d, <span class="keyword">void</span> *key, dictEntry **existing)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">    dictEntry *entry;</span><br><span class="line">    dictht *ht;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) _dictRehashStep(d); <span class="comment">// 如果在rehash，则采用渐进方式</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Get the index of the new element, or -1 if</span></span><br><span class="line"><span class="comment">     * the element already exists. */</span></span><br><span class="line">    <span class="keyword">if</span> ((index = _dictKeyIndex(d, key, dictHashKey(d,key), existing)) == <span class="number">-1</span>) <span class="comment">// -1代表已存在</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    ht = dictIsRehashing(d) ? &amp;d-&gt;ht[<span class="number">1</span>] : &amp;d-&gt;ht[<span class="number">0</span>];</span><br><span class="line">    entry = zmalloc(<span class="keyword">sizeof</span>(*entry));</span><br><span class="line">    entry-&gt;next = ht-&gt;table[index]; <span class="comment">// 链表头插法</span></span><br><span class="line">    ht-&gt;table[index] = entry;</span><br><span class="line">    ht-&gt;used++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set the hash entry fields. */</span></span><br><span class="line">    dictSetKey(d, entry, key);</span><br><span class="line">    <span class="keyword">return</span> entry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a>功能实现</h2><h3 id="rehash"><a href="#rehash" class="headerlink" title="rehash"></a>rehash</h3><p>当桶后面的链表不断增长时，访问目标键值变慢，就需要rehash来加快访问速度（减少链表长度）。</p>
<p>此外，随着键值对的添加和删除，需要动态调整哈希表的大小。</p>
<p>在redis中，字典的存储结构如下，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    dictType *type;</span><br><span class="line">    <span class="keyword">void</span> *privdata;</span><br><span class="line">    dictht ht[<span class="number">2</span>]; <span class="comment">// 默认使用ht[0],ht[1]用于rehash</span></span><br><span class="line">    <span class="keyword">long</span> rehashidx; <span class="comment">/* 是否执行rehash的标识rehashing not in progress if rehashidx == -1 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> iterators; <span class="comment">/* number of iterators currently running */</span></span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure></p>
<p>其中，ht[2]用来存储字典内容，只有在进行rehash操作时，ht[1]才会被用到（默认hash数据都存储在ht[0]上）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictRehash</span><span class="params">(dict *d, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> empty_visits = n*<span class="number">10</span>; <span class="comment">/* Max number of empty buckets to visit. */</span></span><br><span class="line">    <span class="keyword">if</span> (!dictIsRehashing(d)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(n-- &amp;&amp; d-&gt;ht[<span class="number">0</span>].used != <span class="number">0</span>) &#123;</span><br><span class="line">        dictEntry *de, *nextde;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">        assert(d-&gt;ht[<span class="number">0</span>].size &gt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>)d-&gt;rehashidx);</span><br><span class="line">        <span class="keyword">while</span>(d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            d-&gt;rehashidx++; <span class="comment">// 如果当前table桶中数据为空，则增加索引值</span></span><br><span class="line">            <span class="keyword">if</span> (--empty_visits == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        de = d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx]; <span class="comment">// 获取当前哈希桶中的第一个键值对</span></span><br><span class="line">        <span class="comment">/* Move all the keys in this bucket from the old to the new hash HT */</span></span><br><span class="line">        <span class="keyword">while</span>(de) &#123; <span class="comment">// 遍历哈希桶中的所有数据</span></span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">int</span> h;</span><br><span class="line"></span><br><span class="line">            nextde = de-&gt;next;</span><br><span class="line">            <span class="comment">/* Get the index in the new hash table */</span></span><br><span class="line">            h = dictHashKey(d, de-&gt;key) &amp; d-&gt;ht[<span class="number">1</span>].sizemask; <span class="comment">// rehash原有数据到新的哈希表的桶中</span></span><br><span class="line">            de-&gt;next = d-&gt;ht[<span class="number">1</span>].table[h];</span><br><span class="line">            d-&gt;ht[<span class="number">1</span>].table[h] = de;</span><br><span class="line">            d-&gt;ht[<span class="number">0</span>].used--;</span><br><span class="line">            d-&gt;ht[<span class="number">1</span>].used++;</span><br><span class="line">            de = nextde;</span><br><span class="line">        &#125;</span><br><span class="line">        d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx] = <span class="literal">NULL</span>;</span><br><span class="line">        d-&gt;rehashidx++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check if we already rehashed the whole table... */</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].used == <span class="number">0</span>) &#123; <span class="comment">//如果原有hash表中所有数据已转移完成，则释放旧哈希表</span></span><br><span class="line">        zfree(d-&gt;ht[<span class="number">0</span>].table);</span><br><span class="line">        d-&gt;ht[<span class="number">0</span>] = d-&gt;ht[<span class="number">1</span>];</span><br><span class="line">        _dictReset(&amp;d-&gt;ht[<span class="number">1</span>]);</span><br><span class="line">        d-&gt;rehashidx = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* More to rehash... */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在进行rehash的过程中，字典会同时在ht的两个table上进行查找、删除、更新操作，而新增只会在ht[1]上操作。</p>
<h3 id="哈希表扩展"><a href="#哈希表扩展" class="headerlink" title="哈希表扩展"></a>哈希表扩展</h3><p>redis提供了<code>dictExpand</code>函数来扩展哈希表的大小。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 哈希表扩展</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictExpand</span><span class="params">(dict *d, <span class="keyword">unsigned</span> <span class="keyword">long</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dictht n; <span class="comment">/* the new hash table */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> realsize = _dictNextPower(size); <span class="comment">// 计算哈希表的大小</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Allocate the new hash table and initialize all pointers to NULL */</span></span><br><span class="line">    n.size = realsize;</span><br><span class="line">    n.sizemask = realsize<span class="number">-1</span>;</span><br><span class="line">    n.table = zcalloc(realsize*<span class="keyword">sizeof</span>(dictEntry*));</span><br><span class="line">    n.used = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Is this the first initialization? If so it's not really a rehashing</span></span><br><span class="line"><span class="comment">     * we just set the first hash table so that it can accept keys. */</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].table == <span class="literal">NULL</span>) &#123; <span class="comment">// 如果哈希表ht[0]没有被初始化，则使用ht[0]</span></span><br><span class="line">        d-&gt;ht[<span class="number">0</span>] = n;</span><br><span class="line">        <span class="keyword">return</span> DICT_OK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Prepare a second hash table for incremental rehashing */</span></span><br><span class="line">    <span class="comment">// 否则，使用ht[1]用于rehash方式扩展</span></span><br><span class="line">    d-&gt;ht[<span class="number">1</span>] = n;</span><br><span class="line">    d-&gt;rehashidx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> DICT_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> _dictNextPower(<span class="keyword">unsigned</span> <span class="keyword">long</span> size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> i = DICT_HT_INITIAL_SIZE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size &gt;= LONG_MAX) <span class="keyword">return</span> LONG_MAX;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        i *= <span class="number">2</span>; <span class="comment">// 2的指数被增大</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> cache </category>
            
        </categories>
        
        
        <tags>
            
            <tag> redis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[redis 字符串]]></title>
      <url>/2016/12/03/redis-sds/</url>
      <content type="html"><![CDATA[<p>介绍和分析redis数据类型-sds。<br><a id="more"></a></p>
<h2 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h2><p>在<code>redis</code>中，字符串的基本结构如下，其中，<code>len</code>表示字符串的长度，<code>alloc</code>表示字符串的最大容量，<code>flags</code>表示header的类型。<br><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr8</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span> len; <span class="comment">/* 已占用buf长度 */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> alloc; <span class="comment">/* 申请的buf长度 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><code>buf</code>表示需要存储的字符数组，数组的长度为len+1（由于需要存储一个结束符’\0’）。</p>
<p>具体结构如下，</p>
<p><img src="/images/redis-sds.png" alt=""></p>
<h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><p>除了上面提到的<code>sdshdr8</code>，还包含<code>sdshdr5、sdshdr16、sdshdr32、sdshdr64</code>。</p>
<p>在读取字符串时，首先需要获取当字符串的存储类型，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类型 - flags取值</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_5  0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_8  1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_16 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_32 3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_64 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用来获取字符串内容</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_MASK 7 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_BITS 3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_HDR_VAR(T,s) struct sdshdr##T *sh = (void*)((s)-(sizeof(struct sdshdr##T)));</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_HDR(T,s) ((struct sdshdr##T *)((s)-(sizeof(struct sdshdr##T))))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_5_LEN(f) ((f)&gt;&gt;SDS_TYPE_BITS)</span></span><br></pre></td></tr></table></figure></p>
<p>其中，<code>SDS_HDR</code>和<code>SDS_HDR_VAR</code>可以从sds字符串中获取header的起始位置。</p>
<h2 id="函数实现"><a href="#函数实现" class="headerlink" title="函数实现"></a>函数实现</h2><p>sds包含很多功能，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdsnewlen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *init, <span class="keyword">size_t</span> initlen)</span></span>;</span><br><span class="line"><span class="function">sds <span class="title">sdsnew</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *init)</span></span>;</span><br><span class="line"><span class="function">sds <span class="title">sdsempty</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function">sds <span class="title">sdsdup</span><span class="params">(<span class="keyword">const</span> sds s)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsfree</span><span class="params">(sds s)</span></span>;</span><br><span class="line"><span class="function">sds <span class="title">sdsgrowzero</span><span class="params">(sds s, <span class="keyword">size_t</span> len)</span></span>;</span><br><span class="line"><span class="function">sds <span class="title">sdscatlen</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">void</span> *t, <span class="keyword">size_t</span> len)</span></span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>这里只详细介绍下初始化和追加函数，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdsnewlen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *init, <span class="keyword">size_t</span> initlen)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *sh;</span><br><span class="line">    sds s;</span><br><span class="line">    <span class="keyword">char</span> type = sdsReqType(initlen); <span class="comment">// 通过初始化长度获取数据类型</span></span><br><span class="line">    <span class="comment">/* Empty strings are usually created in order to append. Use type 8</span></span><br><span class="line"><span class="comment">     * since type 5 is not good at this. */</span></span><br><span class="line">    <span class="keyword">if</span> (type == SDS_TYPE_5 &amp;&amp; initlen == <span class="number">0</span>) type = SDS_TYPE_8;</span><br><span class="line">    <span class="keyword">int</span> hdrlen = sdsHdrSize(type);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *fp; <span class="comment">/* flags pointer. */</span></span><br><span class="line"></span><br><span class="line">    sh = s_malloc(hdrlen+initlen+<span class="number">1</span>); <span class="comment">// 申请内存空间：header长度+buf长度+1</span></span><br><span class="line">    <span class="keyword">if</span> (!init)</span><br><span class="line">        <span class="built_in">memset</span>(sh, <span class="number">0</span>, hdrlen+initlen+<span class="number">1</span>); <span class="comment">// 全部设置为0</span></span><br><span class="line">    <span class="keyword">if</span> (sh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    s = (<span class="keyword">char</span>*)sh+hdrlen; <span class="comment">// 获取buf指针位置</span></span><br><span class="line">    fp = ((<span class="keyword">unsigned</span> <span class="keyword">char</span>*)s)<span class="number">-1</span>; <span class="comment">// 获取类型flag字段</span></span><br><span class="line">    <span class="keyword">switch</span>(type) &#123;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_5: &#123;</span><br><span class="line">            *fp = type | (initlen &lt;&lt; SDS_TYPE_BITS);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_8: &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">8</span>,s);</span><br><span class="line">            sh-&gt;len = initlen;</span><br><span class="line">            sh-&gt;alloc = initlen;</span><br><span class="line">            *fp = type;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (initlen &amp;&amp; init)</span><br><span class="line">        <span class="built_in">memcpy</span>(s, init, initlen); <span class="comment">// 拷贝数据</span></span><br><span class="line">    s[initlen] = <span class="string">'\0'</span>; <span class="comment">// buf最后一位置为'\0'</span></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>为sds增加可用空间，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdsMakeRoomFor</span><span class="params">(sds s, <span class="keyword">size_t</span> addlen)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *sh, *newsh;</span><br><span class="line">    <span class="keyword">size_t</span> avail = sdsavail(s);</span><br><span class="line">    <span class="keyword">size_t</span> len, newlen;</span><br><span class="line">    <span class="keyword">char</span> type, oldtype = s[<span class="number">-1</span>] &amp; SDS_TYPE_MASK; <span class="comment">// 获取数据类型</span></span><br><span class="line">    <span class="keyword">int</span> hdrlen;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Return ASAP if there is enough space left. */</span></span><br><span class="line">    <span class="keyword">if</span> (avail &gt;= addlen) <span class="keyword">return</span> s; <span class="comment">// 如果可用空间大于请求的长度，则不需要增加空间</span></span><br><span class="line"></span><br><span class="line">    len = sdslen(s);</span><br><span class="line">    sh = (<span class="keyword">char</span>*)s-sdsHdrSize(oldtype);</span><br><span class="line">    newlen = (len+addlen);</span><br><span class="line">    <span class="keyword">if</span> (newlen &lt; SDS_MAX_PREALLOC) <span class="comment">// 2倍的新长度</span></span><br><span class="line">        newlen *= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        newlen += SDS_MAX_PREALLOC;</span><br><span class="line"></span><br><span class="line">    type = sdsReqType(newlen);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Don't use type 5: the user is appending to the string and type 5 is</span></span><br><span class="line"><span class="comment">     * not able to remember empty space, so sdsMakeRoomFor() must be called</span></span><br><span class="line"><span class="comment">     * at every appending operation. */</span></span><br><span class="line">    <span class="keyword">if</span> (type == SDS_TYPE_5) type = SDS_TYPE_8;</span><br><span class="line"></span><br><span class="line">    hdrlen = sdsHdrSize(type);</span><br><span class="line">    <span class="keyword">if</span> (oldtype==type) &#123;</span><br><span class="line">        newsh = s_realloc(sh, hdrlen+newlen+<span class="number">1</span>);  <span class="comment">// 如果类型保持不变，则增加原有长度</span></span><br><span class="line">        <span class="keyword">if</span> (newsh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        s = (<span class="keyword">char</span>*)newsh+hdrlen;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Since the header size changes, need to move the string forward,</span></span><br><span class="line"><span class="comment">         * and can't use realloc */</span></span><br><span class="line">        newsh = s_malloc(hdrlen+newlen+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (newsh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">memcpy</span>((<span class="keyword">char</span>*)newsh+hdrlen, s, len+<span class="number">1</span>); <span class="comment">// 如果类型发生改变，则重新申请新类型数据，并拷贝buf数据</span></span><br><span class="line">        s_free(sh);</span><br><span class="line">        s = (<span class="keyword">char</span>*)newsh+hdrlen;</span><br><span class="line">        s[<span class="number">-1</span>] = type;</span><br><span class="line">        sdssetlen(s, len);</span><br><span class="line">    &#125;</span><br><span class="line">    sdssetalloc(s, newlen);</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="sds与普通string的区别"><a href="#sds与普通string的区别" class="headerlink" title="sds与普通string的区别"></a>sds与普通string的区别</h2><h3 id="获取字符串长度复杂度"><a href="#获取字符串长度复杂度" class="headerlink" title="获取字符串长度复杂度"></a>获取字符串长度复杂度</h3><p>string获取字符串长度的时间复杂度为O(N)，需要遍历整个字符串；而sds不再需要遍历字符串，通过len字段可以直接获取存储在buf内字符串的长度，时间复杂度为O(1)。</p>
<h3 id="空间分配和释放"><a href="#空间分配和释放" class="headerlink" title="空间分配和释放"></a>空间分配和释放</h3><p>对于C语言来说，每一次字符串长度的增加，都会造成一次内存分配的操作；每一次字符串长度的减少，都会造成一次内存释放操作。如果redis同样需要平凡的内存分配和释放，对性能会造成严重的影响。</p>
<p>sds通过alloc字段来记录预分配空间的大小，len字段来记录当前存储字符串的长度。当有资源需要释放时，sds只是减少len的大小；当需要增加空间时，只有当剩余的空位不足，才会重新申请新的空间，否则只需要增加len的大小。</p>
]]></content>
      
        <categories>
            
            <category> cache </category>
            
        </categories>
        
        
        <tags>
            
            <tag> redis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[tire tree算法]]></title>
      <url>/2016/11/27/simWS-tire-tree/</url>
      <content type="html"><![CDATA[<p>tire tree称为查找树或字典树，插入和查询的复杂度为O(K)（K为被插入或查询的关键字长度）。<br><a id="more"></a></p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>tire tree的基本性质如下，</p>
<ul>
<li>根节点不包含任何字符</li>
<li>除根节点外每一个节点都仅包含一个字符</li>
<li>树的每一条路径的所有节点连接起来代表一个被添加的字符串</li>
</ul>
<p><img src="/images/tire-tree-1.png" alt=""></p>
<p>tire tree的核心思想是空间换时间，并利用字符串的公共前缀来降低查询时间的开销以及节约存储空间。</p>
<p>如图所示，“故事”和“故乡”拥有共同的前缀“故”，所以“故”只需要存储一次，达到了节约存储空间的目的。</p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="统计词频"><a href="#统计词频" class="headerlink" title="统计词频"></a>统计词频</h3><p>对于哈希和堆来说，tire tree的公共前缀可以有效降低内存空间，当需要统计的数据越多时，这个压缩的效果越明显。</p>
<h3 id="前缀匹配"><a href="#前缀匹配" class="headerlink" title="前缀匹配"></a>前缀匹配</h3><p>由于tire tree是按照前缀匹配来存储字符串的，那么查询字符串的复杂度只是O(K)，K为字符串的长度，因此，可以用来加载分词的词库。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>这里使用go来实现简单的tire树，完整代码：<a href="https://github.com/yxd123/simWS/blob/master/tire/tire.go。" target="_blank" rel="external">https://github.com/yxd123/simWS/blob/master/tire/tire.go。</a></p>
<h3 id="节点的定义"><a href="#节点的定义" class="headerlink" title="节点的定义"></a>节点的定义</h3><p>树的节点需要包含节点值、子节点指针、节点状态。</p>
<ul>
<li>节点值：当前节点存储的值</li>
<li>子节点指针：当前节点的子节点的指针（记录了当前节点的所有子节点）</li>
<li>节点状态：记录当前节点是否为代表字符串的结尾（用于判断以当前节点为结尾的字符串是否被添加过）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">type Node struct &#123;</span><br><span class="line">    value     byte //当前节点存储的值</span><br><span class="line">    nextNodes []*Node // 子节点指针</span><br><span class="line">    nextNums  int  //子节点个数</span><br><span class="line">    flag      bool //是否为结尾字符</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="节点的添加"><a href="#节点的添加" class="headerlink" title="节点的添加"></a>节点的添加</h3><p>节点的添加需要考虑几种情况：</p>
<ul>
<li>是否为公共前缀</li>
<li>是否为结尾字符</li>
</ul>
<p><code>values</code>代表需要添加的字符串，<code>place</code>代表当前需要处理的字符位置，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">func (t *Node) add(values []byte, place int) &#123;</span><br><span class="line">    // 达到字符串的末尾</span><br><span class="line">    if place &gt;= len(values) &#123;</span><br><span class="line">        t.flag = true</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   //如果没有子节点，需要添加新节点</span><br><span class="line">    if t.nextNodes == nil &#123;</span><br><span class="line">        log.Println(&quot;new nextNodes&quot;)</span><br><span class="line">        t.nextNodes = make([]*Node, 0, 26)</span><br><span class="line">        t.nextNums = 0</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if t.nextNums &gt; 0 &#123;</span><br><span class="line">        for _, node := range t.nextNodes &#123;</span><br><span class="line">            // 如果子节点中包含待添加字符，则递归添加下一节点</span><br><span class="line">            if node.value == values[place] &#123;</span><br><span class="line">                log.Println(&quot;duplicate byte:&quot;, string(node.value))</span><br><span class="line">                node.add(values, place + 1)</span><br><span class="line">                return</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 子节点无待添加字符，则添加新的子节点</span><br><span class="line">    node := NewNode(values[place])</span><br><span class="line">    node.add(values, place + 1)</span><br><span class="line">    t.nextNodes = append(t.nextNodes, node)</span><br><span class="line">    t.nextNums += 1</span><br><span class="line">    log.Println(&quot;add new Node:&quot;, string(node.value), t.nextNums)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="节点的查找"><a href="#节点的查找" class="headerlink" title="节点的查找"></a>节点的查找</h3><p>节点的查找和添加类似，都是从树的根节点开始，递归到目的节点。</p>
<p>节点的查找需要注意结尾标记。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">func (t *Node) find(values []byte, place int) bool &#123;</span><br><span class="line">    //如果没有子节点，则未查到</span><br><span class="line">    if t == nil || t.nextNums == 0 &#123;</span><br><span class="line">        log.Println(&quot;can&apos;t cmp&quot;, string(values[place]), &quot;nextNums:&quot;, string(t.value), t.nextNums)</span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for _, node := range t.nextNodes &#123;</span><br><span class="line">        log.Println(&quot;cmp:&quot;, string(node.value), string(values[place]))</span><br><span class="line">        // 找到待查找字符</span><br><span class="line">        if node.value == values[place] &#123;</span><br><span class="line">            //当前待查找字符为结尾，则找到目标字符串</span><br><span class="line">            if place == len(values) - 1 &#123;</span><br><span class="line">                return node.flag</span><br><span class="line">            &#125;</span><br><span class="line">            // 非结尾字符串，递归查找下一字符</span><br><span class="line">            return node.find(values, place + 1)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> algorithm </category>
            
        </categories>
        
        
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> 中文分词 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[编译原理（二）语法分析]]></title>
      <url>/2016/11/14/compiling-2/</url>
      <content type="html"><![CDATA[<p>语法分析是编译过程的一个逻辑阶段。语法分析的任务是在词法分析的基础上将单词序列组合成各类语法短语。<br><a id="more"></a></p>
<h2 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h2><p>目前语法分析常用的两类方法：</p>
<ul>
<li>自顶向下</li>
<li>自底向上</li>
</ul>
<p>本文采用自顶向下的分析方法。</p>
<h2 id="分析原理"><a href="#分析原理" class="headerlink" title="分析原理"></a>分析原理</h2><p>分析的目标是构造一个计算机可以识别的模型，在这里，使用语法树作为计算器的识别结构。 </p>
<p><img src="/images/compiling-2-1.jpeg" alt="图片1"></p>
<p>其中，节点的结构如上一篇文章中的定义（包含优先级、类型）。</p>
<h3 id="操作符定义"><a href="#操作符定义" class="headerlink" title="操作符定义"></a>操作符定义</h3><p>首先，需要定义所有操作符对应的方法(这里仅提供加、减、乘、除四中运算法方法)，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Opt(object):</span><br><span class="line">    @staticmethod</span><br><span class="line">    def add(self, children):</span><br><span class="line">        return children[0].value + children[1].value</span><br><span class="line"></span><br><span class="line">    @staticmethod</span><br><span class="line">    def sub(self, children):</span><br><span class="line">        return children[0].value - children[1].value</span><br><span class="line"></span><br><span class="line">    @staticmethod</span><br><span class="line">    def mux(self, children):</span><br><span class="line">        return children[0].value * children[1].value</span><br><span class="line"></span><br><span class="line">    @staticmethod</span><br><span class="line">    def div(self, children):</span><br><span class="line">        return children[0].value / children[1].value</span><br></pre></td></tr></table></figure>
<p>在构建语法树的时候，需要把操作符作为根节点来处理，其中加法操作对应的语法树如下,</p>
<p><img src="/images/compiling-2-2.jpeg" alt="图片2"></p>
<h3 id="节点定义与计算"><a href="#节点定义与计算" class="headerlink" title="节点定义与计算"></a>节点定义与计算</h3><p>语法树的节点可以是操作符，也可以是具体的值。但需要注意，所有的值应该是叶子节点，而操作符不可能为叶子节点。</p>
<p>节点定义包含：节点名称、节点优先级、节点类型、当前节点值以及子节点。</p>
<p>需要注意的是<code>在计算当前节点的值时是需要递归计算子树下所有节点的结果的</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">class ASTNode(object):</span><br><span class="line">    def __init__(self, token):</span><br><span class="line">        self.token = token</span><br><span class="line">        self.children = list()</span><br><span class="line"> </span><br><span class="line">    @property</span><br><span class="line">    def token_name(self):</span><br><span class="line">        return self.token.name</span><br><span class="line"></span><br><span class="line">    @property</span><br><span class="line">    def priority(self):</span><br><span class="line">        return self.token.priority</span><br><span class="line"></span><br><span class="line">    @property</span><br><span class="line">    def is_opt(self):</span><br><span class="line">        return self.token.type == TOKENTYPE.OPT</span><br><span class="line"></span><br><span class="line">    @property</span><br><span class="line">    def is_scp(self):</span><br><span class="line">        return self.token.type == TOKENTYPE.SCP</span><br><span class="line"></span><br><span class="line">    def add_child(self, child):</span><br><span class="line">        self.children.append(child)</span><br><span class="line"></span><br><span class="line">    def pop_child(self):</span><br><span class="line">        return self.children.pop()</span><br><span class="line"></span><br><span class="line">    @property</span><br><span class="line">    def value(self):</span><br><span class="line">        if self.is_opt:</span><br><span class="line">            return calcuate(self) # 递归计算得到该操作符的操作结果</span><br><span class="line">        else:</span><br><span class="line">            return self.token.value</span><br><span class="line"></span><br><span class="line">    def __str__(self):</span><br><span class="line">        if not self.is_opt:</span><br><span class="line">            return &apos;(leaf [%s])&apos; % self.token.value</span><br><span class="line">        else:</span><br><span class="line">            return &apos;(%s %s, %s)&apos; % (self.token_name, str(self.children[0]), </span><br><span class="line">                                    str(self.children[1]))</span><br><span class="line">    __repr__ =  __str__</span><br></pre></td></tr></table></figure>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>构造语法树可以使用递归的方式来处理，具体的思想如下：</p>
<ol>
<li>从左侧出发，遍历代码片段</li>
<li>判断操作符类型：值、操作符、停止符（括号）</li>
<li>比较当前操作符和上一次操作符的优先级，调整语法树结构：优先级小于等于上一次操作符，则把当前操作符作为根节点，原有语法树作为左子树，剩余代码片段作为待处理的右子树；优先级大于上一次操作符，则当前操作符替换上一次值的位置，上一次值作为当前操作符的做节点，剩余代码片段作为待处理的右子树。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">def parse(tokens, stop_name=None):</span><br><span class="line">    last_opt = None</span><br><span class="line">    for token in tokens:</span><br><span class="line">        if stop_name and token.name == stop_name:</span><br><span class="line">            return last_opt</span><br><span class="line">        node = ASTNode(token)</span><br><span class="line">        if node.is_opt:</span><br><span class="line">            next_node = ASTNode(tokens.next())</span><br><span class="line">            if next_node.is_scp:</span><br><span class="line">                next_node = parse(tokens, </span><br><span class="line">                    stop_name=TOKEN_SCP_MATCH.get(next_node.token_name))</span><br><span class="line">            if node.priority &lt;= last_opt.priority:</span><br><span class="line">                node.add_child(last_opt)</span><br><span class="line">                node.add_child(next_node)</span><br><span class="line">                last_opt = node</span><br><span class="line">            else:</span><br><span class="line">                node.add_child(last_opt.pop_child())</span><br><span class="line">                node.add_child(next_node)</span><br><span class="line">                last_opt.add_child(node)</span><br><span class="line">        else:</span><br><span class="line">            last_opt = node</span><br><span class="line">        print last_opt</span><br><span class="line">    return last_opt</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> cs </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 编译原理 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[编译原理（一）词法分析]]></title>
      <url>/2016/10/30/compiling-1/</url>
      <content type="html"><![CDATA[<p>词法分析（Lexical analysis）是完成编译程序的第一个阶段的工作。<br><a id="more"></a><br>词法分析是从左到右一个字符一个字符地读入源程序，即对构成源程序的字符流进行扫描然后根据构词规则识别单词(也称单词符号或符号)。词法分析程序实现这个任务。词法分析程序可以使用lex等工具自动生成。</p>
<h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><p>词法分析主要任务就是需要把由代码组成的字符串来识别出来，生成可以被识别的关键字序列。</p>
<p><img src="/images/compoling-1.jpeg" alt="图片1"></p>
<p>本文只实现了5种关键字类型，其中<code>IGN</code>是可悲忽略的字符，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 关键字类型</span><br><span class="line">class TOKENTYPE(object):</span><br><span class="line">    IGN = 0 # ignore</span><br><span class="line">    OPT = 1 # oprate</span><br><span class="line">    SCP = 1 # reserved</span><br><span class="line">    INT = 2 # int</span><br><span class="line">    STR = 3 # string</span><br></pre></td></tr></table></figure></p>
<p>对于不同的关键字需要对应的正则表达式来匹配该数据，并且需要预设关键字的优先级，例如，乘号的优先级高于加号，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 关键字定义</span><br><span class="line">class TokenRegex(object):</span><br><span class="line">    def __init__(self, regex, name,type=TOKENTYPE.OPT, priority=1):</span><br><span class="line">        self.regex = regex</span><br><span class="line">        self.name = name</span><br><span class="line">        self.type = type</span><br><span class="line">        self.priority = priority</span><br><span class="line">        self.value = None</span><br></pre></td></tr></table></figure></p>
<p>关键字定义如下，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">_TokenRegexs = (</span><br><span class="line">    TokenRegex(r&apos;\=&apos;, &apos;eq&apos;),</span><br><span class="line">    TokenRegex(r&apos;\+&apos;, &apos;add&apos;),</span><br><span class="line">    TokenRegex(r&apos;\-&apos;, &apos;sub&apos;),</span><br><span class="line">    TokenRegex(r&apos;\*&apos;, &apos;mux&apos;, priority=2),</span><br><span class="line">    TokenRegex(r&apos;\/&apos;, &apos;div&apos;, priority=2),</span><br><span class="line">    TokenRegex(r&apos;\(&apos;, &apos;(&apos;, type=TOKENTYPE.SCP, priority=3),</span><br><span class="line">    TokenRegex(r&apos;\)&apos;, &apos;)&apos;, type=TOKENTYPE.SCP, priority=3),</span><br><span class="line">    TokenRegex(r&apos;\&#123;&apos;, &apos;&#123;&apos;, type=TOKENTYPE.SCP, priority=3),</span><br><span class="line">    TokenRegex(r&apos;\&#125;&apos;, &apos;&#125;&apos;, type=TOKENTYPE.SCP, priority=3),</span><br><span class="line">    TokenRegex(r&apos;if&apos;, &apos;_if&apos;),</span><br><span class="line">    TokenRegex(r&apos;else&apos;, &apos;_else&apos;),</span><br><span class="line">    TokenRegex(r&apos;;&apos;, &apos;end&apos;),</span><br><span class="line">    TokenRegex(r&apos;[0-9]+&apos;, &apos;int&apos;,  type=TOKENTYPE.INT),</span><br><span class="line">    TokenRegex(r&apos;[a-zA-Z][a-zA-Z0-9_]*&apos;, &apos;str&apos;, type=TOKENTYPE.STR),</span><br><span class="line">    TokenRegex(r&apos;\n&apos;, &apos;enter&apos;, type=TOKENTYPE.IGN),</span><br><span class="line">    TokenRegex(r&apos; &apos;, &apos;blank&apos;, type=TOKENTYPE.IGN),</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>此外，还需要定义特殊关键子匹配规则，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TOKEN_SCP_MATCH = &#123;</span><br><span class="line">    &apos;(&apos;:  &apos;)&apos;,</span><br><span class="line">    &apos;&#123;&apos;:  &apos;&#125;&apos;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>递归遍历输入字符，生成对应的关键字链表，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">def lex(characters):</span><br><span class="line">    pos = 0 </span><br><span class="line">    length = len(characters)</span><br><span class="line">    while pos &lt; length:</span><br><span class="line">        for token_regex in _TokenRegexs:</span><br><span class="line">            regex = re.compile(token_regex.regex)</span><br><span class="line">            r = regex.match(characters, pos)</span><br><span class="line">            if r:</span><br><span class="line">                if token_regex.type is not TOKENTYPE.IGN:</span><br><span class="line">                    yield Token(r.group(0), token_regex)</span><br><span class="line">                pos = r.end(0)</span><br><span class="line">                break</span><br><span class="line">        else:</span><br><span class="line">            print &apos;char:&apos;, characters[pos]</span><br><span class="line">            sys.stderr.write(&apos;Illgal character: %s\n&apos; % characters[pos])</span><br><span class="line">            sys.exit(1)</span><br></pre></td></tr></table></figure></p>
<h3 id="关键字识别"><a href="#关键字识别" class="headerlink" title="关键字识别"></a>关键字识别</h3><p>关键字识别单元，用来存储每一个关键字的信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Token(object):</span><br><span class="line">    def __init__(self, value, token_regex):</span><br><span class="line">        self.value = int(value) if value.isdigit() else value</span><br><span class="line">        self.name = token_regex.name</span><br><span class="line">        self.type = token_regex.type</span><br><span class="line">        self.priority = token_regex.priority</span><br><span class="line"></span><br><span class="line">    def __repr__(self):</span><br><span class="line">        return &apos;&lt;Token(\&apos;%s\&apos;) %s %s&gt;&apos; % (self.name, self.value, self.priority)</span><br><span class="line"></span><br><span class="line">    def is_end(self):</span><br><span class="line">        return True if self.name == &apos;end&apos; else False</span><br></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> cs </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 编译原理 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[SimHash算法]]></title>
      <url>/2016/10/27/simhash/</url>
      <content type="html"><![CDATA[<p>Google采用这种算法来解决万亿级别的网页的去重任务。<br><a id="more"></a></p>
<p>由于实验室和互联网基本没啥关系，也就从来没有关注过数据挖掘相关的东西。在实际工作中，第一次接触到匹配和聚类等工作，虽然用一些简单的匹配算法可以做小数据的聚类，但数据量达到一定的时候就束手无策了。</p>
<p>所以，趁着周末把这方面的东西看了看，做个笔记。</p>
<h2 id="来历"><a href="#来历" class="headerlink" title="来历"></a>来历</h2><p>google的论文“detecting near-duplicates for web crawling”——–simhash。</p>
<h2 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h2><p>simhash算法的主要思想是降维，将高维的特征向量映射成一个低维的特征向量，通过两个向量的Hamming Distance来确定文章是否重复或者高度近似。</p>
<p>算法步骤：　　</p>
<ol>
<li>对于给定的一段语句，进行分词，得到有效的特征向量</li>
<li>为每一个特征向量设置一个权值</li>
<li>对每一个特征向量计算hash值，为01组成的n-bit签名</li>
<li>所有特征向量进行加权（1则为正，0则为负），然后累加</li>
<li>对于n-bit签名的累加结果，如果&gt;0置1，否则置0</li>
<li>得到该语句的simhash值</li>
<li>根据不同语句simhash的海明距离就来判断相似程度<br>　　<br>具体如图，<br><img src="/images/simhash.png" alt="simhash"></li>
</ol>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>simhash用于比较大文本，比如500字以上效果都还蛮好，距离小于3的基本都是相似，误判率也比较低。</p>
<p>这样的话，小文本呢？如何解决？</p>
<p><a href="http://blog.163.com/cindy_19810217/blog/static/20105911820104279560289/" target="_blank" rel="external">该博客</a>给出一个思路是，将短文本抽象出有序关键字，计算此有序字串的simhash值，寻找simhash相等的集合，缩小的搜索范围。还提到了并查集和bloom filter。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.lanceyan.com/tech/arch/simhash_hamming_distance_similarity.html" target="_blank" rel="external">http://www.lanceyan.com/tech/arch/simhash_hamming_distance_similarity.html</a><br><a href="http://www.cnblogs.com/zhengyun_ustc/archive/2012/06/12/sim.html" target="_blank" rel="external">http://www.cnblogs.com/zhengyun_ustc/archive/2012/06/12/sim.html</a><br><a href="http://blog.jobbole.com/21928/" target="_blank" rel="external">http://blog.jobbole.com/21928/</a></p>
]]></content>
      
        <categories>
            
            <category> algorithm </category>
            
        </categories>
        
        
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[软编码存储字典数据]]></title>
      <url>/2016/10/27/soft-coding/</url>
      <content type="html"><![CDATA[<p>采用非固定的字段来存储结构化的json数据。<br><a id="more"></a></p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>树形非固定字段的结构化数据是无法直接存储在mysql中的，需要把数据序列化，然后以字符串的方式存储，但是，如果把字段名称硬编码在字段内，对后期字段修改后的兼容性造成影响。</p>
<p>可参考：saas 插件式配置</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>把字段名称映射为字段，按照0_1_2的方式来存储，代表第三层的第二个数据（它的根节点为第二层的第一个数据），<br>字段名称这样就完全映射为了数字，所以还需要一个字段映射表来存储所有的字段与层级的映射关系。</p>
<p>此时，可以通过修改字段名称来实现字段名称的变化。</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># encoding: utf-8</span><br><span class="line"></span><br><span class="line">field_dict = dict()</span><br><span class="line"></span><br><span class="line">def f(d, layer):</span><br><span class="line">    if not isinstance(d, dict):</span><br><span class="line">        return d</span><br><span class="line">    r = dict()</span><br><span class="line">    i = 0</span><br><span class="line">    for k, v in d.items():</span><br><span class="line">        layer_key = &apos;%s_%d&apos; % (layer, i)</span><br><span class="line">        r[layer_key] = f(v, layer_key)</span><br><span class="line">        i += 1</span><br><span class="line">        if layer_key not in field_dict:</span><br><span class="line">            field_dict[layer_key] = k</span><br><span class="line">    return r</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">d = &#123;</span><br><span class="line">    &quot;id&quot;: 1,</span><br><span class="line">    &quot;name&quot;: &apos;y&apos;,</span><br><span class="line">    &apos;contact&apos;: &#123;</span><br><span class="line">        &apos;tel&apos;: &apos;13499991111&apos;,</span><br><span class="line">        &apos;email&apos;: &apos;y@y.com&apos;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">import json</span><br><span class="line"></span><br><span class="line">dd = f(d, &apos;0&apos;)</span><br><span class="line">print dd</span><br><span class="line">print json.dumps(d)</span><br><span class="line">print json.dumps(dd)</span><br><span class="line"></span><br><span class="line">print field_dict</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> algorithm </category>
            
        </categories>
        
        
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[selenium问题]]></title>
      <url>/2016/10/24/spider-selenium/</url>
      <content type="html"><![CDATA[<p>selenium可以用来动态解析页面数据，用于爬虫、测试等工作。<br><a id="more"></a></p>
<h2 id="install"><a href="#install" class="headerlink" title="install"></a>install</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install selenium</span><br></pre></td></tr></table></figure>
<h2 id="issue"><a href="#issue" class="headerlink" title="issue"></a>issue</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from selenium import webdriver</span><br><span class="line">driver = webdriver.Firefox()</span><br></pre></td></tr></table></figure>
<!--more-->
<p>报错，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">selenium.common.exceptions.WebDriverException: Message: &apos;geckodriver&apos; executable needs to be in PATH.</span><br></pre></td></tr></table></figure></p>
<p>出现的原因：<br>selenium 3.x需要firfox的驱动，而selenium 2.x是不需要该驱动的。</p>
<p>下载驱动，添加到环境变量中，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># download: https://github.com/mozilla/geckodriver/releases</span><br><span class="line"></span><br><span class="line">mv geckodriver /usr/local/bin/</span><br></pre></td></tr></table></figure></p>
<p>同理，在使用chrome作为浏览器时，需要下载chromedriver，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from selenium import webdriver</span><br><span class="line">driver = webdriver.Chrome()</span><br></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
            <tag> spider </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[spring注解annotion]]></title>
      <url>/2016/10/17/spring-annotion/</url>
      <content type="html"><![CDATA[<p>spring 注解配置和使用说明<br><a id="more"></a></p>
<h2 id="注解配置"><a href="#注解配置" class="headerlink" title="注解配置"></a>注解配置</h2><p>开启spring注解功能，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;context:annotation-config/&gt;</span><br></pre></td></tr></table></figure></p>
<p>它将隐式地向 Spring 容器注册<code>AutowiredAnnotationBeanPostProcessor</code>、<code>CommonAnnotationBeanPostProcessor</code>、<code>PersistenceAnnotationBeanPostProcessor</code>以及<code>RequiredAnnotationBeanPostProcessor</code> 这 4 个 BeanPostProcessor。</p>
<p>开启spring mvc注解功能，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;mvc:annotation-driven /&gt;</span><br></pre></td></tr></table></figure></p>
<p>它将隐式地向Spring容器注册<code>DefaultAnnotationHandlerMapping</code>和<code>AnnotationMethodHandlerAdapter</code>。</p>
<h2 id="Required"><a href="#Required" class="headerlink" title="Required"></a>Required</h2><p><code>@Required</code>注解用于检查被注解属性是否已经设置，但并不会检测属性是否为空。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Required</span><br><span class="line">public void setName(name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;person&quot; class=&quot;Persoon&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;name&quot; value=&quot;jack&quot; /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<p>如果bean中没有设置<code>name</code>，则会抛出BeanInitializationException异常。</p>
<h2 id="Autowired"><a href="#Autowired" class="headerlink" title="Autowired"></a>Autowired</h2><p><code>@Autowired</code>注解用于对类进行自动装配工作（按照类型注入）。</p>
<ul>
<li>在默认情况下使用 @Autowired 注释进行自动注入时，Spring 容器中匹配的候选 Bean 数目必须有且仅有一个。</li>
<li>当找不到一个匹配的 Bean 时，Spring 容器将抛出 BeanCreationException 异常，并指出必须至少拥有一个匹配的 Bean；</li>
<li>当不能确定 Spring 容器中一定拥有某个类的 Bean 时，可以在需要自动注入该类 Bean 的地方可以使用 @Autowired(required = false)，这等于告诉 Spring：在找不到匹配 Bean 时也不报错；</li>
<li>如果 Spring 容器中拥有多个候选 Bean，Spring 容器在启动时也会抛出 BeanCreationException 异常。</li>
</ul>
<blockquote>
<p>如果有多个候选的bean该如何处理？</p>
</blockquote>
<p><code>@Qualifier</code>可以用来指定注入的bean。<br><code>@Qualifier</code>是与<code>@Autowired</code>结合使用，这样就会把注入类型从按名称注入转变为按按名称注入。</p>
<p><code>@Autowired</code>可以用标记成员变量、方法以及构造函数，而<code>Qualifier</code>只可以用来标记成员变量、方法入参和苟赞函数入参。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class Student &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    @Qualifier(&quot;math&quot;) // 指定数学书</span><br><span class="line">    private Book book;</span><br><span class="line">    private Pen pen;</span><br><span class="line">   </span><br><span class="line">    @Autowired</span><br><span class="line">    public void setPen(@Qualifier(&quot;pencil&quot;)Pen pen) &#123;</span><br><span class="line">        this.pen = pen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Student &#123;</span><br><span class="line">    private Book book;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    public Student(Book book) &#123;</span><br><span class="line">        this.book = book;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Resource"><a href="#Resource" class="headerlink" title="Resource"></a>Resource</h2><p><code>@Resource</code>注解是按照名称来装配注入的，只有找不到对应的名称才会按照类型来装配注入。<br><code>@Resource</code>注解是由J2EE提供，而@Autowired是由spring提供。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Resource(name=&quot;math&quot;)</span><br><span class="line">private Book book;</span><br><span class="line"></span><br><span class="line">@Reousrce(type=Book.class)</span><br><span class="line">private Book book;</span><br></pre></td></tr></table></figure></p>
<p>一般情况下，无需使用type方式（反射可以获取类型）。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><code>@Service</code>用于标注业务层组件;</p>
<p><code>@Controller</code>用于标注控制层组件（如struts中的action）;</p>
<p><code>@Repository</code>用于标注数据访问组件，即DAO组件;</p>
<p><code>@Component</code>泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。</p>
]]></content>
      
        <categories>
            
            <category> web </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
            <tag> spring </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[spring bean]]></title>
      <url>/2016/10/10/spring-bean/</url>
      <content type="html"><![CDATA[<p>spring bean文件解析。<br><a id="more"></a></p>
<h2 id="beans"><a href="#beans" class="headerlink" title="beans"></a>beans</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">           http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br></pre></td></tr></table></figure>
<p><code>xmlns</code>是XML NameSpace的缩写，用来区分xml文件，类似java中的package。<br><code>xmlns:xsi</code>是XML Schema Instance的缩写，是指具体用到的schema资源文件里定义的元素所遵守的规范。<br><code>xsi:schemaLocation</code>是指文档遵守的xml规范，schemaLocation属性用来引用schema模式文档，解析器可以在需要的情况下使用该文档对XML实例文档校验。该值成对出现，第一个表示命名空间，的哥标示描述其命名空间的模式文档的具体问题。</p>
<h2 id="bean"><a href="#bean" class="headerlink" title="bean"></a>bean</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">    xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd&quot;&gt;</span><br><span class="line">    &lt;!-- 定义第一个Bean实例：bean1 --&gt;</span><br><span class="line">    &lt;bean id=&quot;bean1&quot; class=&quot;com.Bean1&quot; /&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;!-- 定义第二个Bean实例：bean2 --&gt;</span><br><span class="line">    &lt;bean id=&quot;bean2&quot; class=&quot;com.Bean2&quot; /&gt;</span><br><span class="line">    </span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<p><code>&lt;bean&gt;..&lt;/bean&gt;</code>代表一个bean实例，beans由多个bean实例组成。<br><code>id</code>是bean的唯一标识符，容器对bean的管理、访问以及依赖都需要该标志。<br><code>class</code>是bean的具体实现类，默认使用new关键字创建该bean实例。</p>
<h2 id="bean作用域"><a href="#bean作用域" class="headerlink" title="bean作用域"></a>bean作用域</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">    xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd&quot;&gt;</span><br><span class="line">    &lt;!-- 配置一个singleton Bean实例：默认 --&gt;</span><br><span class="line">    &lt;bean id=&quot;bean1&quot; class=&quot;com.Bean1&quot; /&gt;</span><br><span class="line">    &lt;!-- 配置一个prototype Bean实例 --&gt;</span><br><span class="line">    &lt;bean id=&quot;bean2&quot; class=&quot;com.Bean2&quot; scope=&quot;prototype&quot;/&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>
<p>spring中bean共包含五种模式，默认的作用域为单例模式，使用<code>scope</code>来显示的设置作用域。<br><code>singleton</code>单例模式，在每一个spring容器中，一个bean定义只有一个对象实例；<br><code>prototype</code>原型模式，允许bean被多次实例，每次调用都创建一个实例；<br><code>request</code>模式，在每一次http请求中，每个bean定义对应一个实例，该作用域在基于web的spring mvc中才有效；<br><code>session</code>模式，在一个http session中，每个bean定义对应一个实例，该作用域在基于web的spring mvc中才有效；<br><code>global-session</code>模式，在一个全局http session中，每一个bean对应一个实例，该作用阈仅在Portlet Context才有效。</p>
<h2 id="init-method-amp-destroy-method"><a href="#init-method-amp-destroy-method" class="headerlink" title="init-method&amp;destroy-method"></a>init-method&amp;destroy-method</h2><p><code>init-method</code>属性指定一个方法，在实例化bean时，立即调用该方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;bean1&quot; class=&quot;com.Bean1&quot; init-method=&quot;init&quot;&gt;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Bean1 &#123;</span><br><span class="line">    public void init() &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>destroy-method</code>属性制定一个方法，从容器中移除bean之后，才调用该方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;bean1&quot; class=&quot;com.Bean1&quot; destroy-method=&quot;init&quot;&gt;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Bean1 &#123;</span><br><span class="line">    public void destrory() &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>init-method</code>和<code>destroy-method</code>是无参函数。</p>
<p>此外，也可以通过实现<code>InitializingBean</code>和<code>DisposableBean</code>来实现初始化和销毁操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Bean1 implements InitializingBean &#123;</span><br><span class="line">    public void afterPropertiesSet() &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Bean1 implements DisposableBean &#123;</span><br><span class="line">    public void destroy() &#123;</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以通过在beans属性中设置default-init-method和default-destroy-method来批量设置bean的初始化和销毁操作。</p>
<p>最后，还通过使用注解的方式来配置初始化和销毁操作，<br>开启注解功能，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;context:annotation-config /&gt;</span><br></pre></td></tr></table></figure></p>
<p> 使用@PostConstruct注解初始化方法，使用@PreDestroy注解销毁方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import javax.annotation.PostConstruct;</span><br><span class="line">import javax.annotation.PreDestroy;</span><br><span class="line"></span><br><span class="line">public class UserDAO &#123;</span><br><span class="line">    @PreDestroy</span><br><span class="line">    public void destory()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;销毁方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @PostConstruct</span><br><span class="line">    public void init()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;初始化方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h2><p>依赖注入就是把代码的依赖关系使用配置的方式组织起来，同时保证代码的独立性。<br>依赖注入包含两种：基于构造函数的依赖注入和基于设值函数的依赖注入。</p>
<h3 id="基于构造函数"><a href="#基于构造函数" class="headerlink" title="基于构造函数"></a>基于构造函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Bean1 &#123;</span><br><span class="line">    public Bean2 bean2;</span><br><span class="line">    public Bean1(Bean2 bean2) &#123;</span><br><span class="line">        this.bean2 = bean2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Bean2 &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用代码硬编码依赖关系，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Bean2 bean2 = new Bean2();</span><br><span class="line">Bean1 bean1 = new Bean1(bean2);</span><br></pre></td></tr></table></figure></p>
<p>使用依赖注入，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line"></span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">   &lt;bean id=&quot;bean1&quot; class=&quot;com.Bean1&quot;&gt;</span><br><span class="line">      &lt;constructor-arg ref=&quot;bean2&quot;/&gt;</span><br><span class="line">   &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">   &lt;bean id=&quot;bean2&quot; class=&quot;com.Bean2&quot;/&gt;</span><br><span class="line">   &lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="基于设值函数"><a href="#基于设值函数" class="headerlink" title="基于设值函数"></a>基于设值函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Bean1 &#123;</span><br><span class="line">    private Bean2 bean2;</span><br><span class="line">    public setBean2(Bean2 bean2) &#123;</span><br><span class="line">        this.bean2 = bean2;</span><br><span class="line">    &#125;</span><br><span class="line">    public getBean2() &#123;</span><br><span class="line">        return bean2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Bean2 &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用代码硬编码依赖关系，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Bean2 bean2 = new Bean2();</span><br><span class="line">Bean1 bean1 = new Bean1();</span><br><span class="line">bean1.setBean2(bean2);</span><br></pre></td></tr></table></figure></p>
<p>使用依赖注入，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line"></span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">   &lt;bean id=&quot;bean1&quot; class=&quot;com.Bean1&quot;&gt;</span><br><span class="line">      &lt;property name=&quot;bean2&quot; ref=&quot;bean2&quot;/&gt;</span><br><span class="line">   &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">   &lt;bean id=&quot;bean2&quot; class=&quot;com.Bean2&quot;/&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="p-namespace"><a href="#p-namespace" class="headerlink" title="p-namespace"></a>p-namespace</h3><p>使用p-namespace来简化配置，增加<code>xmlns:p=&quot;http://www.springframework.org/schema/p&quot;</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line"></span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">    xmlns:p=&quot;http://www.springframework.org/schema/p&quot; </span><br><span class="line">    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">   &lt;bean id=&quot;bean1&quot; class=&quot;com.Bean1&quot;</span><br><span class="line">       p:bean2-ref=&quot;bean2&quot;&gt;</span><br><span class="line">   &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">   &lt;bean id=&quot;bean2&quot; class=&quot;com.Bean2&quot;/&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="注入集合类型参数"><a href="#注入集合类型参数" class="headerlink" title="注入集合类型参数"></a>注入集合类型参数</h3><p>目前spring提供了<code>list</code>，<code>set</code>，<code>map</code>和<code>props</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;property name=&quot;listParams&quot;&gt;</span><br><span class="line">    &lt;list&gt;</span><br><span class="line">        &lt;value&gt;param1&lt;/value&gt;</span><br><span class="line">        &lt;value&gt;param2&lt;/value&gt;</span><br><span class="line">    &lt;/list&gt;</span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;property name=&quot;setParams&quot;&gt;</span><br><span class="line">    &lt;set&gt;</span><br><span class="line">        &lt;value&gt;param1&lt;/value&gt;</span><br><span class="line">        &lt;value&gt;param2&lt;/value&gt;</span><br><span class="line">    &lt;/set&gt;</span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;property name=&quot;mapParams&quot;&gt;</span><br><span class="line">    &lt;map&gt;</span><br><span class="line">        &lt;entry key=&quot;key1&quot; value=&quot;param1&quot;/&gt;</span><br><span class="line">        &lt;entry key=&quot;key2&quot; value=&quot;param2&quot;/&gt;</span><br><span class="line">    &lt;/map&gt;</span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;property name=&quot;propsParams&quot;&gt;</span><br><span class="line">    &lt;props&gt;</span><br><span class="line">        &lt;prop key=&quot;key1&quot;&gt;param1&lt;/prop&gt;</span><br><span class="line">        &lt;prop key=&quot;key2&quot;&gt;param2&lt;/prop&gt;</span><br><span class="line">    &lt;/props&gt;</span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> web </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
            <tag> spring </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[thrift 入门]]></title>
      <url>/2016/08/22/rpc-thrift-install/</url>
      <content type="html"><![CDATA[<p>介绍thrift基本用法。<br><a id="more"></a></p>
<h2 id="install"><a href="#install" class="headerlink" title="install"></a>install</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install thrift</span><br></pre></td></tr></table></figure>
<h2 id="hello-example"><a href="#hello-example" class="headerlink" title="hello example"></a>hello example</h2><h3 id="maven"><a href="#maven" class="headerlink" title="maven"></a>maven</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.apache.thrift&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;libthrift&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;0.9.3&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;1.5.8&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>
<h3 id="IDL"><a href="#IDL" class="headerlink" title="IDL"></a>IDL</h3><p>编写thrift IDL文件hello.thrift，用于生成java代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">namespace java demo</span><br><span class="line"></span><br><span class="line">service HelloService &#123;</span><br><span class="line">    string hi()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="generate"><a href="#generate" class="headerlink" title="generate"></a>generate</h3><p>执行名声，生成java代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thrift -gen java hello.thrift</span><br></pre></td></tr></table></figure></p>
<p>此时，会在当前目录下生成java-gen文件夹，其中包含所需要的thrift接口文件<code>HelloService.java</code>.</p>
<h3 id="impl"><a href="#impl" class="headerlink" title="impl"></a>impl</h3><p>上步中生成了相应的HelloServie.Iface接口，所以需要实现该接口文件，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package demo;</span><br><span class="line"></span><br><span class="line">public class HelloImpl implements HelloService.Iface &#123;</span><br><span class="line">    public String hi() &#123;</span><br><span class="line">        return &quot;Hi!!!&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="server"><a href="#server" class="headerlink" title="server"></a>server</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package demo;</span><br><span class="line"></span><br><span class="line">import org.apache.thrift.server.TServer;</span><br><span class="line">import org.apache.thrift.server.TSimpleServer;</span><br><span class="line">import org.apache.thrift.transport.TServerSocket;</span><br><span class="line">import org.apache.thrift.transport.TServerTransport;</span><br><span class="line"></span><br><span class="line">public class Server &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        HelloImpl hello = new HelloImpl();</span><br><span class="line">        final HelloService.Processor&lt;HelloImpl&gt; p =</span><br><span class="line">                new HelloService.Processor&lt;HelloImpl&gt;(hello);</span><br><span class="line"></span><br><span class="line">        new Thread(new Runnable() &#123;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    TServerTransport st = new TServerSocket(9000);</span><br><span class="line">                    TServer tServer = new TSimpleServer(new TServer.Args(st).processor(p));</span><br><span class="line">                    System.out.println(&quot;Starting ...&quot;);</span><br><span class="line">                    tServer.serve();</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="client"><a href="#client" class="headerlink" title="client"></a>client</h3><p>注意server使用的端口9000，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package demo;</span><br><span class="line"></span><br><span class="line">import org.apache.thrift.TException;</span><br><span class="line">import org.apache.thrift.protocol.TBinaryProtocol;</span><br><span class="line">import org.apache.thrift.protocol.TProtocol;</span><br><span class="line">import org.apache.thrift.transport.TSocket;</span><br><span class="line">import org.apache.thrift.transport.TTransport;</span><br><span class="line"></span><br><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) throws TException &#123;</span><br><span class="line">        TTransport ts = new TSocket(&quot;localhost&quot;, 9000);</span><br><span class="line">        ts.open();</span><br><span class="line"></span><br><span class="line">        TProtocol p = new TBinaryProtocol(ts);</span><br><span class="line">        HelloService.Client client = new HelloService.Client(p);</span><br><span class="line"></span><br><span class="line">        System.out.println(client.hi());</span><br><span class="line"></span><br><span class="line">        ts.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
            <tag> rpc </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[mysql自增主键]]></title>
      <url>/2016/08/22/mysql-auto-increment/</url>
      <content type="html"><![CDATA[<p>介绍mysql auto increment。<br><a id="more"></a></p>
<h2 id="auto-increment"><a href="#auto-increment" class="headerlink" title="auto increment"></a>auto increment</h2><p><code>mysql</code>的自增步长可以通过下面的命令查询，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW VARIABLES LIKE &apos;auto_inc%&apos;;</span><br><span class="line">+--------------------------+-------+</span><br><span class="line">| Variable_name            | Value |</span><br><span class="line">+--------------------------+-------+</span><br><span class="line">| auto_increment_increment | 1     |</span><br><span class="line">| auto_increment_offset    | 1     |</span><br><span class="line">+--------------------------+-------+</span><br></pre></td></tr></table></figure>
<p>其中，<code>auto_increment_increment</code>是自增的步长，value为1代表每次+1，<code>auto_increment_offset</code>是自增的偏移量，也就是自增开始，value为1代表从1开始增加。</p>
<p>InnoDB自增主键是通过本身的自增计数器获取，该方式会通过表锁机制完成。<br>表锁只有在插入结束后才释放，也就是事务完成后。</p>
<p>为了解决自增主键锁表的问题，引入了<code>innodb_autoinc_lock_mode</code>，通过轻量级互斥量的增长机制来完成。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;innodb_autoinc_lock_mode&apos;;</span><br><span class="line">+--------------------------+-------+</span><br><span class="line">| Variable_name            | Value |</span><br><span class="line">+--------------------------+-------+</span><br><span class="line">| innodb_autoinc_lock_mode | 1     |</span><br><span class="line">+--------------------------+-------+</span><br></pre></td></tr></table></figure></p>
<p><code>innodb_autoinc_lock_mode</code>的取值有三种：</p>
<ul>
<li>0，表锁</li>
<li>1，默认值，互斥量，会“预申请”多余的值，可能会出现不连续的情况</li>
<li>2，自增值不连续，性能好</li>
</ul>
<p>参数innodb_autoinc_lock_mode = 1时，每次会预申请多余的id(handler.cc:compute_next_insert_id)，而insert执行完成后，会特别将这些预留的id空出，就是特意将预申请后的当前最大id回写到表中</p>
<blockquote>
<p>最近就发现一次一个数据表由于频繁的<code>insert on duplicate key update</code>导致了表的不连续，具体原因是该数据会预分配id但如果插入失败执行更新操作，那么该id就被废弃了，而下一条插入操作会跳过该值。 </p>
</blockquote>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>在mysql主主同步时（两台机器互相同步数据），需要设置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auto_increment_increment = 2</span><br><span class="line">auto_increment_offset = 1 和 2</span><br></pre></td></tr></table></figure></p>
<p>这样才能避免两台服务器同时做更新时自增字段的值之间的冲突。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><a href="http://www.cnblogs.com/zhoujinyi/p/3433823.html" target="_blank" rel="external">http://www.cnblogs.com/zhoujinyi/p/3433823.html</a><br><a href="http://blog.csdn.net/yanzongshuai/article/details/46476151" target="_blank" rel="external">http://blog.csdn.net/yanzongshuai/article/details/46476151</a></p>
]]></content>
      
        <categories>
            
            <category> db </category>
            
        </categories>
        
        
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[python 迭代器和生成器]]></title>
      <url>/2016/08/09/python-iter-gen/</url>
      <content type="html"><![CDATA[<p>python迭代器和生成器简单介绍。<br><a id="more"></a></p>
<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>迭代器是一个实现了迭代器协议的对象，Python中的迭代器协议就是有next方法的对象会前进到下一结果，而在一系列结果的末尾是，则会引发StopIteration。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; l = range(2)</span><br><span class="line">&gt;&gt;&gt; i = iter(l)</span><br><span class="line">&gt;&gt;&gt; i</span><br><span class="line">&lt;listiterator object at 0x10a38d990&gt;</span><br><span class="line">&gt;&gt;&gt; i.next()</span><br><span class="line">0</span><br><span class="line">&gt;&gt;&gt; i.next()</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; i.next()</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure>
<p>在for循环中，Python将自动调用工厂函数iter()获得迭代器，自动调用next()获取元素，还完成了检查StopIteration异常的工作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 当发生StopIteration异常，退出循环</span><br><span class="line">for a in range(2):</span><br><span class="line">    print a</span><br></pre></td></tr></table></figure>
<p>常用的几个内建数据结构tuple、list、set、dict都支持迭代器，字符串也可以使用迭代操作。</p>
<p>你也可以自己实现一个迭代器，如上所述，只需要在类的<strong>iter</strong>方法中返回一个对象，这个对象拥有一个next()方法，这个方法能在恰当的时候抛出StopIteration异常即可。但是需要自己实现迭代器的时候不多，即使需要，使用生成器会更轻松。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, input_list)</span>:</span></span><br><span class="line">        self.list = input_list</span><br><span class="line">        self.i = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">next</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.i == len(self.list):</span><br><span class="line">            self.i = <span class="number">0</span></span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line">        self.i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span>  self.list[self.i - <span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>使用迭代器一个显而易见的好处就是：每次只从对象中读取一条数据，不会造成内存的过大开销。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/* 把文件一次加载到内存中，然后逐行打印。当文件很大时，这个方法的内存开销就很大了 */</span><br><span class="line">for line in open(&quot;test.txt&quot;).readlines():</span><br><span class="line">    print line</span><br><span class="line"></span><br><span class="line">/* 这是最简单也是运行速度最快的写法，他并没显式的读取文件，而是利用迭代器每次读取下一行 */</span><br><span class="line">for line in open(&quot;test.txt&quot;):   #use file iterators</span><br><span class="line">    print line</span><br></pre></td></tr></table></figure>
<h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><p>生成器的编写方法和函数定义类似，只是在return的地方改为yield。</p>
<p>生成器中可以有多个yield。当生成器遇到一个yield时，会暂停运行生成器，返回yield后面的值。当再次调用生成器的时候，会从刚才暂停的地方继续运行，直到下一个yield。</p>
<p>生成器自身又构成一个迭代器，每次迭代时使用一个yield返回的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def gen():</span><br><span class="line">...     yield 1</span><br><span class="line">...     yield 2</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; a = gen()</span><br><span class="line">&gt;&gt;&gt; a.next()</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; a.next()</span><br><span class="line">2</span><br><span class="line">&gt;&gt;&gt; a.next()</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">StopIteration</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，生成器中不需要return语句，不需要指定返回值，在生成器中已经存在默认的返回语句</p>
<h3 id="生成器表达式"><a href="#生成器表达式" class="headerlink" title="生成器表达式"></a>生成器表达式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(i for i in range(5))</span><br><span class="line">// 返回迭代器</span><br><span class="line">&lt;generator object &lt;genexpr&gt; at 0x7ff3e8f0d960&gt;</span><br></pre></td></tr></table></figure>
<h3 id="列表解析，返回list"><a href="#列表解析，返回list" class="headerlink" title="列表解析，返回list"></a>列表解析，返回list</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[i for i in range(5)]</span><br><span class="line">// 返回list</span><br><span class="line">[0, 1, 2, 3, 4]</span><br></pre></td></tr></table></figure>
<p>在这里存在一个问题，那就是range(5)会返回一个长度为5的数据，如果是range(1000)那么就会占用一个1000大小的数组空间；如果我们采用<code>生成器</code>，在需要的时候产生一个数字，那么空间的占用情况就会降低，这里我们可以使用xrange()函数来实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">xrange</span><br><span class="line">    函数说明：用法与range完全相同，所不同的是生成的不是一个数组，而是一个生成器。</span><br><span class="line">xrange示例:</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; xrange(5)</span><br><span class="line">xrange(5)</span><br><span class="line">&gt;&gt;&gt; list(xrange(5))</span><br><span class="line">[0, 1, 2, 3, 4]</span><br><span class="line">&gt;&gt;&gt; xrange(1,5)</span><br><span class="line">xrange(1, 5)</span><br><span class="line">&gt;&gt;&gt; list(xrange(1,5))</span><br><span class="line">[1, 2, 3, 4]</span><br><span class="line">&gt;&gt;&gt; xrange(0,6,2)</span><br><span class="line">xrange(0, 6, 2)</span><br><span class="line">&gt;&gt;&gt; list(xrange(0,6,2))</span><br><span class="line">[0, 2, 4]</span><br></pre></td></tr></table></figure>
<p>所以xrange做循环的性能比range好，尤其是返回很大的时候，尽量用xrange吧，除非你是要返回一个列表。</p>
]]></content>
      
        <categories>
            
            <category> python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[mysql中的null]]></title>
      <url>/2016/08/08/mysql-null/</url>
      <content type="html"><![CDATA[<p>null一般用来代表某个字段还没有被赋值，而not null被认为某字段不允许为空，那么在使用中到底该注意哪些内容？<br><a id="more"></a></p>
<h2 id="query"><a href="#query" class="headerlink" title="query"></a>query</h2><p>如果需要查询字段内容为null的数据，不可以直接用<code>expr = null</code>来查询，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from test where name = null;</span><br></pre></td></tr></table></figure></p>
<p>上面的查询是错误的，因为<code>expr = null</code> 永远都是false，及时expr字段被设置为null。<br>应该使用下面的方式<code>expr is null</code>来过滤，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from test where name is null;</span><br></pre></td></tr></table></figure></p>
<p>在<code>GROUP BY</code>中，null会被认为是相同的；<br>在<code>ORDER BY ... ASC</code>中, null会被放在最前面。</p>
<h2 id="storage"><a href="#storage" class="headerlink" title="storage"></a>storage</h2><p>在MyISAM中，null需要增加一个额外的空间来表明该字段为null，<br>在InnoDB中，null可以使变长字段不会占用存储空间，但需要一个标志位来表明该行为null。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">REDUNDANT</span><br><span class="line">* null占用1/2 bytes</span><br><span class="line">* 如果字段是可变长的，data parts为空</span><br><span class="line">* 固定长度的字段，null 2 not null 不会造成索引页的碎片</span><br><span class="line"></span><br><span class="line">COMPACT</span><br><span class="line">* record header包含</span><br></pre></td></tr></table></figure></p>
<h2 id="performance"><a href="#performance" class="headerlink" title="performance"></a>performance</h2><p>在mysql中对于MyISAM、InnoDB、MEMORY，允许使用包含null的字段作为索引。<br>但是，在《High Performance MySQL:Optimization》中指出：</p>
<p>  Mysql难以优化引用可空列查询，它会使索引、索引统计和值更加复杂。可空列需要更多的存储空间，还需要mysql内部进行特殊处理。可空列被索引后，每条记录都需要一个额外的字节，还能导致MyISAM中固定大小的索引变成可变大小的索引。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://dev.mysql.com/doc/refman/5.5/en/problems-with-null.html" target="_blank" rel="external">http://dev.mysql.com/doc/refman/5.5/en/problems-with-null.html</a><br><a href="http://stackoverflow.com/questions/229179/null-in-mysql-performance-storage" target="_blank" rel="external">http://stackoverflow.com/questions/229179/null-in-mysql-performance-storage</a><br><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-physical-record.html" target="_blank" rel="external">https://dev.mysql.com/doc/refman/5.7/en/innodb-physical-record.html</a></p>
]]></content>
      
        <categories>
            
            <category> db </category>
            
        </categories>
        
        
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ZeroCopy零拷贝]]></title>
      <url>/2016/07/12/linux-zero-copy/</url>
      <content type="html"><![CDATA[<p>本文将简单介绍一下0拷贝的原理。<br><a id="more"></a></p>
<h2 id="传统的IO"><a href="#传统的IO" class="headerlink" title="传统的IO"></a>传统的IO</h2><p>服务器在对静态文件进行处理时，需要从硬盘读取静态文件，然后再通过socket返回数据。在这个过程中，数据在内核和用户态之间切换，都会进行数据复制，影响数据传输的效率。</p>
<p><strong>四次内存拷贝</strong></p>
<p>调用read函数会产生一次系统调用sys_read，通过DMA将数据拷贝到内核模式;<br>cpu将内核模式数据拷贝到用户模式的buffer;<br>read函数返回后，write函数将用户模式下buffer数据拷贝到内核模式的socket buffer中;<br>通过DMA将数据从socket buffer中拷贝到网卡缓存中.</p>
<p><img src="/images/linux-zero-copy-1.gif" alt=" 4 copy "></p>
<p><strong>三次上下文的切换</strong></p>
<p>read会造成一次从用户态到内核态的上下文切换;<br>read返回会造成一次从内核态到用户态的上下文切换;<br>write会造成一次从用户态到内核态的上下文切换;<br>write返回造成一次从内核态到用户态的上下文切换.</p>
<p><img src="/images/linux-zero-copy-2.gif" alt=" 3 switch "></p>
<h2 id="zero-copy"><a href="#zero-copy" class="headerlink" title="zero copy"></a>zero copy</h2><p>零拷贝是通过避免不必要的拷贝和状态切换来提高性能的。</p>
<p>对于传统IO来说，在user和kernel之间的数据拷贝是非必须的，所以Linux提供了一种sendfile技术来提高性能。</p>
<p>在Linux中，提供了sendfile系统调用来避免两次数据拷贝，应用包括nginx和lighttpd，而在JAVA中，transferTo函数通过一次系统调用，减少了原来read和send的切换，数据直接从read buffer拷贝到socket buffer中，避免了两次copy操作，应用有kafka和netty。</p>
<p><img src="/images/linux-zero-copy-3.gif" alt=" 2 copy "></p>
<p>同时，上下文切换也降低为两次，</p>
<p><img src="/images/linux-zero-copy-4.gif" alt=" 2 switch "></p>
]]></content>
      
        <categories>
            
            <category> cs </category>
            
        </categories>
        
        
        <tags>
            
            <tag> linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[锁与mysql中的锁]]></title>
      <url>/2016/07/02/db-lock/</url>
      <content type="html"><![CDATA[<p>锁是并发控制主要的技术手段。<br><a id="more"></a></p>
<h2 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h2><p>Pessimistic Concurrency Control</p>
<p>悲观锁是假设数据冲突的可能性很大，每次更新数据都会锁定数据，直到更新操作完成。</p>
<p>在对数据进行更新之前，需要对数据添加排他锁，如果成功，执行更新操作，否则，抛出异常提示执行失败，表明该数据正在被修改。更新成功后，释放排他锁，该数据可用于其他更新操作。</p>
<h2 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h2><p>Optimistic Concurrency Control</p>
<p>乐观锁是假设数据一般不会造成冲突，只有在数据进行提交更新的时候，才会对数据的冲突与否进行验证，如果冲突返回错误信息，待用户进一步处理。</p>
<p>为数据增加一个新的属性版本标识，每当读取数据时，都会把数据的版本信息同时读取出来，每当需要更新数据时，都会数据对应的版本信息与上一次读取的版本信息做对比，只有版本信息相同（数据未被更改）时，才予以更新，否则认为数据已过期。</p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>由于乐观锁的版本对比特性，每次更新都需要进行版本检查，造成了开销，所以它更适合多读得场景，也就是冲突较少的情况（避免过多的版本对比的开销）；反之，写操作较多，冲突较多的场景，更适合使用悲观锁，这样不需要重复的对比开销。</p>
<p>memcached使用CAS（compare and set）乐观锁来解决冲突问题。</p>
<p>redis使用乐观锁来实现事务操作（redis中的事务是把事务中的操作加入到一个执行队列中，直到exec命令开始执行）。</p>
<p>传统关系型数据库中的行锁、表锁都属于悲观锁。</p>
<h2 id="locking-in-MySQL"><a href="#locking-in-MySQL" class="headerlink" title="locking in MySQL"></a>locking in MySQL</h2><p>mysql中常见的锁：行锁、表锁、页锁。</p>
<h3 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h3><p>row-level locking </p>
<p>行级锁是mysql中锁的力度最小的一种，只会当前操作的行进行加锁，但它开销大，加锁慢。</p>
<p>Innodb支持行级锁，但它的实现是通过对索引加锁来实现的，因此只有通过索引来检索数据才会触发行级锁。</p>
<p>由于innodb中的行级锁是逐步获取的，那么有可能造成死锁。</p>
<h3 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h3><p>table-level locking</p>
<p>表级锁是对当前操作的整个数据表加锁，它的实现就比较简单，开销小。</p>
<p>它包括：排他锁和共享锁。</p>
<p>InnoDB和MyISAM都支持表级锁。</p>
<h3 id="页级锁"><a href="#页级锁" class="headerlink" title="页级锁"></a>页级锁</h3><p>page-level locking</p>
<p>页级锁是介于行锁和表锁粒度之间的一种锁，BDB支持，但可能造成死锁。</p>
<h2 id="共享锁、排他锁、意向锁"><a href="#共享锁、排他锁、意向锁" class="headerlink" title="共享锁、排他锁、意向锁"></a>共享锁、排他锁、意向锁</h2><p>共享锁属于行锁，又称为读锁，允许其他用户读取数据，但任何事务都不可以更改数据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from student lock in share mode;</span><br></pre></td></tr></table></figure></p>
<p>排他锁属于行锁，又称为写锁，不允许其他用户的操作（包括写和读）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from student for update;</span><br></pre></td></tr></table></figure></p>
<p>意向锁属于表锁，在InooDB中会自动加意向锁。<br>意向锁分为两种，意向共享锁和意向排他锁。<br>执行insert/update/delete语句时，InnoDB会自动给数据添加意向排他锁，而执行select语句不会加锁。</p>
]]></content>
      
        <categories>
            
            <category> db </category>
            
        </categories>
        
        
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[jetty简介]]></title>
      <url>/2016/06/25/jetty/</url>
      <content type="html"><![CDATA[<p>jetty是一个开源的<code>servlet</code>容器。<br><a id="more"></a></p>
<h2 id="jetty-amp-tomcat"><a href="#jetty-amp-tomcat" class="headerlink" title="jetty &amp; tomcat"></a>jetty &amp; tomcat</h2><ul>
<li>jetty构架更简单</li>
<li>jetty基于Handler实现，tomcat基于容器设计</li>
<li>jetty适合处理长连接，tomcat适合处理短连接</li>
<li>jetty采用NIO，tomcat采用BIO（不适合处理静态资源）</li>
</ul>
<h2 id="example"><a href="#example" class="headerlink" title="example"></a>example</h2><p>IDE:<code>IntelliJ Idea 15</code></p>
<h3 id="配置SDK"><a href="#配置SDK" class="headerlink" title="配置SDK"></a>配置SDK</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Configure -&gt; Settings -&gt; Project Structure</span><br><span class="line">Edit Project SDK</span><br></pre></td></tr></table></figure>
<h3 id="创建maven项目intelliJ新建一个maven项目"><a href="#创建maven项目intelliJ新建一个maven项目" class="headerlink" title="创建maven项目intelliJ新建一个maven项目"></a>创建maven项目intelliJ新建一个<code>maven</code>项目</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Create New Project -&gt; maven</span><br><span class="line">选择 maven-archetype-webapp</span><br><span class="line">填写 GroupId和ArtifactId</span><br><span class="line">next ...</span><br></pre></td></tr></table></figure>
<h3 id="添加jetty依赖"><a href="#添加jetty依赖" class="headerlink" title="添加jetty依赖"></a>添加jetty依赖</h3><p>添加jetty插件：<code>org.mortbay.jetty</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">  &lt;finalName&gt;demo&lt;/finalName&gt;</span><br><span class="line">  &lt;plugins&gt;</span><br><span class="line">    &lt;plugin&gt;</span><br><span class="line">      &lt;groupId&gt;org.mortbay.jetty&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;maven-jetty-plugin&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;6.1.26&lt;/version&gt;</span><br><span class="line">      &lt;configuration&gt;</span><br><span class="line">        &lt;connectors&gt;</span><br><span class="line">          &lt;connector implementation=&quot;org.mortbay.jetty.nio.SelectChannelConnector&quot;&gt;</span><br><span class="line">            &lt;port&gt;8080&lt;/port&gt;</span><br><span class="line">          &lt;/connector&gt;</span><br><span class="line">        &lt;/connectors&gt;</span><br><span class="line">        &lt;scanIntervalSeconds&gt;10&lt;/scanIntervalSeconds&gt;</span><br><span class="line">      &lt;/configuration&gt;</span><br><span class="line">    &lt;/plugin&gt;</span><br><span class="line">  &lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="编辑启动命令"><a href="#编辑启动命令" class="headerlink" title="编辑启动命令"></a>编辑启动命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Edit Configurations</span><br><span class="line">Command line: jetty:run</span><br><span class="line">启动后，访问:127.0.0.1:8080/demo</span><br></pre></td></tr></table></figure>
<h3 id="spring-mvc-with-jetty"><a href="#spring-mvc-with-jetty" class="headerlink" title="spring mvc with jetty"></a>spring mvc with jetty</h3><p>增加<code>spring</code>依赖<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-core&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-context&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;javax.servlet&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;servlet-api&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;$&#123;servlet.version&#125;&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;jstl&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;jstl&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;$&#123;jstl.version&#125;&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p>
<p>对应的版本信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;properties&gt;</span><br><span class="line">  &lt;spring.version&gt;4.2.5.RELEASE&lt;/spring.version&gt;</span><br><span class="line">  &lt;spring-data.version&gt;1.2.0.RELEASE&lt;/spring-data.version&gt;</span><br><span class="line">  &lt;servlet.version&gt;2.5&lt;/servlet.version&gt;</span><br><span class="line">  &lt;jstl.version&gt;1.2&lt;/jstl.version&gt;</span><br><span class="line">&lt;/properties&gt;</span><br></pre></td></tr></table></figure>
<p>配置web.xml</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;servlet&gt;</span><br><span class="line">  &lt;servlet-name&gt;mvc-dispatcher&lt;/servlet-name&gt;</span><br><span class="line">  &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;</span><br><span class="line">  &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;</span><br><span class="line">&lt;/servlet&gt;</span><br><span class="line"></span><br><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">  &lt;servlet-name&gt;mvc-dispatcher&lt;/servlet-name&gt;</span><br><span class="line">  &lt;url-pattern&gt;/&lt;/url-pattern&gt;</span><br><span class="line">&lt;/servlet-mapping&gt;</span><br></pre></td></tr></table></figure>
<p>配置对应的servlet<br>在web.xml所在目录，新建mvc-dispatcher-servlet.xml</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--指定controller位置--&gt;</span><br><span class="line">    &lt;context:component-scan base-package=&quot;controller&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;jspViewResolver&quot; class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;viewClass&quot; value=&quot;org.springframework.web.servlet.view.JstlView&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/pages/&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>
<p>创建webapp/WEB-INF/pages/index.jsp</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;zh-CN&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;</span><br><span class="line">    &lt;!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ --&gt;</span><br><span class="line">    &lt;title&gt;SpringMVC Demo 首页&lt;/title&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 新 Bootstrap 核心 CSS 文件 --&gt;</span><br><span class="line">    &lt;link rel=&quot;stylesheet&quot; href=&quot;//cdn.bootcss.com/bootstrap/3.3.5/css/bootstrap.min.css&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries --&gt;</span><br><span class="line">    &lt;!-- WARNING: Respond.js doesn&apos;t work if you view the page via file:// --&gt;</span><br><span class="line">    &lt;!--[if lt IE 9]&gt;</span><br><span class="line">    &lt;script src=&quot;//cdn.bootcss.com/html5shiv/3.7.2/html5shiv.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script src=&quot;//cdn.bootcss.com/respond.js/1.4.2/respond.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;![endif]--&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;SpringMVC Demo&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">&lt;h3&gt;出现此页面，说明配置成功。&lt;/h3&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- jQuery文件。务必在bootstrap.min.js 之前引入 --&gt;</span><br><span class="line">&lt;script src=&quot;//cdn.bootcss.com/jquery/1.11.3/jquery.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 最新的 Bootstrap 核心 JavaScript 文件 --&gt;</span><br><span class="line">&lt;script src=&quot;//cdn.bootcss.com/bootstrap/3.3.5/js/bootstrap.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>创建src/main/java/controller/IndexController.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package controller;</span><br><span class="line"></span><br><span class="line">import org.springframework.stereotype.Controller;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMethod;</span><br><span class="line"></span><br><span class="line">@Controller</span><br><span class="line">public class IndexController &#123;</span><br><span class="line">    @RequestMapping(value = &quot;/&quot;, method = RequestMethod.GET)</span><br><span class="line">    public String index() &#123;</span><br><span class="line">        return &quot;index&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
            <tag> jetty </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[tcp常见问题]]></title>
      <url>/2016/05/31/tcp-term/</url>
      <content type="html"><![CDATA[<p>记录tcp中常见的问题和答案。<br><a id="more"></a></p>
<h2 id="FIN"><a href="#FIN" class="headerlink" title="FIN"></a>FIN</h2><p>FIN是终止一个方向的连接请求，需要四次握手的原因是TCP的半关闭。</p>
<h2 id="TIME-WAIT"><a href="#TIME-WAIT" class="headerlink" title="TIME_WAIT"></a>TIME_WAIT</h2><p><code>TIME_WAIT</code>状态也称为2MSL等待状态，MSL为最大报文段最大生存时间(Maximum Segment Lifetime)。</p>
<p>需要注意，处于TIME_WAIT状态的端口是不能被使用，</p>
<p>一般情况下，客户端主动断开连接，处于TIME_WAIT状态，该端口无法使用，但是，如果服务器主动断开连接，那么TIME_WAIT状态的服务器端口不能被立即重用（需要等待1~4分钟）。</p>
<p><strong>为什么需要TIME_WAIT？</strong></p>
<p>TCP是建立在不可靠网络的可靠协议。在主动关闭一方接收到被动关闭方发送的FIN后，回应ACK并进入TIME_WAIT状态，但是由于网络的不可靠，主动关闭回应的ACK可能会产生延迟，从而触发被动一方重传FIN。极端情况下，重传的往返时间就是2MSL，因此，TIME_WAIT状态是为了提高不可靠的网络中通信的可靠性。</p>
<p><strong>解决大量TIME_WAIT？</strong></p>
<p>可配置参数，具体内容google：</p>
<ul>
<li>ip_contrack </li>
<li>tcp_tw_recycle 回收</li>
<li>tcp_tw_reuse 复用</li>
<li>tcp_max_tw_buckets 总数设置</li>
</ul>
<h2 id="CLOSE-WAIT"><a href="#CLOSE-WAIT" class="headerlink" title="CLOSE_WAIT"></a>CLOSE_WAIT</h2><p>CLOSE_WAIT状态是被动关闭方回应ACK之后的状态，也是在发送FIN给主动关闭方之前的状态。<br>一般来所CLOSE_WAIT的持续时间较长，至少为2小时，该端口将一直被占用。</p>
<p><strong>出现CLOSE_WAIT的原因？</strong><br>可能是在关闭连接之前有许多数据需要发送，也就是说被动关闭方自身存在问题。</p>
<p><strong>解决CLOSE_WAIT？</strong><br>需要在业务层面判断连接是否已被对端关闭。</p>
<h2 id="三次握手和四次握手的原因"><a href="#三次握手和四次握手的原因" class="headerlink" title="三次握手和四次握手的原因"></a>三次握手和四次握手的原因</h2><p>TCP建立连接时，客户端主动连接，服务器被动连接，因此，可以复用第二次握手来传递SYN/ACK，</p>
<p>但是，TCP断开连接时，断开连接的顺序不是固定的，客户端和服务器都有可能主动断开连接（同时断开连接），所以不可以复用握手。</p>
<p>此外，另外一种情况也回产生四次握手：</p>
<p>两个应用程序同时主动打开，发送SYN，那么两端接收后会变为SYN_RCVD状态，再分别发送SYN、ACK进行确认，而且只会建立一条连接。</p>
<h2 id="请求不存在端口"><a href="#请求不存在端口" class="headerlink" title="请求不存在端口"></a>请求不存在端口</h2><p>当一个数据报到达目的端口时，如果该端口未被使用，</p>
<ul>
<li>UDP返回ICMP不可达信息</li>
<li>TCP使用复位</li>
</ul>
<h2 id="Half-Open"><a href="#Half-Open" class="headerlink" title="Half-Open"></a>Half-Open</h2><p>半打开连接是指一方关闭连接或异常终止连接而另外一方却不知情的情况。<br>只要不打算在半打开连接上传输数据，仍处于连接状态的一方就不会检测另一方的异常状态。</p>
<h2 id="backlog"><a href="#backlog" class="headerlink" title="backlog"></a>backlog</h2><p><code>socket listen</code>参数中的backlog，是指TCP呼入连接请求队列的长度。<br>请求队列是用来存储那些三次握手连接，但并没有被应用层接受的连接，如果请求队列满了，TCP不会对SYN做出反应，从而迫使客户端TCP重传。</p>
]]></content>
      
        <categories>
            
            <category> cs </category>
            
        </categories>
        
        
        <tags>
            
            <tag> tcp </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[spring mvc框架]]></title>
      <url>/2016/05/19/spring-mvc/</url>
      <content type="html"><![CDATA[<p>spring web mvc 是一种基于JAVA实现的web框架，它根据MVC思想将web进行职责解耦。<br><a id="more"></a></p>
<h2 id="Componet"><a href="#Componet" class="headerlink" title="Componet"></a>Componet</h2><p>spring mvc包括以下组件，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Dispatcher Servlet - 前端控制器</span><br><span class="line">Handler Mapping - 处理器映射器</span><br><span class="line">Controller - 页面控制器</span><br><span class="line">View Resolver - 试图解析器</span><br></pre></td></tr></table></figure></p>
<h2 id="How-to-use-in-eclipse"><a href="#How-to-use-in-eclipse" class="headerlink" title="How to use in eclipse"></a>How to use in eclipse</h2><p>需要提前安装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java</span><br><span class="line">eclipse</span><br><span class="line">tomcat</span><br><span class="line">maven</span><br></pre></td></tr></table></figure></p>
<h3 id="new-dynamic-web-project"><a href="#new-dynamic-web-project" class="headerlink" title="new dynamic web project"></a>new dynamic web project</h3><p>新建动态web工程：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">File -&gt; other -&gt; web -&gt; dynamic web project</span><br></pre></td></tr></table></figure></p>
<p>设置：<br>项目名称、服务器版本</p>
<h3 id="maven-project"><a href="#maven-project" class="headerlink" title="maven project"></a>maven project</h3><p>转换为<code>maven</code>工程：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">properties -&gt; configure -&gt; convert to maven project</span><br></pre></td></tr></table></figure></p>
<h3 id="add-dependencies"><a href="#add-dependencies" class="headerlink" title="add dependencies"></a>add dependencies</h3><p>利用maven来管理依赖，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pom.xml -&gt; dependencies</span><br><span class="line">add -&gt; </span><br><span class="line"></span><br><span class="line">groupId - artifactId - version</span><br><span class="line">------------</span><br><span class="line">org.springframework - spring-context - 4.2.5.RELEASE</span><br><span class="line">org.springframework - spring-aop - 4.2.5.RELEASE</span><br><span class="line">org.springframework - spring-webmvc - 4.2.5.RELEASE</span><br><span class="line">org.springframework - spring-web - 4.2.5.RELEASE</span><br><span class="line">javax.servlet - jstl - 1.2</span><br><span class="line">commons-logging - commons-logging - 1.1.3</span><br><span class="line">------------</span><br></pre></td></tr></table></figure></p>
<h3 id="add-hello-servlet-xml"><a href="#add-hello-servlet-xml" class="headerlink" title="add hello-servlet.xml"></a>add hello-servlet.xml</h3><p><code>&lt;context:componet-scan&gt;</code>用来设置需要加载的控制类所在的包，<br><code>&lt;bean id=&quot;viewResolver&quot; ... &gt;</code>用来解析view并自动添加前缀和后缀</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">	xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</span><br><span class="line">	xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">	xsi:schemaLocation=&quot;</span><br><span class="line">        http://www.springframework.org/schema/beans     </span><br><span class="line">        http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">        http://www.springframework.org/schema/mvc </span><br><span class="line">        http://www.springframework.org/schema/mvc/spring-mvc.xsd</span><br><span class="line">        http://www.springframework.org/schema/context </span><br><span class="line">        http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; </span><br><span class="line">	&lt;context:component-scan base-package=&quot;com.hello&quot; /&gt;</span><br><span class="line">	&lt;bean id=&quot;viewResolver&quot;</span><br><span class="line">		class=&quot;org.springframework.web.servlet.view.UrlBasedViewResolver&quot;&gt;</span><br><span class="line">		&lt;property name=&quot;viewClass&quot;</span><br><span class="line">			value=&quot;org.springframework.web.servlet.view.JstlView&quot; /&gt;</span><br><span class="line">		&lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt;</span><br><span class="line">		&lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;</span><br><span class="line">	&lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>
<h3 id="add-web-xml"><a href="#add-web-xml" class="headerlink" title="add web.xml"></a>add web.xml</h3><p><code>&lt;servlet-name&gt;</code>设置<code>servlet.xml</code>文件的名称，如下对应的应该为<code>hello-servlet.xml</code>，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot; version=&quot;3.0&quot;&gt;</span><br><span class="line">  &lt;display-name&gt;SpringMVC&lt;/display-name&gt;</span><br><span class="line">  &lt;welcome-file-list&gt;</span><br><span class="line">    &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt;</span><br><span class="line">  &lt;/welcome-file-list&gt;</span><br><span class="line">    &lt;servlet&gt;</span><br><span class="line">        &lt;servlet-name&gt;hello&lt;/servlet-name&gt;</span><br><span class="line">        &lt;servlet-class&gt;</span><br><span class="line">            org.springframework.web.servlet.DispatcherServlet</span><br><span class="line">        &lt;/servlet-class&gt;</span><br><span class="line">        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;</span><br><span class="line">    &lt;/servlet&gt;</span><br><span class="line">    &lt;servlet-mapping&gt;</span><br><span class="line">        &lt;servlet-name&gt;hello&lt;/servlet-name&gt;</span><br><span class="line">        &lt;url-pattern&gt;/welcome.jsp&lt;/url-pattern&gt;</span><br><span class="line">        &lt;url-pattern&gt;/welcome.html&lt;/url-pattern&gt;</span><br><span class="line">        &lt;url-pattern&gt;*.html&lt;/url-pattern&gt;</span><br><span class="line">    &lt;/servlet-mapping&gt;</span><br><span class="line">&lt;/web-app&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="add-controller-class"><a href="#add-controller-class" class="headerlink" title="add  controller class"></a>add  controller class</h3><p>添加包<code>com.hello.controller</code>以及Hello控制类，<br>定义映射关系<code>welcome</code>，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package com.hello.controller;</span><br><span class="line"></span><br><span class="line">import org.springframework.stereotype.Controller;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.servlet.ModelAndView;</span><br><span class="line">  </span><br><span class="line">@Controller</span><br><span class="line">public class Hello &#123; </span><br><span class="line">	@RequestMapping(&quot;/welcome&quot;)</span><br><span class="line">	public ModelAndView helloWorld() &#123;</span><br><span class="line">		String message = &quot;Hello&quot;;</span><br><span class="line">		return new ModelAndView(&quot;welcome&quot;, &quot;message&quot;, message);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中，<code>ModelAndView</code>对象会解析<code>view</code>并把结果返回给请求端，<code>message</code>是传递给<code>view</code>的值。<br>那么，根据<code>hello-servlet.xml</code>中的设置，<code>welcome</code>会自动补全为<code>/WEB-INF/jsp/welcome.jsp</code>。</p>
<h3 id="add-view"><a href="#add-view" class="headerlink" title="add view"></a>add view</h3><p>添加默认页面<code>index.jsp</code>,<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;Spring MVC Tutorial Series by Crunchify.com&lt;/title&gt;</span><br><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">body &#123;</span><br><span class="line">	background-image: url(&apos;http://crunchify.com/bg.png&apos;);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">	&lt;br&gt;</span><br><span class="line">	&lt;div style=&quot;text-align:center&quot;&gt;</span><br><span class="line">		&lt;h2&gt;</span><br><span class="line">			This is your Spring MCV&lt;br&gt;</span><br><span class="line">		&lt;/h2&gt;</span><br><span class="line">		&lt;h3&gt;</span><br><span class="line">			&lt;a href=&quot;welcome.html&quot;&gt;Click here to See Welcome Message... &lt;/a&gt;</span><br><span class="line">		&lt;/h3&gt;</span><br><span class="line">	&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>
<p>添加<code>welcome.jsp</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1&gt;$&#123;message&#125;&lt;/h1&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="maven-build"><a href="#maven-build" class="headerlink" title="maven build"></a>maven build</h3><p><code>maven</code>编译，在<code>target</code>目录产生编译结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">properties -&gt; run as -&gt; maven build ... </span><br><span class="line">Add Goals:</span><br><span class="line">----</span><br><span class="line">clean install</span><br><span class="line">----</span><br></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> web </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
            <tag> spring </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[maven简介]]></title>
      <url>/2016/05/17/maven/</url>
      <content type="html"><![CDATA[<p>maven是一个项目管理和自动化工具。<br><a id="more"></a></p>
<h2 id="project"><a href="#project" class="headerlink" title="project"></a>project</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$&#123;basedir&#125; # 子目录，存放有pom.xml</span><br><span class="line">$&#123;basedir&#125;/src/main/java  # 项目源码</span><br><span class="line">$&#123;basedir&#125;/src/main/resource # 项目资源</span><br><span class="line">$&#123;basedir&#125;/src/test/java # 单元测试</span><br><span class="line">$&#123;basedir&#125;/src/test/resource # 测试资源</span><br><span class="line">$&#123;basedir&#125;/target # 编译结果</span><br></pre></td></tr></table></figure>
<h2 id="Download"><a href="#Download" class="headerlink" title="Download"></a>Download</h2><p>site: <a href="http://maven.apache.org/download.cgi" target="_blank" rel="external">http://maven.apache.org/download.cgi</a></p>
<h2 id="Configure"><a href="#Configure" class="headerlink" title="Configure"></a>Configure</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># ~/.bash_profile 或 ~/.zhsrc</span><br><span class="line">export MAVEN_HOME=/path/to/maven</span><br><span class="line">export PATH=$&#123;PATH&#125;:$&#123;MAVEN_HOME&#125;/bin</span><br></pre></td></tr></table></figure>
<p>执行<code>mvn -v</code>，查看是否配置成功</p>
<h2 id="Eclipse-plugin"><a href="#Eclipse-plugin" class="headerlink" title="Eclipse plugin"></a>Eclipse plugin</h2><p>通过eclipse的<code>install new software</code>来安装:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">maven-plugin: http://download.eclipse.org/technology/m2e/releases</span><br></pre></td></tr></table></figure></p>
<h2 id="Use-maven-with-eclipse"><a href="#Use-maven-with-eclipse" class="headerlink" title="Use maven with eclipse"></a>Use maven with eclipse</h2><h3 id="create-maven-project"><a href="#create-maven-project" class="headerlink" title="create maven project"></a>create maven project</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">File -&gt; Other -&gt; Maven -&gt; Maven Project</span><br><span class="line">Group Id: com.test.app # 项目的唯一标识符，实际对应包结构</span><br><span class="line">Artifact Id:  quickstart    # 具体的项目名称</span><br><span class="line">Version:  0.0.1                # 项目版本</span><br></pre></td></tr></table></figure>
<p>此时，会生成一个名为<code>quickstart</code>。</p>
<h3 id="add-dependencies-to-quickstart"><a href="#add-dependencies-to-quickstart" class="headerlink" title="add dependencies to quickstart"></a>add dependencies to quickstart</h3><p>对该项目添加<code>json</code>依赖，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pom.xml -&gt; Depndencies -&gt; add(left)</span><br><span class="line">Group Id: com.google.code.gson</span><br><span class="line">Artifact Id: gson</span><br><span class="line">Version:  2.3.1</span><br></pre></td></tr></table></figure></p>
<h3 id="use-gson"><a href="#use-gson" class="headerlink" title="use gson"></a>use gson</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class App &#123;</span><br><span class="line">    public printJson(String s) &#123;</span><br><span class="line">        Gson gson = new Gson();</span><br><span class="line">        System.out.println(gson.toJson(s));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="maven-build"><a href="#maven-build" class="headerlink" title="maven build"></a>maven build</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">quickstart -&gt; properties -&gt; run as -&gt; maven build</span><br></pre></td></tr></table></figure>
<h3 id="use-quickstart-jar"><a href="#use-quickstart-jar" class="headerlink" title="use quickstart.jar"></a>use quickstart.jar</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import com.test.app.App;</span><br><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line">    public static void main( String[] args ) &#123;</span><br><span class="line">        App app = new App();</span><br><span class="line">        app.printJson(&quot;hello world&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
            <tag> maven </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[同步、异步、阻塞、非阻塞]]></title>
      <url>/2016/04/26/block-sync/</url>
      <content type="html"><![CDATA[<p>简单介绍同步、异步、阻塞等问题。<br><a id="more"></a></p>
<h2 id="阻塞和非阻塞"><a href="#阻塞和非阻塞" class="headerlink" title="阻塞和非阻塞"></a>阻塞和非阻塞</h2><blockquote>
<p>阻塞和非阻塞的区别之处在于程序等待调用结果后的状态（等待与否）。</p>
</blockquote>
<h3 id="阻塞-blocking"><a href="#阻塞-blocking" class="headerlink" title="阻塞 blocking"></a>阻塞 blocking</h3><p>调用结果返回前，程序会被挂起，直到调用结果返回。</p>
<h3 id="非阻塞-non-blocking"><a href="#非阻塞-non-blocking" class="headerlink" title="非阻塞 non blocking"></a>非阻塞 non blocking</h3><p>程序不会等待调用结果的返回，不会导致当前程序的挂起。</p>
<p>socket read操作：<br>阻塞情况：内核请求从缓冲区读取数据，程序挂起，直到缓冲区内数据准备好，数据从内核拷贝到read进程中<br>非阻塞情况：内核请求从缓冲区读取数据，如果未准备好，不等待，直接返回，重复上面的过程</p>
<h2 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h2><blockquote>
<p>同步和异步的区别在于消息的通信机制。</p>
</blockquote>
<h3 id="同步-synchronous"><a href="#同步-synchronous" class="headerlink" title="同步 synchronous"></a>同步 synchronous</h3><p>发起一个调用后，在没有得到结果之前，调用不会返回，直到返回调用结果。</p>
<h3 id="异步-asynchronous"><a href="#异步-asynchronous" class="headerlink" title="异步 asynchronous"></a>异步 asynchronous</h3><p>发起一个调用后，直接返回，而调用结果通过其他方式来通知调用者（利用触发机制来通知处理消息者）。</p>
<p>可以参考node.js中的异步操作</p>
]]></content>
      
        <categories>
            
            <category> cs </category>
            
        </categories>
        
        
        <tags>
            
            <tag> linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MyISAM与InnoDB对比]]></title>
      <url>/2016/04/15/MyISAM-InnoDB/</url>
      <content type="html"><![CDATA[<p>总结myisam与innodb的区别。<br><a id="more"></a></p>
<h2 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h2><p><code>MyISAM</code>使用<code>B+tree</code>作为索引结构，叶节点存放的是<code>数据地址</code>。</p>
<p><code>MyISAM</code>不支持事务和外键。</p>
<p><code>MyISAM</code>是表锁，对数据库写操作时会锁住整个表，效率低。</p>
<p><code>MyISAM</code>支持全文索引。</p>
<p><code>MyISAM</code>设计结构简单，适合<code>read密集</code>的表。</p>
<p><code>MyISAM</code>支持索引压缩，可以加载更多索引。</p>
<h2 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h2><p><code>InnoDB</code>同样使用<code>B+tree</code>作为索引结构，但是叶节点存储的是<code>完整的数据</code>。</p>
<p><code>InnoDB</code>支持事务和外键，在发生故障时可以通过事务日志来回复数据库。</p>
<p><code>InnoDB</code>是行锁，只锁定一行数据，因此写操作很快。</p>
<p><code>InnoDB</code>不支持全文索引。</p>
<p><code>InnoDB</code>对于<code>write和update密集</code>的性能更好（由于行级锁的原因）。</p>
<blockquote>
<p>参考：<a href="http://stackoverflow.com/questions/15678406/when-to-use-myisam-and-innodb" target="_blank" rel="external">http://stackoverflow.com/questions/15678406/when-to-use-myisam-and-innodb</a></p>
</blockquote>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ul>
<li><p>叶节点数据存放的不同，指针和完整数据</p>
</li>
<li><p>是否支持事务和外键</p>
</li>
<li><p>设计的区别，适合读密集还是写密集</p>
</li>
<li><p>锁的区别，表锁和行锁(如果<code>InnoDB</code>不能确定扫描范围，则需要对全表锁定)</p>
</li>
<li><p>是否支持全文索引</p>
</li>
<li><p><code>select count(*)</code>的区别，<code>MyISAM</code>保存行数(如果由<code>where</code>则扫描全表)，而<code>InnoDB</code>扫描全表</p>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> db </category>
            
        </categories>
        
        
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[redis总结]]></title>
      <url>/2016/04/07/redis-summary/</url>
      <content type="html"><![CDATA[<p>总结redis。<br><a id="more"></a></p>
<h2 id="redis与memcached"><a href="#redis与memcached" class="headerlink" title="redis与memcached"></a>redis与memcached</h2><ul>
<li>redis支持更多的数据结构</li>
<li>redis支持数据持久化</li>
</ul>
<blockquote>
<p>redis支持两种存储方式：snapshot(快照)和aof(append only mode)，快照是定时将内存快照持久化到硬盘（crash会丢失数据），aof是在写入数据的同时将操作命令保存到日志（不会丢失数据，但操作日志管理维护成本高）</p>
</blockquote>
<ul>
<li>redis单线程，memcached是多线程的</li>
<li>redis修改libevent实现小巧的epoll，memcached完全依赖libevent（性能影响）</li>
<li>memcached使用CAS避免资源竞争修改，redis提供了事务功能</li>
</ul>
<blockquote>
<p>CAS是通过为每一个cacke key设置一个隐藏的cas token作为版本号，每次set操作都会检查并更新token</p>
</blockquote>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><p><code>string</code>是key/value的存储结构（同memcached一样），支持的命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">get/set/del</span><br><span class="line">incr/incrby</span><br><span class="line">decr/descby</span><br><span class="line">append/strlen</span><br><span class="line">getrange/setrange</span><br></pre></td></tr></table></figure>
<p><strong>问题</strong>：计数</p>
<p>一般情况都需要额外使用锁来避免并发写的问题。</p>
<p>解决方法：</p>
<p>使用<code>incr</code>命令来实现原子递增，使用<code>get/set</code>来重置计数状态。</p>
<blockquote>
<p>与memcached相同，可作为key/value数据库，例如session共享。</p>
</blockquote>
<h2 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h2><p><code>hash</code>的value实际上是一个hashmap，可以直接操作value的各个feild的值，支持的命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hset/hget/hgetall</span><br><span class="line">hmset/hmget</span><br><span class="line">hlen/hexists</span><br><span class="line">hkeys/hvals</span><br></pre></td></tr></table></figure>
<p><code>hash</code>两种实现方式，</p>
<ul>
<li>当数据较少时，为了节省内存采用线性存储来节省空间</li>
<li>当数据较多时，才会使用hashmap来降低时间复杂度</li>
</ul>
<p><strong>问题</strong>：商品维度计数<br>商品有各种计数（喜欢、评论、鉴定、浏览等）<br>解决方法：<br>使用<code>hash</code>的<code>field</code>字段来存储喜欢、评论等计数值。</p>
<p>同理，用户维度计数（动态、关注、粉丝、喜欢、发帖等）。</p>
<blockquote>
<p>该存储结构适用于常用的商品、热门新闻动态等经常被大量访问的数据对象。</p>
</blockquote>
<h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><p><code>list</code>通过双向链表实现，支持反向查找和遍历，支持的命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lpush/rpush</span><br><span class="line">lpop/rpop</span><br><span class="line">lrange/lrem</span><br></pre></td></tr></table></figure>
<p>利用<code>push</code>和<code>pop</code>操作可以实现消息队列，也可以实现关注列表、粉丝/在线好友列表等功能。</p>
<p><strong>问题</strong>：显示最新的项目列表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM foo WHERE ... ORDER BY TIME DESC LIMIT 10;</span><br></pre></td></tr></table></figure>
<p>数据库上的查询语句如上，随着数据的增多，排序会越来越慢。<br>解决方法：</p>
<ul>
<li>为每一条数据选择一个唯一的ID（可选自增ID）</li>
<li>缓存最新的N个数据，利用<code>redis</code>做数据缓存（<code>list</code>结构不断LPUSH最新的数据）</li>
<li>当查询内容超过<code>redis</code>缓存内容后，才会穿透缓存访问数据库</li>
</ul>
<p><strong>消息队列</strong>的实现：</p>
<ul>
<li>用<code>list</code>数据结构作为channel</li>
<li>生产者lpush消息</li>
<li>消费者rpop消息</li>
<li>设定超时时间</li>
</ul>
<blockquote>
<p>上述消息队列与PUB/SUB相比，不会丢失数据，但也没有失败重传的机制（也就是没有消息状态）</p>
</blockquote>
<h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p><code>set</code>是一个不允许重复的数据组合，支持的命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sadd/spop</span><br><span class="line">sismembers</span><br><span class="line">sinter/sunion/sdiff</span><br></pre></td></tr></table></figure>
<p><code>smembers</code>可以用来实现好友列表中判断是否为已存在好友或关注好友，也可以通过集合操作来实现共同好友、共同兴趣、共同关注列表等。</p>
<p><strong>问题</strong>：判断微博的共同好友、共同兴趣、是否为关注好友<br>解决方法：</p>
<ul>
<li>利用set集合存储用户的好友ID</li>
<li>通过<code>sismembers</code>判断用户是否存在好友集合中</li>
<li>通过<code>sinter</code>来判断两个好友集合的共同好友</li>
<li>通过<code>sunion</code>来获取两个集合的所有好友</li>
<li>通过<code>sdiff</code>来获取两个集合的非共同好友，用于好友推荐</li>
</ul>
<h3 id="sorted-set"><a href="#sorted-set" class="headerlink" title="sorted set"></a>sorted set</h3><p><code>sorted set</code>是有序的<code>set</code>，通过提供一个优先级<code>score</code>来实现自动排序，支持的命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zadd/zrem</span><br><span class="line">zrange/zcard</span><br></pre></td></tr></table></figure></p>
<p><code>score</code>可以用来实现权重队列，也可以实现按时间、评分的自动排序列表。</p>
<p><strong>问题</strong>：在线游戏实时排行榜<br>在线游戏的排行榜都需要实时更新操作，不可能去频繁地更改关系型数据库，<br>解决方法：</p>
<ul>
<li>为用户设置唯一的ID，采用<code>sorted set</code>来存储用户的得分情况</li>
<li>利用有序集合来对用户得分进行排名，这里不可能存储全部的用户，可能只关心前100个用户，那么就需要在redis之外做限制</li>
</ul>
<p><strong>问题</strong>：新闻排序<br>新闻排序是按照新闻的关注度（点击率）和时间做排序，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">score = points / (time^alpha)</span><br></pre></td></tr></table></figure></p>
<p>上面的公式可以说明，点击率越高，越可能获得更多的评分；时间越久远，也会降低新闻的评分。<br>因此，需要有一个专门用于计算新闻评分的进程，实时地处理最新的N条数据<br>解决方法：</p>
<ul>
<li>拉取最新的N条数据</li>
<li>计算各个数据的评分</li>
<li>添加到有序集合中</li>
</ul>
<h3 id="Pub-Sub"><a href="#Pub-Sub" class="headerlink" title="Pub/Sub"></a>Pub/Sub</h3><p>实现消息队列、实时消息系统。</p>
<h3 id="Transactions"><a href="#Transactions" class="headerlink" title="Transactions"></a>Transactions</h3><p><code>redis</code>提供事务的支持，</p>
<ul>
<li>事务可以一次执行多个命令，多个命令按照顺序执行，不会被其他客户单的命令所打断</li>
<li>事务是原子操作，要么全部执行，要么不执行</li>
</ul>
<p>使用方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; MULTI</span><br><span class="line">&gt; ...</span><br><span class="line">&gt; EXEC</span><br></pre></td></tr></table></figure></p>
<p>错误处理：</p>
<ul>
<li>在EXEC之前产生的错误，<code>redis</code>会自动放弃这个事务</li>
<li>在EXEC之后产生的错误，并没有特殊处理</li>
</ul>
<h2 id="其他应用"><a href="#其他应用" class="headerlink" title="其他应用"></a>其他应用</h2><ul>
<li>实时统计，而全量操作数据记录到log日志，利用Hadoop进行更全面的离线分析</li>
<li>web缓存，减轻数据库压力</li>
</ul>
]]></content>
      
        <categories>
            
            <category> cache </category>
            
        </categories>
        
        
        <tags>
            
            <tag> redis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Btree 索引]]></title>
      <url>/2016/03/22/btree/</url>
      <content type="html"><![CDATA[<blockquote>
<p>索引是帮助数据库高效获取数据的一种数据结构，通过提取句子主干，就可以得到索引的本质。<br><a id="more"></a></p>
</blockquote>
<h2 id="m-way查找树"><a href="#m-way查找树" class="headerlink" title="m-way查找树"></a>m-way查找树</h2><p>如果想了解<code>Btree</code>，需要首先了解<code>m-way</code>数据结构。<br><!--more--></p>
<p><code>m-way</code>查找树是是一种树形的存储结构，主要特点如下，</p>
<ul>
<li>每个节点存储的key数量小于m个</li>
<li>每个节点的度小于等于m</li>
<li>节点key按顺序排序</li>
<li>子树key值要完全小于、大于或介于父节点之间</li>
</ul>
<p>例如，<br>3-way如图，m为3，那么每个节点最多拥有为2个（m-1），<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">待索引元素列表为：</span><br><span class="line">[5, 7, 12, 6, 8, 3, 4]</span><br></pre></td></tr></table></figure></p>
<p><img src="/images/btree-1.png" alt=""></p>
<h2 id="Btree查找树"><a href="#Btree查找树" class="headerlink" title="Btree查找树"></a>Btree查找树</h2><p><code>Btree</code>是一种平衡的<code>m-way</code>查找树，它可以利用多个分支节点（子树节点）来减少查询数据时所经历的节点数，从而达到节省存取时间的目的。</p>
<p>主要特点如下，</p>
<ul>
<li>每个节点的key数量小于m个（与m-way相同）</li>
<li>除根节点和叶子节点的其他节点存储key的个数必须大于等于<code>m/2</code></li>
<li>所有叶子节点都处于同一层，也就是说所有叶节点具有相同的深度h（树的高度，也意味着树是平衡的）</li>
</ul>
<h3 id="Btree的查找"><a href="#Btree的查找" class="headerlink" title="Btree的查找"></a>Btree的查找</h3><p>必须从根节点开始采用二分法查找，所以时间复杂度为<code>O（logn）</code>。</p>
<h3 id="Btree的插入"><a href="#Btree的插入" class="headerlink" title="Btree的插入"></a>Btree的插入</h3><p>为了保证树的平衡，如果带插入节点的key数量小于m-1个，则直接插入（不会违反第一条特性），否则，需要将该节点分为两部分，再执行该操作。</p>
<p><img src="/images/btree-2.png" alt=""></p>
<blockquote>
<p>详细插入操作可参考:<a href="http://www.cnblogs.com/yangecnu/p/introduce-b-tree-and-b-plus-tree.html" target="_blank" rel="external">http://www.cnblogs.com/yangecnu/p/introduce-b-tree-and-b-plus-tree.html</a></p>
</blockquote>
<h2 id="B-tree查找树"><a href="#B-tree查找树" class="headerlink" title="B+tree查找树"></a>B+tree查找树</h2><p><code>B+tree</code>是基于<code>Btree</code>的变体，与<code>Btree</code>不同之处在于，</p>
<ul>
<li>非叶子节点的key个数等于m</li>
<li>每个节点的下级指针为n个（n为关键字个数，而不是n+1个）</li>
<li>为所有叶子节点增加一个链指针（注意链上的数据是有序的）</li>
<li>所有key都存在叶子节点中</li>
</ul>
<p><img src="/images/btree-3.png" alt=""></p>
<h3 id="为什么使用Btree结构"><a href="#为什么使用Btree结构" class="headerlink" title="为什么使用Btree结构"></a>为什么使用Btree结构</h3><p>索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。<br>索引查找过程中就要产生磁盘I/O消耗，相对于内存存取，I/O存取的消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘I/O操作次数的渐进复杂度。（换句话说，索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数。）</p>
<p><strong>为了达到降低磁盘I/O的目的</strong></p>
<ul>
<li>磁盘按需读取，要求每次都会预读的长度一般为页的整数倍， 数据库系统将一个节点的大小设为等于一个页，这样每个节点的元素数据只需要一次I/O就可以完全载入</li>
<li>每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I/O</li>
<li>把B-tree中的m值设的非常大，就会让树的高度降低，有利于一次完全载入</li>
</ul>
<p><strong>红黑树</strong></p>
<p><code>红黑树BST</code>的时间复杂度是依赖于树的高度，但是，红黑树的高度与Btree相比，高度更大。</p>
]]></content>
      
        <categories>
            
            <category> algorithm </category>
            
        </categories>
        
        
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[TCP状态]]></title>
      <url>/2016/01/18/tcp-status/</url>
      <content type="html"><![CDATA[<p>介绍TCP状态。<br><a id="more"></a></p>
<h2 id="TCP状态图"><a href="#TCP状态图" class="headerlink" title="TCP状态图"></a>TCP状态图</h2><blockquote>
<p>TCP连接中包含不同的状态，如何通过状态来判断程序问题尤为重要。</p>
</blockquote>
<p><img src="/images/tcp-status-1.png" alt="tcp连接"></p>
<h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p>图中的<code>connection</code>部分为三次握手。</p>
<h3 id="四次握手"><a href="#四次握手" class="headerlink" title="四次握手"></a>四次握手</h3><p>图中的<code>close</code>部分为四次握手。</p>
<h3 id="CLOSE-WAIT"><a href="#CLOSE-WAIT" class="headerlink" title="CLOSE_WAIT"></a>CLOSE_WAIT</h3><p>服务器接受到FIN关闭请求后为<code>CLOSE_WAIT</code>状态。<br>默认情况下，<code>CLOSE_WAIT</code>状态会至少维持2小时的状态。<br>由于<code>CLOSE_WAIT</code>状态后应该发送ACK请求，状态会变为<code>LAST_ACK</code>，但如果由太多的<code>CLOSE_WAIT</code>状态，则服务器出现错误。</p>
<h3 id="TIME-WAIT"><a href="#TIME-WAIT" class="headerlink" title="TIME_WAIT"></a>TIME_WAIT</h3><p>客户端在接受到服务器的FIN关闭请求后为<code>TIME_WAIT</code>状态，最后会自动切换到<code>CLOSE</code>状态。<br>当服务器主动关闭链接时形成<code>TIME_WAIT</code>状态，会持续2个MSL(Max Segment Lifetime)，默认为4分钟。</p>
<p><code>TIME_WAIT</code>状态下的socket不能被回收使用，具体现象是对于一个处理大量短连接的服务器，如果由于服务器主动关闭客户端的连接，将导致服务器产生大量处于<code>TIME_WAIT</code>状态的socket，严重影响服务器的处理能力。</p>
<h3 id="AWK和NETSTAT命令"><a href="#AWK和NETSTAT命令" class="headerlink" title="AWK和NETSTAT命令"></a>AWK和NETSTAT命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># -n表示-net</span><br><span class="line">netstat -n </span><br><span class="line"></span><br><span class="line"># -v用于定义参数</span><br><span class="line"> netstat  -net | awk -v i=0,j=0 &apos;&#123;if ($6==&quot;ESTABLISHED&quot;) &#123;i++&#125;; if ($6 == &quot;CLOSE_WAIT&quot;) &#123;j++&#125;; print i, j, prit $6&#125;&apos;</span><br><span class="line"></span><br><span class="line"># 最佳用法如下:</span><br><span class="line"># 1. 使用正则/xxx/来匹配行</span><br><span class="line"># 2. $NF代表最后一列的数据，命令中定义了一个字典，最后一列数据作为key</span><br><span class="line"># 3. 每次匹配都会让value递增</span><br><span class="line"># 4. END表示结束</span><br><span class="line"># 5. 最后的&#123;&#125;用来打印key,value</span><br><span class="line">netstat -n | awk &apos;/^tcp/ &#123;++S[$NF]&#125; END &#123;for (a in S) print a, S[a]&#125;&apos;</span><br></pre></td></tr></table></figure>
<p>那么，如何对结果进行排序呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 利用管道</span><br><span class="line">netstat -n | awk &apos;/^tcp/ &#123;++S[$NF]&#125; END &#123;for (a in S) print a, S[a] | &quot;sort -r -n -k2&quot;&#125;&apos;</span><br><span class="line"></span><br><span class="line"># 其中，sort为外部命令，-r代表从大到小（倒序），-n代表按照数字排序，-k2代表按照第2行排序。</span><br></pre></td></tr></table></figure></p>
<p>此外，也可以使用<code>asort</code>来实现结果排序。</p>
]]></content>
      
        <categories>
            
            <category> cs </category>
            
        </categories>
        
        
        <tags>
            
            <tag> tcp </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[python-单元测试]]></title>
      <url>/2015/12/31/python-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</url>
      <content type="html"><![CDATA[<p>The Hacker’s Guide To Python 单元测试<br><a id="more"></a></p>
<h2 id="基本方式"><a href="#基本方式" class="headerlink" title="基本方式"></a>基本方式</h2><p>python中提供了非常简单的单元测试方式，利用<code>nose</code>包中的<code>nosetests</code>命令可以实现简单的批量测试。</p>
<p>安装<code>nose</code>包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pip install nose</span><br></pre></td></tr></table></figure></p>
<p>编辑测试文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># test_true.py</span><br><span class="line">def test_true():</span><br><span class="line">    assert True</span><br><span class="line"></span><br><span class="line">def test_false():</span><br><span class="line">    assert False</span><br></pre></td></tr></table></figure></p>
<p>执行测试<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 命令， nosetests命令会加载所有以test_开头的文件，并执行所有以test_开头的函数</span><br><span class="line">nosetests -v</span><br><span class="line"># 输出</span><br><span class="line">test_true.test_true ... ok</span><br><span class="line">test_true.test_false ... FAIL</span><br><span class="line"></span><br><span class="line">======================================================================</span><br><span class="line">FAIL: test_true.test_false</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;/usr/local/lib/python2.7/site-packages/nose/case.py&quot;, line 197, in runTest</span><br><span class="line">    self.test(*self.arg)</span><br><span class="line">  File &quot;/xxxx/workspace/py/test/test_true.py&quot;, line 5, in test_false</span><br><span class="line">    assert False</span><br><span class="line">AssertionError</span><br><span class="line"></span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">Ran 2 tests in 0.007s</span><br><span class="line"></span><br><span class="line">FAILED (failures=1</span><br></pre></td></tr></table></figure></p>
<p><code>unittest</code>是python提供了单元测试的标准库。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 为了兼容python 2.6和2.7</span><br><span class="line">try:</span><br><span class="line">    import unittest2 as unittest</span><br><span class="line">except ImportError:</span><br><span class="line">    import unittest</span><br><span class="line"></span><br><span class="line">class TestKey(unittest.TestCase):</span><br><span class="line">    def test_keyh(self):</span><br><span class="line">        a = [&apos;a&apos;]</span><br><span class="line">        b = [&apos;a&apos;, &apos;b&apos;]</span><br><span class="line">        self.assertEqual(a, b)</span><br></pre></td></tr></table></figure>
<p>输出如下，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">test_keyh (test_true.TestKey) ... FAIL</span><br><span class="line"></span><br><span class="line">======================================================================</span><br><span class="line">FAIL: test_keyh (test_true.TestKey)</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;/home/y/workspace/py/test/test_true.py&quot;, line 8, in test_keyh</span><br><span class="line">    self.assertEqual(a, b)</span><br><span class="line">AssertionError: Lists differ: [&apos;a&apos;] != [&apos;a&apos;, &apos;b&apos;]</span><br><span class="line"></span><br><span class="line">Second list contains 1 additional elements.</span><br><span class="line">First extra element 1:</span><br><span class="line">b</span><br><span class="line"></span><br><span class="line">- [&apos;a&apos;]</span><br><span class="line">+ [&apos;a&apos;, &apos;b&apos;]</span><br><span class="line"></span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">Ran 1 test in 0.006s</span><br><span class="line"></span><br><span class="line">FAILED (failures=1)</span><br></pre></td></tr></table></figure></p>
<p>此外，<code>unittest.skipIf</code>可以通过判断条件来选择是否进行测试，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class TestSkipped(unittest.TestCase):</span><br><span class="line">    @unitttest.skip(&quot;Do not run this&quot;)</span><br><span class="line">    def test_failt(self):</span><br><span class="line">        self.fail(&quot;This should not be run&quot;)</span><br><span class="line"></span><br><span class="line">    @unittest.skipIf(mylib is None, &quot;mylib is not available&quot;)</span><br><span class="line">    def test_mylib(self):</span><br><span class="line">        self.assertEqual(1, 1)</span><br></pre></td></tr></table></figure></p>
<p>此外，自定义<code>setUp</code>和<code>tearDown</code>函数可以单元测试开始和结束时自动调用。</p>
<h2 id="fixtures"><a href="#fixtures" class="headerlink" title="fixtures"></a>fixtures</h2><p><code>fixtures</code>模块可以用来临时改变当前的测试环境。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import fixtures</span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line">class TestEnviron(fixtures.TestWithFixtures):</span><br><span class="line">    def test_environ(self):</span><br><span class="line">        fixture = self.useFixture(</span><br><span class="line">                fixtures.EnvironmentVariable(&quot;FOOBAR&quot;, &quot;42&quot;)) # 临时增加一个环境变量FOOBAR</span><br><span class="line">        self.assertEqual(os.environ.get(&quot;FOOBAR&quot;), &quot;42&quot;)</span><br><span class="line"></span><br><span class="line">    def test_environ_no_fixture(self):</span><br><span class="line">        self.assertEqual(os.environ.get(&quot;FOOBAR&quot;), None) # 上面增加的环境变量的操作对于其他函数无效</span><br></pre></td></tr></table></figure>
<h2 id="mock"><a href="#mock" class="headerlink" title="mock"></a>mock</h2><p><code>mock</code>模块可以用来进行模拟测试，其主要功能就是模拟一个函数，类或实例的行为。</p>
<p>由于网络测试环境的特殊性，最常用的使用就是模拟网络请求，具体例子如下，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"># test_mock.py</span><br><span class="line">import requests</span><br><span class="line">import unittest</span><br><span class="line">import mock</span><br><span class="line"></span><br><span class="line">class WhereIsPythonError(Exception):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">def is_python():</span><br><span class="line">    try:</span><br><span class="line">        r = requests.get(&quot;http://python.org&quot;)</span><br><span class="line">    except IOError:</span><br><span class="line">        pass</span><br><span class="line">    else:</span><br><span class="line">        if r.status_code == 200:</span><br><span class="line">            return &apos;is python&apos; in r.content</span><br><span class="line">    raise WhereIsPythonError(&apos;something happened&apos;)</span><br><span class="line"></span><br><span class="line">def get_fake_get(status_code, content):</span><br><span class="line">    m = mock.Mock()</span><br><span class="line">    m.status_code = status_code</span><br><span class="line">    m.content = content</span><br><span class="line">    def fake_get(url):</span><br><span class="line">        return m</span><br><span class="line">    return fake_get</span><br><span class="line"></span><br><span class="line">def raise_get(url):</span><br><span class="line">    raise IOError(&quot;unable to fetch url %s&quot; % url)</span><br><span class="line"></span><br><span class="line">class TestPython(unittest.TestCase):</span><br><span class="line">    @mock.patch(&apos;requests.get&apos;, get_fake_get(</span><br><span class="line">        200, &apos;is python, hello&apos;</span><br><span class="line">        ))</span><br><span class="line">    def test_python_is(self):</span><br><span class="line">        self.assertTrue(is_python())</span><br><span class="line"></span><br><span class="line">    @mock.patch(&apos;requests.get&apos;, get_fake_get(</span><br><span class="line">        200, &apos;is not python, hello&apos;</span><br><span class="line">        ))</span><br><span class="line">    def test_python_is_not(self):</span><br><span class="line">        self.assertFalse(is_python())</span><br></pre></td></tr></table></figure>
<p>输出如下，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 命令</span><br><span class="line">nosetests --tests=test_mock -v</span><br><span class="line"># 结果</span><br><span class="line">test_python_is (test_mock.TestPython) ... ok</span><br><span class="line">test_python_is_not (test_mock.TestPython) ... ok</span><br><span class="line"></span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">Ran 2 tests in 0.001s</span><br><span class="line"></span><br><span class="line">OK</span><br></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[python yield关键字]]></title>
      <url>/2015/11/24/python-yield/</url>
      <content type="html"><![CDATA[<p><code>yield</code>的功能类似于<code>return</code>，但是不同之处在于它返回的是<code>生成器</code>。<br><a id="more"></a></p>
<h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><p>生成器是通过一个或多个<code>yield</code>表达式构成的函数，每一个生成器都是一个迭代器（但是迭代器不一定是生成器）。</p>
<p>如果一个函数包含<code>yield</code>关键字，这个函数就会变为一个生成器。</p>
<p>生成器并不会一次返回所有结果，而是每次遇到<code>yield</code>关键字后返回相应结果，并保留函数当前的运行状态，等待下一次的调用。</p>
<p>由于生成器也是一个迭代器，那么它就应该支持<code>next</code>方法来获取下一个值。</p>
<h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 通过`yield`来创建生成器</span><br><span class="line">def func():</span><br><span class="line">   for i in xrange(10);</span><br><span class="line">        yield i</span><br><span class="line"></span><br><span class="line"># 通过列表来创建生成器</span><br><span class="line">[i for i in xrange(10)]</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 调用如下</span><br><span class="line">&gt;&gt;&gt; f = func()</span><br><span class="line">&gt;&gt;&gt; f # 此时生成器还没有运行</span><br><span class="line">&lt;generator object func at 0x7fe01a853820&gt;</span><br><span class="line">&gt;&gt;&gt; f.next() # 当i=0时，遇到yield关键字，直接返回</span><br><span class="line">0</span><br><span class="line">&gt;&gt;&gt; f.next() # 继续上一次执行的位置，进入下一层循环</span><br><span class="line">1</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; f.next()</span><br><span class="line">9</span><br><span class="line">&gt;&gt;&gt; f.next() # 当执行完最后一次循环后，结束yield语句，生成StopIteration异常</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">StopIteration</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>除了<code>next</code>函数，生成器还支持<code>send</code>函数。该函数可以向生成器传递参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def func():</span><br><span class="line">...     n = 0</span><br><span class="line">...     while 1:</span><br><span class="line">...         n = yield n #可以通过send函数向n赋值</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; f = func()</span><br><span class="line">&gt;&gt;&gt; f.next() # 默认情况下n为0</span><br><span class="line">0</span><br><span class="line">&gt;&gt;&gt; f.send(1) #n赋值1</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; f.send(2)</span><br><span class="line">2</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>最经典的例子，生成无限序列。</p>
<p>常规的解决方法是，生成一个满足要求的很大的列表，这个列表需要保存在内存中，很明显内存限制了这个问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def get_primes(start):</span><br><span class="line">    for element in magical_infinite_range(start):</span><br><span class="line">        if is_prime(element):</span><br><span class="line">            return element</span><br></pre></td></tr></table></figure>
<p>如果使用生成器就不需要返回整个列表，每次都只是返回一个数据，避免了内存的限制问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def get_primes(number):</span><br><span class="line">    while True:</span><br><span class="line">        if is_prime(number):</span><br><span class="line">            yield number</span><br><span class="line">        number += 1</span><br></pre></td></tr></table></figure>
<h2 id="生成器源码分析"><a href="#生成器源码分析" class="headerlink" title="生成器源码分析"></a>生成器源码分析</h2><p>生成器的源码在<code>Objects/genobject.c</code>。</p>
<h3 id="调用栈"><a href="#调用栈" class="headerlink" title="调用栈"></a>调用栈</h3><p>在解释生成器之前，需要讲解一下Python虚拟机的调用原理。</p>
<p>Python虚拟机有一个栈帧的调用栈，其中栈帧的是<code>PyFrameObject</code>，位于<code>Include/frameobject.h</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _frame &#123;</span><br><span class="line">    PyObject_VAR_HEAD</span><br><span class="line">    struct _frame *f_back;	/* previous frame, or NULL */</span><br><span class="line">    PyCodeObject *f_code;	/* code segment */</span><br><span class="line">    PyObject *f_builtins;	/* builtin symbol table (PyDictObject) */</span><br><span class="line">    PyObject *f_globals;	/* global symbol table (PyDictObject) */</span><br><span class="line">    PyObject *f_locals;		/* local symbol table (any mapping) */</span><br><span class="line">    PyObject **f_valuestack;	/* points after the last local */</span><br><span class="line">    /* Next free slot in f_valuestack.  Frame creation sets to f_valuestack.</span><br><span class="line">       Frame evaluation usually NULLs it, but a frame that yields sets it</span><br><span class="line">       to the current stack top. */</span><br><span class="line">    PyObject **f_stacktop;</span><br><span class="line">    PyObject *f_trace;		/* Trace function */</span><br><span class="line"></span><br><span class="line">    /* If an exception is raised in this frame, the next three are used to</span><br><span class="line">     * record the exception info (if any) originally in the thread state.  See</span><br><span class="line">     * comments before set_exc_info() -- it&apos;s not obvious.</span><br><span class="line">     * Invariant:  if _type is NULL, then so are _value and _traceback.</span><br><span class="line">     * Desired invariant:  all three are NULL, or all three are non-NULL.  That</span><br><span class="line">     * one isn&apos;t currently true, but &quot;should be&quot;.</span><br><span class="line">     */</span><br><span class="line">    PyObject *f_exc_type, *f_exc_value, *f_exc_traceback;</span><br><span class="line"></span><br><span class="line">    PyThreadState *f_tstate;</span><br><span class="line">    int f_lasti;		/* Last instruction if called */</span><br><span class="line">    /* Call PyFrame_GetLineNumber() instead of reading this field</span><br><span class="line">       directly.  As of 2.3 f_lineno is only valid when tracing is</span><br><span class="line">       active (i.e. when f_trace is set).  At other times we use</span><br><span class="line">       PyCode_Addr2Line to calculate the line from the current</span><br><span class="line">       bytecode index. */</span><br><span class="line">    int f_lineno;		/* Current line number */</span><br><span class="line">    int f_iblock;		/* index in f_blockstack */</span><br><span class="line">    PyTryBlock f_blockstack[CO_MAXBLOCKS]; /* for try and loop blocks */</span><br><span class="line">    PyObject *f_localsplus[1];	/* locals+stack, dynamically sized */</span><br><span class="line">&#125; PyFrameObject;</span><br></pre></td></tr></table></figure>
<p>栈帧保存了给出代码的的信息和上下文，其中包含最后执行的指令，全局和局部命名空间，异常状态等信息。<code>f_valueblock</code>保存了数据，<code>b_blockstack</code>保存了异常和循环控制方法。</p>
<p>举一个例子来说明，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def foo():</span><br><span class="line">    x = 1</span><br><span class="line">    def bar(y):</span><br><span class="line">        z = y + 2  # &lt;--- (3) ... and the interpreter is here.</span><br><span class="line">        return z</span><br><span class="line">    return bar(x)  # &lt;--- (2) ... which is returning a call to bar ...</span><br><span class="line">foo()              # &lt;--- (1) We&apos;re in the middle of a call to foo ...</span><br></pre></td></tr></table></figure>
<p>那么，相应的调用栈如下，一个py文件，一个类，一个函数都是一个代码块，对应者一个Frame，保存着上下文环境以及字节码指令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">c   ---------------------------</span><br><span class="line">a  | bar Frame                 | -&gt; block stack: []</span><br><span class="line">l  |     (newest)              | -&gt; data stack: [1, 2]</span><br><span class="line">l   ---------------------------</span><br><span class="line">   | foo Frame                 | -&gt; block stack: []</span><br><span class="line">s  |                           | -&gt; data stack: [&lt;Function foo.&lt;locals&gt;.bar at 0x10d389680&gt;, 1]</span><br><span class="line">t   ---------------------------</span><br><span class="line">a  | main (module) Frame       | -&gt; block stack: []</span><br><span class="line">c  |       (oldest)            | -&gt; data stack: [&lt;Function foo at 0x10d3540e0&gt;]</span><br><span class="line">k   ---------------------------</span><br></pre></td></tr></table></figure>
<p>每一个栈帧都拥有自己的数据栈和block栈，独立的数据栈和block栈使得解释器可以中断和恢复栈帧（生成器正式利用这点）。</p>
<p>Python代码首先被编译为字节码，再由Python虚拟机来执行。一般来说，一条Python语句对应着多条字节码（由于每条字节码对应着一条C语句，而不是一个机器指令，所以不能按照字节码的数量来判断代码性能）。</p>
<p>调用<code>dis</code>模块可以分析字节码，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">from dis import dis</span><br><span class="line"></span><br><span class="line">dis(foo)</span><br><span class="line"></span><br><span class="line">  5           0 LOAD_CONST               1 (1) # 加载常量1</span><br><span class="line">              3 STORE_FAST               0 (x) # x赋值为1</span><br><span class="line"></span><br><span class="line">  6           6 LOAD_CONST               2 (&lt;code object bar at 0x7f3cdee3a030, file &quot;t1.py&quot;, line 6&gt;) # 加载常量2</span><br><span class="line">              9 MAKE_FUNCTION            0 # 创建函数</span><br><span class="line">             12 STORE_FAST               1 (bar) </span><br><span class="line"></span><br><span class="line">  9          15 LOAD_FAST                1 (bar) </span><br><span class="line">             18 LOAD_FAST                0 (x)</span><br><span class="line">             21 CALL_FUNCTION            1  # 调用函数</span><br><span class="line">             24 RETURN_VALUE</span><br></pre></td></tr></table></figure>
<p>其中，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">第一行为代码行号；</span><br><span class="line">第二行为偏移地址；</span><br><span class="line">第三行为字节码指令；</span><br><span class="line">第四行为指令参数；</span><br><span class="line">第五行为参数解释。</span><br></pre></td></tr></table></figure>
<h3 id="生成器源码分析-1"><a href="#生成器源码分析-1" class="headerlink" title="生成器源码分析"></a>生成器源码分析</h3><p>由了上面对于调用栈的理解，就可以很容易的明白生成器的具体实现。</p>
<p>生成器的源码位于<code>object/genobject.c</code>。</p>
<h4 id="生成器的创建"><a href="#生成器的创建" class="headerlink" title="生成器的创建"></a>生成器的创建</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">PyObject *</span><br><span class="line">PyGen_New(PyFrameObject *f)</span><br><span class="line">&#123;</span><br><span class="line">    PyGenObject *gen = PyObject_GC_New(PyGenObject, &amp;PyGen_Type); # 创建生成器对象</span><br><span class="line">    if (gen == NULL) &#123;</span><br><span class="line">        Py_DECREF(f);</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    gen-&gt;gi_frame = f; # 赋予代码块</span><br><span class="line">    Py_INCREF(f-&gt;f_code); # 引用计数+1</span><br><span class="line">    gen-&gt;gi_code = (PyObject *)(f-&gt;f_code);</span><br><span class="line">    gen-&gt;gi_running = 0; # 0表示为执行，也就是生成器的初始状态</span><br><span class="line">    gen-&gt;gi_weakreflist = NULL;</span><br><span class="line">    _PyObject_GC_TRACK(gen); # GC跟踪</span><br><span class="line">    return (PyObject *)gen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="send与next"><a href="#send与next" class="headerlink" title="send与next"></a>send与next</h4><p><code>next</code>与<code>send</code>函数，如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">static PyObject *</span><br><span class="line">gen_iternext(PyGenObject *gen)</span><br><span class="line">&#123;</span><br><span class="line">    return gen_send_ex(gen, NULL, 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static PyObject *</span><br><span class="line">gen_send(PyGenObject *gen, PyObject *arg)</span><br><span class="line">&#123;</span><br><span class="line">    return gen_send_ex(gen, arg, 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的代码中可以看到，<code>send</code>和<code>next</code>都是调用的同一函数<code>gen_send_ex</code>，区别在于是否带有参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">static PyObject *</span><br><span class="line">gen_send_ex(PyGenObject *gen, PyObject *arg, int exc)</span><br><span class="line">&#123;</span><br><span class="line">    PyThreadState *tstate = PyThreadState_GET();</span><br><span class="line">    PyFrameObject *f = gen-&gt;gi_frame;</span><br><span class="line">    PyObject *result;</span><br><span class="line"></span><br><span class="line">    if (gen-&gt;gi_running) &#123; # 判断生成器是否已经运行</span><br><span class="line">        PyErr_SetString(PyExc_ValueError,</span><br><span class="line">                        &quot;generator already executing&quot;);</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    if (f==NULL || f-&gt;f_stacktop == NULL) &#123; # 如果代码块为空或调用栈为空，则抛出StopIteration异常</span><br><span class="line">        /* Only set exception if called from send() */</span><br><span class="line">        if (arg &amp;&amp; !exc)</span><br><span class="line">            PyErr_SetNone(PyExc_StopIteration);</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (f-&gt;f_lasti == -1) &#123; # f_lasti=1 代表首次执行</span><br><span class="line">        if (arg &amp;&amp; arg != Py_None) &#123; # 首次执行不允许带有参数</span><br><span class="line">            PyErr_SetString(PyExc_TypeError,</span><br><span class="line">                            &quot;can&apos;t send non-None value to a &quot;</span><br><span class="line">                            &quot;just-started generator&quot;);</span><br><span class="line">            return NULL;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        /* Push arg onto the frame&apos;s value stack */</span><br><span class="line">        result = arg ? arg : Py_None;</span><br><span class="line">        Py_INCREF(result); # 该参数引用计数+1</span><br><span class="line">        *(f-&gt;f_stacktop++) = result; # 参数压栈</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* Generators always return to their most recent caller, not</span><br><span class="line">     * necessarily their creator. */</span><br><span class="line">    f-&gt;f_tstate = tstate;</span><br><span class="line">    Py_XINCREF(tstate-&gt;frame);</span><br><span class="line">    assert(f-&gt;f_back == NULL);</span><br><span class="line">    f-&gt;f_back = tstate-&gt;frame;</span><br><span class="line"></span><br><span class="line">    gen-&gt;gi_running = 1; # 修改生成器执行状态</span><br><span class="line">    result = PyEval_EvalFrameEx(f, exc); # 执行字节码</span><br><span class="line">    gen-&gt;gi_running = 0; # 恢复为未执行状态</span><br><span class="line"></span><br><span class="line">    /* Don&apos;t keep the reference to f_back any longer than necessary.  It</span><br><span class="line">     * may keep a chain of frames alive or it could create a reference</span><br><span class="line">     * cycle. */</span><br><span class="line">    assert(f-&gt;f_back == tstate-&gt;frame);</span><br><span class="line">    Py_CLEAR(f-&gt;f_back);</span><br><span class="line">    /* Clear the borrowed reference to the thread state */</span><br><span class="line">    f-&gt;f_tstate = NULL;</span><br><span class="line"></span><br><span class="line">    /* If the generator just returned (as opposed to yielding), signal</span><br><span class="line">     * that the generator is exhausted. */</span><br><span class="line">    if (result == Py_None &amp;&amp; f-&gt;f_stacktop == NULL) &#123;</span><br><span class="line">        Py_DECREF(result);</span><br><span class="line">        result = NULL;</span><br><span class="line">        /* Set exception if not called by gen_iternext() */</span><br><span class="line">        if (arg)</span><br><span class="line">            PyErr_SetNone(PyExc_StopIteration);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!result || f-&gt;f_stacktop == NULL) &#123;</span><br><span class="line">        /* generator can&apos;t be rerun, so release the frame */</span><br><span class="line">        Py_DECREF(f);</span><br><span class="line">        gen-&gt;gi_frame = NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="字节码的执行"><a href="#字节码的执行" class="headerlink" title="字节码的执行"></a>字节码的执行</h4><p><code>PyEval_EvalFrameEx</code>函数的功能为执行字节码并返回结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 主要流程如下，</span><br><span class="line">for (;;) &#123;</span><br><span class="line">   switch(opcode) &#123; # opcode为操作码，对应着各种操作</span><br><span class="line">        case NOP:</span><br><span class="line">            goto  fast_next_opcode;</span><br><span class="line">        ...</span><br><span class="line">        ...</span><br><span class="line">        case YIELD_VALUE: # 如果操作码是yield</span><br><span class="line">            retval = POP(); </span><br><span class="line">            f-&gt;f_stacktop = stack_pointer;</span><br><span class="line">            why = WHY_YIELD;</span><br><span class="line">            goto fast_yield; # 利用goto跳出循环</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fast_yield:</span><br><span class="line">    ... </span><br><span class="line">return vetval; # 返回结果</span><br></pre></td></tr></table></figure>
<p>举一个例子，<code>f_back</code>上一个Frame，<code>f_lasti</code>上一次执行的指令的偏移量，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">from dis import dis</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def func():</span><br><span class="line">    f = sys._getframe(0)</span><br><span class="line">    print f.f_lasti</span><br><span class="line">    print f.f_back</span><br><span class="line">    yield 1</span><br><span class="line"></span><br><span class="line">    print f.f_lasti</span><br><span class="line">    print f.f_back</span><br><span class="line">    yield 2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = func()</span><br><span class="line">dis(func)</span><br><span class="line">a.next()</span><br><span class="line">a.next()</span><br></pre></td></tr></table></figure></p>
<p>结果如下，其中第三行的英文为操作码，对应着上面的<code>opcode</code>，每次switch都是在不同的<code>opcode</code>之间进行选择。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">  6           0 LOAD_GLOBAL              0 (sys)</span><br><span class="line">              3 LOAD_ATTR                1 (_getframe)</span><br><span class="line">              6 LOAD_CONST               1 (0)</span><br><span class="line">              9 CALL_FUNCTION            1</span><br><span class="line">             12 STORE_FAST               0 (f)</span><br><span class="line"></span><br><span class="line">  7          15 LOAD_FAST                0 (f)</span><br><span class="line">             18 LOAD_ATTR                2 (f_lasti) </span><br><span class="line">             21 PRINT_ITEM          </span><br><span class="line">             22 PRINT_NEWLINE       </span><br><span class="line"></span><br><span class="line">  8          23 LOAD_FAST                0 (f)</span><br><span class="line">             26 LOAD_ATTR                3 (f_back)</span><br><span class="line">             29 PRINT_ITEM          </span><br><span class="line">             30 PRINT_NEWLINE       </span><br><span class="line"></span><br><span class="line">  9          31 LOAD_CONST               2 (1)</span><br><span class="line">             34 YIELD_VALUE     # 此时操作码为YIELD_VALUE，直接跳转上述goto语句，此时f_lasti为当前指令，f_back为当前frame</span><br><span class="line">             35 POP_TOP             </span><br><span class="line"></span><br><span class="line"> 11          36 LOAD_FAST                0 (f)</span><br><span class="line">             39 LOAD_ATTR                2 (f_lasti)</span><br><span class="line">             42 PRINT_ITEM          </span><br><span class="line">             43 PRINT_NEWLINE       </span><br><span class="line"></span><br><span class="line"> 12          44 LOAD_FAST                0 (f)</span><br><span class="line">             47 LOAD_ATTR                3 (f_back)</span><br><span class="line">             50 PRINT_ITEM          </span><br><span class="line">             51 PRINT_NEWLINE       </span><br><span class="line"></span><br><span class="line"> 13          52 LOAD_CONST               3 (2)</span><br><span class="line">             55 YIELD_VALUE         </span><br><span class="line">             56 POP_TOP             </span><br><span class="line">             57 LOAD_CONST               0 (None)</span><br><span class="line">             60 RETURN_VALUE        </span><br><span class="line">18</span><br><span class="line">&lt;frame object at 0x7fa75fcebc20&gt; #和下面的frame相同，属于同一个frame，也就是说在同一个函数（命名空间）内，frame是同一个。</span><br><span class="line">39</span><br><span class="line">&lt;frame object at 0x7fa75fcebc20&gt;</span><br></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[mysql存储过程]]></title>
      <url>/2015/10/28/mysql-procedure/</url>
      <content type="html"><![CDATA[<p>存储过程是通过给定的语法格式编写自定义的数据库API，类似于给数据库编写可执行函数。<br><a id="more"></a></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>存储过程是一组为了完成特定功能的SQL语句集合，是经过编译后存储在数据库中。</p>
<p>存储过程增强了SQL语言的功能和灵活性，它可以使用流控制语句编写来完成复杂的判断和计算。</p>
<p>存储过程是把完成特定功能的SQL语句集合统一在数据库中进行处理，避免了多次网络IO请求造成的网络负载。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> DELIMITER //</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> CREATE PROCEDURE proc1(OUT s int)</span></span><br><span class="line">        -&gt; BEGIN</span><br><span class="line">        -&gt; SELECT COUNT(*) INTO s FROM person;</span><br><span class="line">        -&gt; END //</span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> DELIMITER;</span></span><br></pre></td></tr></table></figure>
<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p><strong>基本结构</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER //</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> some_func;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> some_func</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">IN</span> param1 <span class="built_in">INT</span>,</span><br><span class="line">    <span class="keyword">IN</span> param2 <span class="built_in">VARCHAR</span>(<span class="number">32</span>),</span><br><span class="line">    <span class="keyword">OUT</span> res <span class="built_in">INT</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">SQL</span>-SCRIPT</span><br><span class="line"><span class="keyword">END</span> //</span><br><span class="line">DELIMITER;</span><br></pre></td></tr></table></figure>
<p>调用语句如下，</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CALL</span> some_func(params...);</span><br></pre></td></tr></table></figure>
<p><strong>变量</strong></p>
<p>在存储过程中，函数参数包含三种变量，</p>
<ul>
<li>IN 输入参数，必须在调用存储过程时指定</li>
<li>OUT 输出参数，可在存储过程内部被改变，返回该结果</li>
<li>INOUT 输入输出参数，调用时指定并且可被改变和返回</li>
</ul>
<p>在存储过程内部，参数的定义如下，</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span> var_name [, var_name] var_type [<span class="keyword">default</span> <span class="keyword">value</span>];</span><br></pre></td></tr></table></figure>
<p><strong>用户变量</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> @mvar = <span class="string">'Hello World'</span>;</span><br></pre></td></tr></table></figure>
<p><strong>变量赋值</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET var_name = 表达式;</span><br></pre></td></tr></table></figure>
<p><strong>条件语句</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if var=0 then </span><br><span class="line">  <span class="keyword">insert</span> <span class="keyword">into</span> person <span class="keyword">values</span> (<span class="string">'f'</span>);</span><br><span class="line">else</span><br><span class="line">  <span class="keyword">insert</span> <span class="keyword">into</span> person <span class="keyword">values</span> (<span class="string">'ff'</span>);</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span>;</span><br></pre></td></tr></table></figure>
<p><strong>case语句</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">case var</span><br><span class="line">when 0 then</span><br><span class="line">  <span class="keyword">insert</span> <span class="keyword">into</span> person <span class="keyword">values</span> (<span class="string">'f'</span>);</span><br><span class="line">when 1 then</span><br><span class="line">  <span class="keyword">insert</span> <span class="keyword">into</span> person <span class="keyword">values</span> (<span class="string">'ff'</span>);</span><br><span class="line">else</span><br><span class="line">  <span class="keyword">insert</span> <span class="keyword">into</span> person <span class="keyword">values</span> (<span class="string">'fff'</span>);</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">case</span>;</span><br></pre></td></tr></table></figure>
<p><strong>循环语句</strong></p>
<p>WHILE语句，同C语言中的while语句一样。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while var &lt; N do</span><br><span class="line">  <span class="keyword">insert</span> <span class="keyword">into</span> person <span class="keyword">values</span> (<span class="string">'f'</span>);</span><br><span class="line">  <span class="keyword">set</span> <span class="keyword">var</span> = <span class="keyword">var</span> + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">while</span>;</span><br></pre></td></tr></table></figure>
<p>REPEAT语句，类似于C语言中的do while语句。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">repeat</span><br><span class="line">  <span class="keyword">insert</span> <span class="keyword">into</span> person <span class="keyword">values</span> (<span class="string">'f'</span>);</span><br><span class="line">  <span class="keyword">set</span> <span class="keyword">var</span> = <span class="keyword">var</span> + <span class="number">1</span>;</span><br><span class="line">until var &gt;= N</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">repeat</span>;</span><br></pre></td></tr></table></figure>
<p>LOOP语句，没有结束的判断语句，利用<code>leave</code>来跳出循环，类似于break。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> @<span class="keyword">var</span> = <span class="number">0</span>;</span><br><span class="line">loop_name:loop</span><br><span class="line">  <span class="keyword">set</span> @<span class="keyword">var</span> = @<span class="keyword">var</span> + <span class="number">1</span>;</span><br><span class="line">  if @var &gt; 5 then</span><br><span class="line">    leave loop_name;</span><br><span class="line">  <span class="keyword">end</span> <span class="keyword">if</span>;</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">loop</span> loop_name;</span><br><span class="line"><span class="keyword">select</span> @<span class="keyword">var</span>;</span><br></pre></td></tr></table></figure>
<h2 id="基本函数"><a href="#基本函数" class="headerlink" title="基本函数"></a>基本函数</h2><p>mysql内置了一些函数，这些函数可以极大地提高编写存储过程的效率。</p>
<p>字符串操作如下，</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CHARSET(str) //获取字符集</span><br><span class="line">CONCAT(str1, str2, ...) //联接字符串</span><br><span class="line">INSTR(str, substr) //返回substr出现在str中的第一个位置</span><br><span class="line">LOCATE(substr, str, start_position) //返回substr在str的start_position开始第一次出现的位置</span><br><span class="line">LCASE(str) //将所有字符转换为小写</span><br><span class="line">LEFT(str, length) //返回str从左边开始的length个字符</span><br><span class="line">LENGTH(str) //返回str长度</span><br><span class="line">LOAD_FILE(file_name) //读取文见内容</span><br><span class="line">LPAD(str, length, pad) //重复在str的首部插入pad，直到str的长度达到length</span><br><span class="line">LTRIM(str) //去除str首部的空格</span><br><span class="line">RTRIM(str) //去除str尾部的空格</span><br><span class="line">STRCMP(str1, str2) //字符串比较</span><br><span class="line">SUBSTRING(str, start_position, length) //截取字符串，默认第一个字符下标为1</span><br></pre></td></tr></table></figure>
<p>math相关操作如下，</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ABS(i) //绝对值</span><br><span class="line">BIN(i) //十进制-&gt;二进制</span><br><span class="line">CEILING(i) //向上取整</span><br><span class="line">CONV(i, from, to) //进制转换</span><br><span class="line">FLOOR(i) //向下取整</span><br><span class="line">FORMAT(i, n) //保留小数位数</span><br><span class="line">HEX(i) //转十六进制</span><br><span class="line">LEAST(i0, i1, i2, ..) //求最小值</span><br><span class="line">MOD(i, demoninator) //求余</span><br><span class="line">POWER(I, POWER) //求指数</span><br><span class="line">RAND([seed]) //随机数</span><br><span class="line">ROUND(I, [, DECIMALS]) //四舍五入，decimals为保留小数位数</span><br><span class="line">SQRT(number2) //开平方</span><br></pre></td></tr></table></figure>
<p>时间相关操作如下，</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">ADDTIME (date2 ,time_interval ) //将time_interval加到date2 </span><br><span class="line">CONVERT_TZ (datetime2 ,fromTZ ,toTZ ) //转换时区 </span><br><span class="line">CURRENT_DATE ( ) //当前日期 </span><br><span class="line">CURRENT_TIME ( ) //当前时间 </span><br><span class="line">CURRENT_TIMESTAMP ( ) //当前时间戳 </span><br><span class="line">DATE (datetime ) //返回datetime的日期部分 </span><br><span class="line">DATE_ADD (date2 , INTERVAL d_value d_type ) //在date2中加上日期或时间 </span><br><span class="line">DATE_FORMAT (datetime ,FormatCodes ) //使用formatcodes格式显示datetime </span><br><span class="line">DATE_SUB (date2 , INTERVAL d_value d_type ) //在date2上减去一个时间 </span><br><span class="line">DATEDIFF (date1 ,date2 ) //两个日期差 </span><br><span class="line">DAY (date ) //返回日期的天 </span><br><span class="line">DAYNAME (date ) //英文星期 </span><br><span class="line">DAYOFWEEK (date ) //星期(1-7) ,1为星期天 </span><br><span class="line">DAYOFYEAR (date ) //一年中的第几天 </span><br><span class="line">EXTRACT (interval_name FROM date ) //从date中提取日期的指定部分 </span><br><span class="line">MAKEDATE (year ,day ) //给出年及年中的第几天,生成日期串 </span><br><span class="line">MAKETIME (hour ,minute ,second ) //生成时间串 </span><br><span class="line">MONTHNAME (date ) //英文月份名 </span><br><span class="line">NOW ( ) //当前时间 </span><br><span class="line">SEC_TO_TIME (seconds ) //秒数转成时间 </span><br><span class="line">STR_TO_DATE (string ,format ) //字串转成时间,以format格式显示 </span><br><span class="line">TIMEDIFF (datetime1 ,datetime2 ) //两个时间差 </span><br><span class="line">TIME_TO_SEC (time ) //时间转秒数] </span><br><span class="line">WEEK (date_time [,start_of_week ]) //第几周 </span><br><span class="line">YEAR (datetime ) //年份 </span><br><span class="line">DAYOFMONTH(datetime) //月的第几天 </span><br><span class="line">HOUR(datetime) //小时 </span><br><span class="line">LAST_DAY(date) //date的月的最后日期 </span><br><span class="line">MICROSECOND(datetime) //微秒 </span><br><span class="line">MONTH(datetime) //月 </span><br><span class="line">MINUTE(datetime) //分返回符号,正负或0</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://xdj651897373-126-com.iteye.com/blog/1819924" target="_blank" rel="external">http://xdj651897373-126-com.iteye.com/blog/1819924</a><br><a href="http://blog.tankywoo.com/2015/04/01/mysql-stored-procedure.html" target="_blank" rel="external">http://blog.tankywoo.com/2015/04/01/mysql-stored-procedure.html</a><br><a href="http://stackoverflow.com/questions/8549619/mysql-dynamically-build-query-string-in-a-stored-procedure-based-on-logic" target="_blank" rel="external">http://stackoverflow.com/questions/8549619/mysql-dynamically-build-query-string-in-a-stored-procedure-based-on-logic</a></p>
]]></content>
      
        <categories>
            
            <category> db </category>
            
        </categories>
        
        
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[golang反射]]></title>
      <url>/2015/10/15/go-reflect/</url>
      <content type="html"><![CDATA[<p>go语言中reflect反射机制。详细原文：<a href="http://blog.golang.org/laws-of-reflection" target="_blank" rel="external">地址</a><br><a id="more"></a><br>在go中，反射是建立在类型基础之上，每一个变量都会有一个静态类型。</p>
<h2 id="接口值到反射对象"><a href="#接口值到反射对象" class="headerlink" title="接口值到反射对象"></a>接口值到反射对象</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="keyword">int</span> = <span class="number">1</span></span><br><span class="line">    fmt.Println(<span class="string">"type: "</span>, reflect.TypeOf(x))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type:  int</span><br></pre></td></tr></table></figure>
<p><code>TypeOf</code>函数的定义如下，参数为接口类型，返回值为类型<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TypeOf</span><span class="params">(i <span class="keyword">interface</span> &#123;&#125;)</span> <span class="title">Type</span></span></span><br></pre></td></tr></table></figure></p>
<p><code>ValueOf</code>函数的定义如下，参数为接口类型，返回值为<code>Value</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var x int = 1</span><br><span class="line">fmt.Println(&quot;value: &quot;, reflect.ValueOf(x))</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value:  &lt;int Value&gt;</span><br></pre></td></tr></table></figure>
<p>可以通过<code>Kind</code>函数来检查类型，<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(<span class="string">"Kind:  "</span>, reflect.ValueOf(x).Kind())</span><br><span class="line">fmt.Println(<span class="string">"Kind is Int? "</span>, reflect.ValueOf(x).Kind() == reflect.<span class="keyword">int</span>)</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Kind:   int</span><br><span class="line">Kind is Int?  true</span><br></pre></td></tr></table></figure>
<h2 id="反射对象到接口值"><a href="#反射对象到接口值" class="headerlink" title="反射对象到接口值"></a>反射对象到接口值</h2><p>通过<code>Interface</code>函数可以实现反射对象到接口值的转换，<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span> <span class="title">Interface</span><span class="params">()</span> <span class="title">interface</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Interface 以 interface&#123;&#125; 返回 v 的值</span></span><br><span class="line">y := v.Interface().(<span class="keyword">float64</span>)</span><br><span class="line">fmt.Println(y)</span><br></pre></td></tr></table></figure>
<h2 id="修改反射对象"><a href="#修改反射对象" class="headerlink" title="修改反射对象"></a>修改反射对象</h2><blockquote>
<p>修改反射对象的前提条件是其值必须是可设置的</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="keyword">float64</span> = <span class="number">3.4</span></span><br><span class="line">v := reflect.ValueOf(x)</span><br><span class="line">v.SetFloat(<span class="number">7.3</span>) <span class="comment">// Error: panic</span></span><br></pre></td></tr></table></figure>
<p>为了避免这个问题，需要使用<code>CanSet</code>函数来检查该值的设置性，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var x float64 = 3.4</span><br><span class="line">v := reflect.ValueOf(x)</span><br><span class="line">fmt.Println(&quot;settability of v: &quot;, v.CanSet())</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">settability of v: false</span><br></pre></td></tr></table></figure>
<p>那么如何才能设置该值呢？<br>这里需要考虑一个常见的问题，<code>参数传递</code>，传值还是传引用或地址？<br>在上面的例子中，我们使用的是<code>reflect.ValueOf(x)</code>，这是一个值传递，传递的是x的值的一个副本，不是x本身，因此更新副本中的值是不允许的。如果使用<code>reflect.ValueOf(&amp;x)</code>来替换刚才的值传递，就可以实现值的修改。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var x float64 = 3.4</span><br><span class="line">p := reflect.ValueOf(&amp;x) // 获取x的地址</span><br><span class="line">fmt.Println(&quot;settability of p: &quot;, p.CanSet())</span><br><span class="line">v := p.Elem()</span><br><span class="line">fmt.Println(&quot;settability of v: &quot;, v.CanSet())</span><br><span class="line">v.SetFloat(7.1)</span><br><span class="line">fmt.Println(v.Interface())</span><br><span class="line">fmt.Println(x)</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">settability of p: false</span><br><span class="line">settability of v: true</span><br><span class="line">7.1</span><br><span class="line">7.1</span><br></pre></td></tr></table></figure>
<h2 id="获取结构体标签"><a href="#获取结构体标签" class="headerlink" title="获取结构体标签"></a>获取结构体标签</h2><p>首先介绍如何遍历结构体字段内容，<br>假设结构体如下，<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">    A <span class="keyword">int</span></span><br><span class="line">    B <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">t := T&#123;<span class="number">12</span>, <span class="string">"skidoo"</span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>从而，通过反射来遍历所有的字段内容<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s := reflect.ValueOf(&amp;t).Elem()</span><br><span class="line">typeOfT := s.Type()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; s.NumField(); i++ &#123;</span><br><span class="line">    f := s.Field(i)</span><br><span class="line">    fmt.Printf(<span class="string">"%d %s %s = %v\n"</span>, i, typeOfT.Field(i).Name, f.Type(), f.Interface())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0 A int = 23</span><br><span class="line">1 B string = skidoo</span><br></pre></td></tr></table></figure>
<p>接下来，如何获取结构体的标签内容?<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    type S struct &#123;</span><br><span class="line">        F string `species:&quot;gopher&quot; color:&quot;blue&quot;`</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    s := S&#123;&#125;</span><br><span class="line">    st := reflect.TypeOf(s)</span><br><span class="line">    field := st.Field(0)</span><br><span class="line">    fmt.Println(field.Tag.Get(&quot;color&quot;), field.Tag.Get(&quot;species&quot;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="interface-到函数反射"><a href="#interface-到函数反射" class="headerlink" title="interface{}到函数反射"></a>interface{}到函数反射</h2><p>一般情况下，为了存储多个函数值，一般采用<code>map</code>来存储。其中key为函数名称，而value为相应的处理函数。<br>在这里需要定义好函数类型，但是函数的参数以及返回类型就需要是统一的，如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func say(text string) &#123;</span><br><span class="line">    fmt.Println(text)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    var funcMap = make(map[string]func(string))</span><br><span class="line">    funcMap[&quot;say&quot;] = say</span><br><span class="line">    funcMap[&quot;say&quot;](&quot;hello&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果希望<code>map</code>可以存储任意类型的函数（参数不同，返回值不同），那么就需要用interface{}而不是func(param…)来定义value。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func say(text string) &#123;</span><br><span class="line">    fmt.Println(text)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    var funcMap = make(map[string]interface&#123;&#125;)</span><br><span class="line">    funcMap[&quot;say&quot;] = say</span><br><span class="line">    funcMap[&quot;say&quot;](&quot;hello&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cannot call non-function funcMap[&quot;say&quot;] (type interface &#123;&#125;)</span><br></pre></td></tr></table></figure>
<p>直接调用会报错，提示不能调用interface{}类型的函数。</p>
<p>这时，需要利用<code>reflect</code>把函数从interface转换到函数来使用，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;reflect&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func say(text string) &#123;</span><br><span class="line">    fmt.Println(text)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func Call(m map[string]interface&#123;&#125;, name string, params ... interface&#123;&#125;) (result []reflect.Value) &#123;</span><br><span class="line">    f := reflect.ValueOf(m[name]) // 把函数转化为reflect value</span><br><span class="line">    in := make([]reflect.Value, len(params))</span><br><span class="line">    for k, param := range params &#123;</span><br><span class="line">        in[k] = reflect.ValueOf(param) // 把参数转为为[] reflect value</span><br><span class="line">    &#125;</span><br><span class="line">    result = f.Call(in)</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    var funcMap = make(map[string]interface&#123;&#125;)</span><br><span class="line">    funcMap[&quot;say&quot;] = say</span><br><span class="line">    Call(funcMap, &quot;say&quot;, &quot;hello&quot;)</span><br></pre></td></tr></table></figure></p>
<p>其中，使用Call函数，调用函数v，参数为[]value<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func (v Value) Call(in []Value) []Value</span><br></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> go </category>
            
        </categories>
        
        
        <tags>
            
            <tag> go </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[模拟退火算法]]></title>
      <url>/2015/09/22/simulate-anneal/</url>
      <content type="html"><![CDATA[<p>模拟退火算法<br><a id="more"></a></p>
<h2 id="搜索算法"><a href="#搜索算法" class="headerlink" title="搜索算法"></a>搜索算法</h2><p><strong>启发式搜索</strong></p>
<p>按照预定的控制策略实行搜索，在搜索过程中获取的中间信息补用来改进控制策略，称为盲目搜索，反之，称为启发式搜索。</p>
<p>常见的深度优先和广度优先搜索算法都属于盲目搜索；而爬山法、模拟退火算法、遗传算法和蚁群算法等都属于启发式搜索。</p>
<h2 id="模拟退火算法"><a href="#模拟退火算法" class="headerlink" title="模拟退火算法"></a>模拟退火算法</h2><p>模拟退火算法属于启发式算法。</p>
<h3 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h3><p>模拟退火算法是来源于固体退火原理，将固体加温至充分高，再让其嘘嘘冷却，加温时，固体内部粒子随温度升高变为无序状，内能增大，而徐徐冷却时粒子逐渐有序，每个温度都达到平衡状态，最后在常温时达到基态，内能减为最小。</p>
<p>根据<code>Metropolis</code>准则，固体内部粒子在温度T时趋于平衡的概率为<code>exp(△E/(kT))</code>，其中E为温度T时的内能，△E为其改变量，k为Boltzmann常数。</p>
<p>$$f(n)=\begin{cases}1, \quad if \quad E(x_{new}) &lt; E(x_{old})\\<br>exp(-\frac{E(x_{new})-E(x_{old})}{T}), \quad if \quad E(x_{new}) &gt; E(x_{old}) \end{cases}$$</p>
<h3 id="主要思想"><a href="#主要思想" class="headerlink" title="主要思想"></a>主要思想</h3><p>用固体退火模拟组合优化问题，可以将内能E模拟为目标函数值f，温度T演化成控制参数。</p>
<p><strong>算法流程</strong></p>
<ul>
<li>随机产生一个初始解$ x_0 $, 令$ x_{best} = x_0 $， 并计算目标函数值$E(x_0)$</li>
<li>设置初始温度$ T_0 $，迭代次数为N,i=0记录迭代次数</li>
<li>当i &lt; N, 并且不满足终止条件，<ul>
<li>对当前最优解$ x_{best} $按照某一邻域函数产生一个新的解$ x_{new} $。计算新的目标函数值$ E(x_{new}) $，从而得到目标函数值的增量$△E = E(x_{new}) - E(x_{best})$</li>
<li>应用Metropolis准则，当△E &lt; 0时，总是接受移动$x_{best}=x_{new}$，否则以一定概率接受移动$p=exp(-△E/T(i))$</li>
<li>i += 1</li>
</ul>
</li>
<li>输出当前最优解，计算结束</li>
</ul>
<p><strong>伪代码</strong></p>
<p>来自wikipedia</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">s := 0; e := E(s)</span><br><span class="line">k := 0                   ##       //k为评估次数</span><br><span class="line">while k &lt; kmax and e &gt; emax     //kmax最大评估次数，emax可接受的最大结果</span><br><span class="line">    sn := neighbour(s)          //随机选取一个邻居状态</span><br><span class="line">    en := E(sn)                 //能量结果</span><br><span class="line">    if random() &lt; P(e, en, temp(k/kmax)) then</span><br><span class="line">        s := sn; e := en        //如果满足metropolis准则，则移动到该邻居节点</span><br><span class="line">    k += 1                      //评估完成，次数+1</span><br><span class="line">return s</span><br></pre></td></tr></table></figure>
<h3 id="冷却进度"><a href="#冷却进度" class="headerlink" title="冷却进度"></a>冷却进度</h3><p>这面两种方法都能够让模拟退火算法收敛于局部最小。</p>
<p>经典模拟退火算法的降温方式,从下面的公式中可以得出，该算法是一种指数的变化趋势</p>
<p>$T(t)=\frac {T_0} {lg(1+t)}$</p>
<p>快速模拟退火算法的降温方式，稳定变化</p>
<p>$T(t)=\frac {T_0} {1 + t}$</p>
<h3 id="终止条件"><a href="#终止条件" class="headerlink" title="终止条件"></a>终止条件</h3><ul>
<li>设置终止的目标值</li>
<li>迭代次数限制</li>
<li>连续若干步保持不变</li>
<li>系统熵是否稳定</li>
</ul>
<h3 id="改进策略"><a href="#改进策略" class="headerlink" title="改进策略"></a>改进策略</h3><ul>
<li>增加升温或重升温策略，调整搜索进程中的状态，避免陷入局部最优</li>
<li>增加移动的记忆功能，避免遗失当前遇到过的最优解</li>
<li>结合其他搜索方法</li>
</ul>
]]></content>
      
        <categories>
            
            <category> algorithm </category>
            
        </categories>
        
        
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MySQL实现嵌套集合模型(Nested Set Model)]]></title>
      <url>/2015/09/22/Nested-Set-Model/</url>
      <content type="html"><![CDATA[<p>译文主要是介绍如何用MySQL来存储嵌套集合数据。在其中会增加一些自己的理解，也会删除掉一些自认为无用的废话。<br><a id="more"></a><br>这篇文章主要讲的是嵌套集合模型，所以邻接表不是本文的重点，简单略过就好。</p>
<p>也许这是<a href="http://mikehillyer.com/articles/managing-hierarchical-data-in-mysql/" target="_blank" rel="external">原文地址</a>，因为我也不知道这是不是原文。</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><strong>什么是分层数据？</strong><br>类似于树形结构，除了根节点和叶子节点外，所有节点都有用一个父节点和多个子节点。</p>
<p><img src="/images/Nested-Set-Model-1.png" alt=""></p>
<p>那么，在MySQL中如何处理分层数据呢？</p>
<p>原文中介绍了两种分层结构模型：<code>邻接表模型</code>和<code>嵌套集合模型</code>。</p>
<h2 id="邻接表模型-The-Adjacency-List-Model"><a href="#邻接表模型-The-Adjacency-List-Model" class="headerlink" title="邻接表模型(The Adjacency List Model)"></a>邻接表模型(The Adjacency List Model)</h2><p>首先，建立测试表，导入测试数据，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE category(</span><br><span class="line">        category_id INT AUTO_INCREMENT PRIMARY KEY,</span><br><span class="line">        name VARCHAR(20) NOT NULL,</span><br><span class="line">        parent INT DEFAULT NULL</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">INSERT INTO category VALUES</span><br><span class="line">        (1,&apos;ELECTRONICS&apos;,NULL),</span><br><span class="line">        (2,&apos;TELEVISIONS&apos;,1),</span><br><span class="line">        (3,&apos;TUBE&apos;,2),</span><br><span class="line">        (4,&apos;LCD&apos;,2),</span><br><span class="line">        (5,&apos;PLASMA&apos;,2),</span><br><span class="line">        (6,&apos;PORTABLE ELECTRONICS&apos;,1),</span><br><span class="line">        (7,&apos;MP3 PLAYERS&apos;,6),</span><br><span class="line">        (8,&apos;FLASH&apos;,7),</span><br><span class="line">        (9,&apos;CD PLAYERS&apos;,6),</span><br><span class="line">        (10,&apos;2 WAY RADIOS&apos;,6);</span><br><span class="line"></span><br><span class="line">SELECT * FROM category ORDER BY category_id;</span><br><span class="line">+-------------+----------------------+--------+</span><br><span class="line">| category_id | name                 | parent |</span><br><span class="line">+-------------+----------------------+--------+</span><br><span class="line">|           1 | ELECTRONICS          |   NULL |</span><br><span class="line">|           2 | TELEVISIONS          |      1 |</span><br><span class="line">|           3 | TUBE                 |      2 |</span><br><span class="line">|           4 | LCD                  |      2 |</span><br><span class="line">|           5 | PLASMA               |      2 |</span><br><span class="line">|           6 | PORTABLE ELECTRONICS |      1 |</span><br><span class="line">|           7 | MP3 PLAYERS          |      6 |</span><br><span class="line">|           8 | FLASH                |      7 |</span><br><span class="line">|           9 | CD PLAYERS           |      6 |</span><br><span class="line">|          10 | 2 WAY RADIOS         |      6 |</span><br><span class="line">+-------------+----------------------+--------+</span><br><span class="line">10 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></p>
<p>在邻接表中，所有的数据均拥有一个Parent字段，用来存储它的父节点。当前节点为根节点的话，它的父节点则为NULL。<br>那么在遍历的时候，可以使用递归来实现查询整棵树，从根节点开始，不断寻找子节点（父节点-&gt;子节点-&gt;父节点-&gt;子节点）。</p>
<h3 id="检索分层路径"><a href="#检索分层路径" class="headerlink" title="检索分层路径"></a>检索分层路径</h3><p>一般需要获取一个分层结构的路径问题，那么</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">SELECT t1.name AS lev1, t2.name as lev2, t3.name as lev3, t4.name as lev4</span><br><span class="line">FROM category AS t1</span><br><span class="line">LEFT JOIN category AS t2 ON t2.parent = t1.category_id</span><br><span class="line">LEFT JOIN category AS t3 ON t3.parent = t2.category_id</span><br><span class="line">LEFT JOIN category AS t4 ON t4.parent = t3.category_id</span><br><span class="line">WHERE t1.name = &apos;ELECTRONICS&apos;;</span><br><span class="line"></span><br><span class="line">+-------------+----------------------+--------------+-------+</span><br><span class="line">| lev1        | lev2                 | lev3         | lev4  |</span><br><span class="line">+-------------+----------------------+--------------+-------+</span><br><span class="line">| ELECTRONICS | TELEVISIONS          | TUBE         | NULL  |</span><br><span class="line">| ELECTRONICS | TELEVISIONS          | LCD          | NULL  |</span><br><span class="line">| ELECTRONICS | TELEVISIONS          | PLASMA       | NULL  |</span><br><span class="line">| ELECTRONICS | PORTABLE ELECTRONICS | MP3 PLAYERS  | FLASH |</span><br><span class="line">| ELECTRONICS | PORTABLE ELECTRONICS | CD PLAYERS   | NULL  |</span><br><span class="line">| ELECTRONICS | PORTABLE ELECTRONICS | 2 WAY RADIOS | NULL  |</span><br><span class="line">+-------------+----------------------+--------------+-------+</span><br><span class="line">6 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<h2 id="检索叶子节点"><a href="#检索叶子节点" class="headerlink" title="#检索叶子节点"></a>#检索叶子节点</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">SELECT t1.name FROM</span><br><span class="line">category AS t1 LEFT JOIN category as t2</span><br><span class="line">ON t1.category_id = t2.parent</span><br><span class="line">WHERE t2.category_id IS NULL;</span><br><span class="line"></span><br><span class="line">+--------------+</span><br><span class="line">| name         |</span><br><span class="line">+--------------+</span><br><span class="line">| TUBE         |</span><br><span class="line">| LCD          |</span><br><span class="line">| PLASMA       |</span><br><span class="line">| FLASH        |</span><br><span class="line">| CD PLAYERS   |</span><br><span class="line">| 2 WAY RADIOS |</span><br><span class="line">+--------------+</span><br></pre></td></tr></table></figure>
<h2 id="检索指定路径"><a href="#检索指定路径" class="headerlink" title="#检索指定路径"></a>#检索指定路径</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SELECT t1.name AS lev1, t2.name as lev2, t3.name as lev3, t4.name as lev4</span><br><span class="line">FROM category AS t1</span><br><span class="line">LEFT JOIN category AS t2 ON t2.parent = t1.category_id</span><br><span class="line">LEFT JOIN category AS t3 ON t3.parent = t2.category_id</span><br><span class="line">LEFT JOIN category AS t4 ON t4.parent = t3.category_id</span><br><span class="line">WHERE t1.name = &apos;ELECTRONICS&apos; AND t4.name = &apos;FLASH&apos;;</span><br><span class="line"></span><br><span class="line">+-------------+----------------------+-------------+-------+</span><br><span class="line">| lev1        | lev2                 | lev3        | lev4  |</span><br><span class="line">+-------------+----------------------+-------------+-------+</span><br><span class="line">| ELECTRONICS | PORTABLE ELECTRONICS | MP3 PLAYERS | FLASH |</span><br><span class="line">+-------------+----------------------+-------------+-------+</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure>
<h3 id="邻接表的缺点"><a href="#邻接表的缺点" class="headerlink" title="邻接表的缺点"></a>邻接表的缺点</h3><p>在检索路径的过程中，除了本层外，每一层都会对应一个<code>LEFT JOIN</code>，那么如果层数不定怎么办？或者层数过多？<br>在删除中间层的节点时，需要同时删除该节点下的所有节点，否则会出现孤立节点。</p>
<h2 id="嵌套集合模型Nested-Set-Model"><a href="#嵌套集合模型Nested-Set-Model" class="headerlink" title="嵌套集合模型Nested Set Model"></a>嵌套集合模型Nested Set Model</h2><p>原文中主要的目的是介绍嵌套集合模型，如下<br><img src="/images/Nested-Set-Model-2.png" alt=""></p>
<p>通过集合的包含关系，嵌套结合模型可以表示分层结构，每一个分层可以用一个Set来表示（一个圈），父节点所在的圈包含所有子节点所在的圈。</p>
<p>为了用MySQL来表示集合关系，需要定义连个字段<code>left</code>和<code>right</code>（表示一个集合的范围）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE nested_category (</span><br><span class="line">        category_id INT AUTO_INCREMENT PRIMARY KEY,</span><br><span class="line">        name VARCHAR(20) NOT NULL,</span><br><span class="line">        lft INT NOT NULL,</span><br><span class="line">        rgt INT NOT NULL</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">INSERT INTO nested_category VALUES</span><br><span class="line">  (1,&apos;ELECTRONICS&apos;,1,20),</span><br><span class="line">  (2,&apos;TELEVISIONS&apos;,2,9),</span><br><span class="line">  (3,&apos;TUBE&apos;,3,4),</span><br><span class="line">  (4,&apos;LCD&apos;,5,6),</span><br><span class="line">  (5,&apos;PLASMA&apos;,7,8),</span><br><span class="line">  (6,&apos;PORTABLE ELECTRONICS&apos;,10,19),</span><br><span class="line">  (7,&apos;MP3 PLAYERS&apos;,11,14),</span><br><span class="line">  (8,&apos;FLASH&apos;,12,13),</span><br><span class="line">  (9,&apos;CD PLAYERS&apos;,15,16),</span><br><span class="line">  (10,&apos;2 WAY RADIOS&apos;,17,18);</span><br><span class="line"></span><br><span class="line">SELECT * FROM nested_category ORDER BY category_id;</span><br><span class="line"></span><br><span class="line">+-------------+----------------------+-----+-----+</span><br><span class="line">| category_id | name                 | lft | rgt |</span><br><span class="line">+-------------+----------------------+-----+-----+</span><br><span class="line">|           1 | ELECTRONICS          |   1 |  20 |</span><br><span class="line">|           2 | TELEVISIONS          |   2 |   9 |</span><br><span class="line">|           3 | TUBE                 |   3 |   4 |</span><br><span class="line">|           4 | LCD                  |   5 |   6 |</span><br><span class="line">|           5 | PLASMA               |   7 |   8 |</span><br><span class="line">|           6 | PORTABLE ELECTRONICS |  10 |  19 |</span><br><span class="line">|           7 | MP3 PLAYERS          |  11 |  14 |</span><br><span class="line">|           8 | FLASH                |  12 |  13 |</span><br><span class="line">|           9 | CD PLAYERS           |  15 |  16 |</span><br><span class="line">|          10 | 2 WAY RADIOS         |  17 |  18 |</span><br><span class="line">+-------------+----------------------+-----+-----+</span><br></pre></td></tr></table></figure>
<p>由于<code>left</code>和<code>right</code>是MySQL的保留字，因此，字段名称用lft和rgt代替。每一个集合都是从lft开始到rgt结束，也就是集合的两个边界。<br><img src="/images/Nested-Set-Model-3.png" alt=""></p>
<p>在树中也同样适用，<br><img src="/images/Nested-Set-Model-4.png" alt=""></p>
<p>当为树状结构编号时，我们从左到右，一次一层，赋值按照从左到右的顺序遍历其子节点，这种方法称为<code>先序遍历算法</code>。</p>
<h3 id="检索分层路径-1"><a href="#检索分层路径-1" class="headerlink" title="检索分层路径"></a>检索分层路径</h3><p>由于子节点的lft值总在父节点的lft和rgt值之间，所以可以通过父节点连接到子节点上来检索整棵树。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">SELECT node.name</span><br><span class="line">FROM nested_category AS node,</span><br><span class="line">        nested_category AS parent</span><br><span class="line">WHERE node.lft BETWEEN parent.lft AND parent.rgt</span><br><span class="line">        AND parent.name = &apos;ELECTRONICS&apos;</span><br><span class="line">ORDER BY node.lft;</span><br><span class="line"></span><br><span class="line">+----------------------+</span><br><span class="line">| name                 |</span><br><span class="line">+----------------------+</span><br><span class="line">| ELECTRONICS          |</span><br><span class="line">| TELEVISIONS          |</span><br><span class="line">| TUBE                 |</span><br><span class="line">| LCD                  |</span><br><span class="line">| PLASMA               |</span><br><span class="line">| PORTABLE ELECTRONICS |</span><br><span class="line">| MP3 PLAYERS          |</span><br><span class="line">| FLASH                |</span><br><span class="line">| CD PLAYERS           |</span><br><span class="line">| 2 WAY RADIOS         |</span><br><span class="line">+----------------------+&lt;/pre&gt;</span><br></pre></td></tr></table></figure>
<p>这个方法并不需要考虑层数，而且不需要考虑节点的rgt。</p>
<h3 id="检索所有叶子节点"><a href="#检索所有叶子节点" class="headerlink" title="检索所有叶子节点"></a>检索所有叶子节点</h3><p>由于每一个叶子节点的<code>rgt=lft+1</code>，那么只需要这一个条件即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">SELECT name</span><br><span class="line">FROM nested_category</span><br><span class="line">WHERE rgt = lft + 1;</span><br><span class="line"></span><br><span class="line">+--------------+</span><br><span class="line">| name         |</span><br><span class="line">+--------------+</span><br><span class="line">| TUBE         |</span><br><span class="line">| LCD          |</span><br><span class="line">| PLASMA       |</span><br><span class="line">| FLASH        |</span><br><span class="line">| CD PLAYERS   |</span><br><span class="line">| 2 WAY RADIOS |</span><br><span class="line">+--------------+</span><br></pre></td></tr></table></figure>
<h3 id="检索节点路径"><a href="#检索节点路径" class="headerlink" title="检索节点路径"></a>检索节点路径</h3><p>不再需要多个join连接操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">SELECT parent.name</span><br><span class="line">FROM nested_category AS node,</span><br><span class="line">        nested_category AS parent</span><br><span class="line">WHERE node.lft BETWEEN parent.lft AND parent.rgt</span><br><span class="line">        AND node.name = &apos;FLASH&apos;</span><br><span class="line">ORDER BY node.lft;</span><br><span class="line"></span><br><span class="line">+----------------------+</span><br><span class="line">| name                 |</span><br><span class="line">+----------------------+</span><br><span class="line">| ELECTRONICS          |</span><br><span class="line">| PORTABLE ELECTRONICS |</span><br><span class="line">| MP3 PLAYERS          |</span><br><span class="line">| FLASH                |</span><br><span class="line">+----------------------+</span><br></pre></td></tr></table></figure>
<h3 id="检索节点深度"><a href="#检索节点深度" class="headerlink" title="检索节点深度"></a>检索节点深度</h3><p>通过<code>COUNT</code>和<code>GROUP BY</code>函数来获取父节点的个数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">SELECT node.name, (COUNT(parent.name) - 1) AS depth</span><br><span class="line">FROM nested_category AS node,</span><br><span class="line">        nested_category AS parent</span><br><span class="line">WHERE node.lft BETWEEN parent.lft AND parent.rgt</span><br><span class="line">GROUP BY node.name</span><br><span class="line">ORDER BY node.lft;</span><br><span class="line"></span><br><span class="line">+----------------------+-------+</span><br><span class="line">| name                 | depth |</span><br><span class="line">+----------------------+-------+</span><br><span class="line">| ELECTRONICS          |     0 |</span><br><span class="line">| TELEVISIONS          |     1 |</span><br><span class="line">| TUBE                 |     2 |</span><br><span class="line">| LCD                  |     2 |</span><br><span class="line">| PLASMA               |     2 |</span><br><span class="line">| PORTABLE ELECTRONICS |     1 |</span><br><span class="line">| MP3 PLAYERS          |     2 |</span><br><span class="line">| FLASH                |     3 |</span><br><span class="line">| CD PLAYERS           |     2 |</span><br><span class="line">| 2 WAY RADIOS         |     2 |</span><br><span class="line">+----------------------+-------+</span><br></pre></td></tr></table></figure>
<p>甚至可以得到分层的缩进结果，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">SELECT CONCAT( REPEAT(&apos; &apos;, COUNT(parent.name) - 1), node.name) AS name</span><br><span class="line">FROM nested_category AS node,</span><br><span class="line">        nested_category AS parent</span><br><span class="line">WHERE node.lft BETWEEN parent.lft AND parent.rgt</span><br><span class="line">GROUP BY node.name</span><br><span class="line">ORDER BY node.lft;</span><br><span class="line"></span><br><span class="line">+-----------------------+</span><br><span class="line">| name                  |</span><br><span class="line">+-----------------------+</span><br><span class="line">| ELECTRONICS           |</span><br><span class="line">|  TELEVISIONS          |</span><br><span class="line">|   TUBE                |</span><br><span class="line">|   LCD                 |</span><br><span class="line">|   PLASMA              |</span><br><span class="line">|  PORTABLE ELECTRONICS |</span><br><span class="line">|   MP3 PLAYERS         |</span><br><span class="line">|    FLASH              |</span><br><span class="line">|   CD PLAYERS          |</span><br><span class="line">|   2 WAY RADIOS        |</span><br><span class="line">+-----------------------+</span><br></pre></td></tr></table></figure>
<h3 id="检索子树的深度"><a href="#检索子树的深度" class="headerlink" title="检索子树的深度"></a>检索子树的深度</h3><p>考虑到检索中需要自连接的node或parent，因此需要增加一个额外的连接来作为子查询来限制子树。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">SELECT node.name, (COUNT(parent.name) - (sub_tree.depth + 1)) AS depth</span><br><span class="line">FROM nested_category AS node,</span><br><span class="line">        nested_category AS parent,</span><br><span class="line">        nested_category AS sub_parent,</span><br><span class="line">        (</span><br><span class="line">                SELECT node.name, (COUNT(parent.name) - 1) AS depth</span><br><span class="line">                FROM nested_category AS node,</span><br><span class="line">                nested_category AS parent</span><br><span class="line">                WHERE node.lft BETWEEN parent.lft AND parent.rgt</span><br><span class="line">                AND node.name = &apos;PORTABLE ELECTRONICS&apos;</span><br><span class="line">                GROUP BY node.name</span><br><span class="line">                ORDER BY node.lft</span><br><span class="line">        )AS sub_tree</span><br><span class="line">WHERE node.lft BETWEEN parent.lft AND parent.rgt</span><br><span class="line">        AND node.lft BETWEEN sub_parent.lft AND sub_parent.rgt</span><br><span class="line">        AND sub_parent.name = sub_tree.name</span><br><span class="line">GROUP BY node.name</span><br><span class="line">ORDER BY node.lft;</span><br><span class="line"></span><br><span class="line">+----------------------+-------+</span><br><span class="line">| name                 | depth |</span><br><span class="line">+----------------------+-------+</span><br><span class="line">| PORTABLE ELECTRONICS |     0 |</span><br><span class="line">| MP3 PLAYERS          |     1 |</span><br><span class="line">| FLASH                |     2 |</span><br><span class="line">| CD PLAYERS           |     1 |</span><br><span class="line">| 2 WAY RADIOS         |     1 |</span><br><span class="line">+----------------------+-------+</span><br></pre></td></tr></table></figure>
<h3 id="检索节点的直接子节点"><a href="#检索节点的直接子节点" class="headerlink" title="检索节点的直接子节点"></a>检索节点的直接子节点</h3><p>假设一个场景，当用户点击网站上电子产品的一个分类时，将呈现该分类下的产品，同时需要列出所有子分类，并不是全部分类。<br>为了限制显示分类的层数，需要使用<code>HAVING</code>字句，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">SELECT node.name, (COUNT(parent.name) - (sub_tree.depth + 1)) AS depth</span><br><span class="line">FROM nested_category AS node,</span><br><span class="line">        nested_category AS parent,</span><br><span class="line">        nested_category AS sub_parent,</span><br><span class="line">        (</span><br><span class="line">                SELECT node.name, (COUNT(parent.name) - 1) AS depth</span><br><span class="line">                FROM nested_category AS node,</span><br><span class="line">                        nested_category AS parent</span><br><span class="line">                WHERE node.lft BETWEEN parent.lft AND parent.rgt</span><br><span class="line">                        AND node.name = &apos;PORTABLE ELECTRONICS&apos;</span><br><span class="line">                GROUP BY node.name</span><br><span class="line">                ORDER BY node.lft</span><br><span class="line">        )AS sub_tree</span><br><span class="line">WHERE node.lft BETWEEN parent.lft AND parent.rgt</span><br><span class="line">        AND node.lft BETWEEN sub_parent.lft AND sub_parent.rgt</span><br><span class="line">        AND sub_parent.name = sub_tree.name</span><br><span class="line">GROUP BY node.name</span><br><span class="line">HAVING depth &amp;lt;= 1</span><br><span class="line">ORDER BY node.lft;</span><br><span class="line"></span><br><span class="line">+----------------------+-------+</span><br><span class="line">| name                 | depth |</span><br><span class="line">+----------------------+-------+</span><br><span class="line">| PORTABLE ELECTRONICS |     0 |</span><br><span class="line">| MP3 PLAYERS          |     1 |</span><br><span class="line">| CD PLAYERS           |     1 |</span><br><span class="line">| 2 WAY RADIOS         |     1 |</span><br><span class="line">+----------------------+-------+</span><br></pre></td></tr></table></figure>
<h3 id="增加新节点"><a href="#增加新节点" class="headerlink" title="增加新节点"></a>增加新节点</h3><p>上面已经介绍了如何检索结果，那么如何才能增加新的节点呢？<br><img src="/images/Nested-Set-Model-5.png" alt=""></p>
<p>如果希望在TELEVISIONS和PROTABLE ELECTRONICS节点之间增加一个新的节点，那么新节点的lft和rgt的值应该是10和11，那么所有大于10的节点（新节点右侧的节点）的lft和rgt都应该加2，如上图所示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">LOCK TABLE nested_category WRITE;</span><br><span class="line"></span><br><span class="line">SELECT @myRight := rgt FROM nested_category</span><br><span class="line">WHERE name = &apos;TELEVISIONS&apos;;</span><br><span class="line"></span><br><span class="line">UPDATE nested_category SET rgt = rgt + 2 WHERE rgt &amp;gt; @myRight;</span><br><span class="line">UPDATE nested_category SET lft = lft + 2 WHERE lft &amp;gt; @myRight;</span><br><span class="line"></span><br><span class="line">INSERT INTO nested_category(name, lft, rgt) VALUES(&apos;GAME CONSOLES&apos;, @myRight + 1, @myRight + 2);</span><br><span class="line"></span><br><span class="line">UNLOCK TABLES</span><br></pre></td></tr></table></figure>
<p>如果希望在叶子节点下增加节点，需要修改下查询语句，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">LOCK TABLE nested_category WRITE;</span><br><span class="line"></span><br><span class="line">SELECT @myLeft := lft FROM nested_category</span><br><span class="line"></span><br><span class="line">WHERE name = &apos;2 WAY RADIOS&apos;;</span><br><span class="line"></span><br><span class="line">UPDATE nested_category SET rgt = rgt + 2 WHERE rgt &amp;gt; @myLeft;</span><br><span class="line">UPDATE nested_category SET lft = lft + 2 WHERE lft &amp;gt; @myLeft;</span><br><span class="line"></span><br><span class="line">INSERT INTO nested_category(name, lft, rgt) VALUES(&apos;FRS&apos;, @myLeft + 1, @myLeft + 2);</span><br><span class="line"></span><br><span class="line">UNLOCK TABLES;</span><br></pre></td></tr></table></figure>
<h3 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h3><p>删除叶子节点比较容易，只需要删除自己，而删除一个中间层节点就需要删除其所有子节点。在这个模型中，所有子节点的节点正好在lft和rgt之间。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">LOCK TABLE nested_category WRITE;</span><br><span class="line"></span><br><span class="line">SELECT @myLeft := lft, @myRight := rgt, @myWidth := rgt - lft + 1</span><br><span class="line">FROM nested_category</span><br><span class="line">WHERE name = &apos;GAME CONSOLES&apos;;</span><br><span class="line"></span><br><span class="line">DELETE FROM nested_category WHERE lft BETWEEN @myLeft AND @myRight;</span><br><span class="line"></span><br><span class="line">UPDATE nested_category SET rgt = rgt - @myWidth WHERE rgt &amp;gt; @myRight;</span><br><span class="line">UPDATE nested_category SET lft = lft - @myWidth WHERE lft &amp;gt; @myRight;</span><br><span class="line"></span><br><span class="line">UNLOCK TABLES;</span><br></pre></td></tr></table></figure>
<p>在某些情况下，只需要删除某个节点，但是并不希望删除该节点下的子节点数据。<br>通过把右侧所有节点的左右值-2，当前节点的子节点左右值-1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">LOCK TABLE nested_category WRITE;</span><br><span class="line"></span><br><span class="line">SELECT @myLeft := lft, @myRight := rgt, @myWidth := rgt - lft + 1</span><br><span class="line">FROM nested_category</span><br><span class="line">WHERE name = &apos;PORTABLE ELECTRONICS&apos;;</span><br><span class="line"></span><br><span class="line">DELETE FROM nested_category WHERE lft = @myLeft;</span><br><span class="line"></span><br><span class="line">UPDATE nested_category SET rgt = rgt - 1, lft = lft - 1 WHERE lft BETWEEN @myLeft AND @myRight;</span><br><span class="line">UPDATE nested_category SET rgt = rgt - 2 WHERE rgt &amp;gt; @myRight;</span><br><span class="line">UPDATE nested_category SET lft = lft - 2 WHERE lft &amp;gt; @myRight;</span><br><span class="line"></span><br><span class="line">UNLOCK TABLES;</span><br></pre></td></tr></table></figure></p>
<h2 id="最后的思考"><a href="#最后的思考" class="headerlink" title="最后的思考"></a>最后的思考</h2><p>原作者推荐了一本名为《Joe Celko’s Trees and Hierarchies in SQL for Smarties》的书籍，该书的作者是SQL领域的大神Joe Celko（嵌套几何模型的创造者）。这本书涵盖了本文中未涉及到的一些高级话题。</p>
]]></content>
      
        <categories>
            
            <category> db </category>
            
        </categories>
        
        
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Go项目结构和模块导入]]></title>
      <url>/2015/09/17/golang-project-import/</url>
      <content type="html"><![CDATA[<p>golang项目结构与其他语言类似，但是仍然有一些需要注意的地方。<br><a id="more"></a></p>
<h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><p>go 命令依赖一个重要的环境变量：<code>$GOPATH</code>，它表示GO项目的路径，如下设置</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> GOPATH=/home/t/gospace</span><br></pre></td></tr></table></figure>
<p>对于GOPATH来说，允许多个项目目录（Unix中为“：”，Windows中为“；”）。</p>
<h3 id="项目目录"><a href="#项目目录" class="headerlink" title="项目目录"></a>项目目录</h3><p>在项目目录中，一般包含三个文件夹，分别为<code>src</code>，<code>pkg</code>和 <code>bin</code>。各个文件夹功能如下，</p>
<ul>
<li>src 存放golang源码</li>
<li>pkg 存放编译后的文件</li>
<li>bin 存放编译后可执行的文件</li>
</ul>
<h2 id="模块导入"><a href="#模块导入" class="headerlink" title="模块导入"></a>模块导入</h2><p>在golang中，模块导入包括两种导入方式：相对路径和绝对路径。</p>
<h3 id="相对导入"><a href="#相对导入" class="headerlink" title="相对导入"></a>相对导入</h3><p>当前文件同一目录的model目录，但是不建议这种方式来import</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"./test1"</span></span><br><span class="line">    <span class="string">"../test2"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="绝对导入"><a href="#绝对导入" class="headerlink" title="绝对导入"></a>绝对导入</h3><p>前提条件需要把该项目加入到golang的GOPATH中，</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"project/module1"</span></span><br><span class="line">    <span class="string">"project/module2/t"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h2 id="import的其他操作"><a href="#import的其他操作" class="headerlink" title="import的其他操作"></a>import的其他操作</h2><h3 id="点操作"><a href="#点操作" class="headerlink" title="点操作"></a>点操作</h3><p>点操作的含义就是这个包导入之后在你调用这个包的函数时，你可以省略前缀的包名,</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> . <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Println(<span class="string">"test"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="别名操作"><a href="#别名操作" class="headerlink" title="别名操作"></a>别名操作</h3><p>别名操作就是把包命名成另一个名字</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> f <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    f.Println(<span class="string">"test"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="操作"><a href="#操作" class="headerlink" title="_操作"></a>_操作</h3><p>操作其实是引入该包，而不直接使用包里面的函数，而是调用了该包里面的init函数</p>
<p>文件1： module/module1.go<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> module1</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">   fmt.Println(<span class="string">"this is module1"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>文件2： main.go<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    _ <span class="string">"module"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"this is a test"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>output:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">this is module1</span><br><span class="line">this is a test</span><br></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> go </category>
            
        </categories>
        
        
        <tags>
            
            <tag> go </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[sqlalchemy(二)高级用法]]></title>
      <url>/2015/08/19/sqlalchemy2/</url>
      <content type="html"><![CDATA[<p>本文将介绍sqlalchemy的高级用法。<br><a id="more"></a></p>
<h2 id="外键以及relationship"><a href="#外键以及relationship" class="headerlink" title="外键以及relationship"></a>外键以及relationship</h2><p>首先创建数据库，在这里一个user对应多个address，因此需要在address上增加user_id这个外键（一对多）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># encoding: utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> create_engine</span><br><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> Column</span><br><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> Integer</span><br><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> String</span><br><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> ForeignKey</span><br><span class="line"><span class="keyword">from</span> sqlalchemy.orm <span class="keyword">import</span> backref</span><br><span class="line"><span class="keyword">from</span> sqlalchemy.orm <span class="keyword">import</span> sessionmaker</span><br><span class="line"><span class="keyword">from</span> sqlalchemy.orm <span class="keyword">import</span> relationship, backref</span><br><span class="line"><span class="keyword">from</span> sqlalchemy.ext.declarative <span class="keyword">import</span> declarative_base</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Base = declarative_base()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span><span class="params">(Base)</span>:</span></span><br><span class="line">    __tablename__ = <span class="string">'users'</span></span><br><span class="line"></span><br><span class="line">    id = Column(Integer, primary_key=<span class="keyword">True</span>)</span><br><span class="line">    name = Column(String(<span class="number">32</span>))</span><br><span class="line"></span><br><span class="line">    addresses = relationship(<span class="string">"Address"</span>, order_by=<span class="string">"Address.id"</span>, backref=<span class="string">"user"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Address</span><span class="params">(Base)</span>:</span></span><br><span class="line">    __tablename__ = <span class="string">'addresses'</span></span><br><span class="line">    id = Column(Integer, primary_key=<span class="keyword">True</span>)</span><br><span class="line">    email_address = Column(String(<span class="number">32</span>), nullable=<span class="keyword">False</span>)</span><br><span class="line">    user_id = Column(Integer, ForeignKey(<span class="string">'users.id'</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">#user = relationship("User", backref=backref('addresses', order_by=id))</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">engine  = create_engine(<span class="string">'mysql://root:root@localhost:3306/test'</span>, echo=<span class="keyword">True</span>)</span><br><span class="line"><span class="comment">#Base.metadata.create_all(engine)</span></span><br></pre></td></tr></table></figure>
<p>接下来，调用user和address来添加数据，</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>jack = User(name=<span class="string">'jack'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>jack.address</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">AttributeError: <span class="string">'User'</span> object has no attribute <span class="string">'address'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>jack.addresses</span><br><span class="line">[]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>jack.addresses = [Address(email_address=<span class="string">'test@test.com'</span>), Address(email_address=<span class="string">'test1@test1.com'</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>jack.addresses</span><br><span class="line">[&lt;demo.Address object at <span class="number">0x7f2536564f90</span>&gt;, &lt;demo.Address object at <span class="number">0x7f2535dc71d0</span>&gt;]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>session.add(jack)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>session.commit()</span><br><span class="line"><span class="number">2015</span><span class="number">-08</span><span class="number">-19</span> <span class="number">13</span>:<span class="number">45</span>:<span class="number">36</span>,<span class="number">237</span> INFO sqlalchemy.engine.base.Engine SHOW VARIABLES LIKE <span class="string">'sql_mode'</span></span><br><span class="line"><span class="number">2015</span><span class="number">-08</span><span class="number">-19</span> <span class="number">13</span>:<span class="number">45</span>:<span class="number">36</span>,<span class="number">237</span> INFO sqlalchemy.engine.base.Engine ()</span><br><span class="line"><span class="number">2015</span><span class="number">-08</span><span class="number">-19</span> <span class="number">13</span>:<span class="number">45</span>:<span class="number">36</span>,<span class="number">238</span> INFO sqlalchemy.engine.base.Engine SELECT DATABASE()</span><br><span class="line"><span class="number">2015</span><span class="number">-08</span><span class="number">-19</span> <span class="number">13</span>:<span class="number">45</span>:<span class="number">36</span>,<span class="number">238</span> INFO sqlalchemy.engine.base.Engine ()</span><br><span class="line"><span class="number">2015</span><span class="number">-08</span><span class="number">-19</span> <span class="number">13</span>:<span class="number">45</span>:<span class="number">36</span>,<span class="number">239</span> INFO sqlalchemy.engine.base.Engine show collation where `Charset` = <span class="string">'utf8'</span> <span class="keyword">and</span> `Collation` = <span class="string">'utf8_bin'</span></span><br><span class="line"><span class="number">2015</span><span class="number">-08</span><span class="number">-19</span> <span class="number">13</span>:<span class="number">45</span>:<span class="number">36</span>,<span class="number">239</span> INFO sqlalchemy.engine.base.Engine ()</span><br><span class="line"><span class="number">2015</span><span class="number">-08</span><span class="number">-19</span> <span class="number">13</span>:<span class="number">45</span>:<span class="number">36</span>,<span class="number">239</span> INFO sqlalchemy.engine.base.Engine SELECT CAST(<span class="string">'test plain returns'</span> AS CHAR(<span class="number">60</span>)) AS anon_1</span><br><span class="line"><span class="number">2015</span><span class="number">-08</span><span class="number">-19</span> <span class="number">13</span>:<span class="number">45</span>:<span class="number">36</span>,<span class="number">239</span> INFO sqlalchemy.engine.base.Engine ()</span><br><span class="line"><span class="number">2015</span><span class="number">-08</span><span class="number">-19</span> <span class="number">13</span>:<span class="number">45</span>:<span class="number">36</span>,<span class="number">240</span> INFO sqlalchemy.engine.base.Engine SELECT CAST(<span class="string">'test unicode returns'</span> AS CHAR(<span class="number">60</span>)) AS anon_1</span><br><span class="line"><span class="number">2015</span><span class="number">-08</span><span class="number">-19</span> <span class="number">13</span>:<span class="number">45</span>:<span class="number">36</span>,<span class="number">240</span> INFO sqlalchemy.engine.base.Engine ()</span><br><span class="line"><span class="number">2015</span><span class="number">-08</span><span class="number">-19</span> <span class="number">13</span>:<span class="number">45</span>:<span class="number">36</span>,<span class="number">240</span> INFO sqlalchemy.engine.base.Engine SELECT CAST(<span class="string">'test collated returns'</span> AS CHAR CHARACTER SET utf8) COLLATE utf8_bin AS anon_1</span><br><span class="line"><span class="number">2015</span><span class="number">-08</span><span class="number">-19</span> <span class="number">13</span>:<span class="number">45</span>:<span class="number">36</span>,<span class="number">240</span> INFO sqlalchemy.engine.base.Engine ()</span><br><span class="line"><span class="number">2015</span><span class="number">-08</span><span class="number">-19</span> <span class="number">13</span>:<span class="number">45</span>:<span class="number">36</span>,<span class="number">241</span> INFO sqlalchemy.engine.base.Engine BEGIN (implicit)</span><br><span class="line"><span class="number">2015</span><span class="number">-08</span><span class="number">-19</span> <span class="number">13</span>:<span class="number">45</span>:<span class="number">36</span>,<span class="number">242</span> INFO sqlalchemy.engine.base.Engine INSERT INTO users (name) VALUES (%s)</span><br><span class="line"><span class="number">2015</span><span class="number">-08</span><span class="number">-19</span> <span class="number">13</span>:<span class="number">45</span>:<span class="number">36</span>,<span class="number">242</span> INFO sqlalchemy.engine.base.Engine (<span class="string">'jack'</span>,)</span><br><span class="line"><span class="number">2015</span><span class="number">-08</span><span class="number">-19</span> <span class="number">13</span>:<span class="number">45</span>:<span class="number">36</span>,<span class="number">243</span> INFO sqlalchemy.engine.base.Engine INSERT INTO addresses (email_address, user_id) VALUES (%s, %s)</span><br><span class="line"><span class="number">2015</span><span class="number">-08</span><span class="number">-19</span> <span class="number">13</span>:<span class="number">45</span>:<span class="number">36</span>,<span class="number">243</span> INFO sqlalchemy.engine.base.Engine (<span class="string">'test@test.com'</span>, <span class="number">1L</span>)</span><br><span class="line"><span class="number">2015</span><span class="number">-08</span><span class="number">-19</span> <span class="number">13</span>:<span class="number">45</span>:<span class="number">36</span>,<span class="number">243</span> INFO sqlalchemy.engine.base.Engine INSERT INTO addresses (email_address, user_id) VALUES (%s, %s)</span><br><span class="line"><span class="number">2015</span><span class="number">-08</span><span class="number">-19</span> <span class="number">13</span>:<span class="number">45</span>:<span class="number">36</span>,<span class="number">243</span> INFO sqlalchemy.engine.base.Engine (<span class="string">'test1@test1.com'</span>, <span class="number">1L</span>)</span><br><span class="line"><span class="number">2015</span><span class="number">-08</span><span class="number">-19</span> <span class="number">13</span>:<span class="number">45</span>:<span class="number">36</span>,<span class="number">244</span> INFO sqlalchemy.engine.base.Engine COMMIT</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>此时，查看数据库，可以得到刚才插入的数据，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from users;</span><br><span class="line">+----+------+</span><br><span class="line">| id | name |</span><br><span class="line">+----+------+</span><br><span class="line">|  1 | jack |</span><br><span class="line">+----+------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from addresses;</span><br><span class="line">+----+-----------------+---------+</span><br><span class="line">| id | email_address   | user_id |</span><br><span class="line">+----+-----------------+---------+</span><br><span class="line">|  1 | test@test.com   |       1 |</span><br><span class="line">|  2 | test1@test1.com |       1 |</span><br><span class="line">+----+-----------------+---------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<h2 id="join查询"><a href="#join查询" class="headerlink" title="join查询"></a>join查询</h2><p>如果不使用join的话，可以直接联表查询，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; session.query(User.name, Address.email_address).filter(User.id==Address.user_id).filter(Address.email_address==&apos;test@test.com&apos;).all()</span><br><span class="line">2015-08-19 14:02:02,877 INFO sqlalchemy.engine.base.Engine SELECT users.name AS users_name, addresses.email_address AS addresses_email_address </span><br><span class="line">FROM users, addresses </span><br><span class="line">WHERE users.id = addresses.user_id AND addresses.email_address = %s</span><br><span class="line">2015-08-19 14:02:02,878 INFO sqlalchemy.engine.base.Engine (&apos;test@test.com&apos;,)</span><br><span class="line">[(&apos;jack&apos;, &apos;test@test.com&apos;)]</span><br></pre></td></tr></table></figure>
<p>在sqlalchemy中提供了Queqy.join()函数，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; session.query(User).join(Address).filter(Address.email_address==&apos;test@test.com&apos;).first()</span><br><span class="line">2015-08-19 14:06:56,624 INFO sqlalchemy.engine.base.Engine SELECT users.id AS users_id, users.name AS users_name </span><br><span class="line">FROM users INNER JOIN addresses ON users.id = addresses.user_id </span><br><span class="line">WHERE addresses.email_address = %s </span><br><span class="line"> LIMIT %s</span><br><span class="line">2015-08-19 14:06:56,624 INFO sqlalchemy.engine.base.Engine (&apos;test@test.com&apos;, 1)</span><br><span class="line">&lt;demo.User object at 0x7f9a74139a10&gt;</span><br><span class="line">&gt;&gt;&gt; session.query(User).join(Address).filter(Address.email_address==&apos;test@test.com&apos;).first().name</span><br><span class="line">2015-08-19 14:07:04,224 INFO sqlalchemy.engine.base.Engine SELECT users.id AS users_id, users.name AS users_name </span><br><span class="line">FROM users INNER JOIN addresses ON users.id = addresses.user_id </span><br><span class="line">WHERE addresses.email_address = %s </span><br><span class="line"> LIMIT %s</span><br><span class="line">2015-08-19 14:07:04,224 INFO sqlalchemy.engine.base.Engine (&apos;test@test.com&apos;, 1)</span><br><span class="line">&apos;jack&apos;</span><br><span class="line">&gt;&gt;&gt; session.query(User).join(Address).filter(Address.email_address==&apos;test@test.com&apos;).first().addresses</span><br><span class="line">2015-08-19 14:07:06,534 INFO sqlalchemy.engine.base.Engine SELECT users.id AS users_id, users.name AS users_name </span><br><span class="line">FROM users INNER JOIN addresses ON users.id = addresses.user_id </span><br><span class="line">WHERE addresses.email_address = %s </span><br><span class="line"> LIMIT %s</span><br><span class="line">2015-08-19 14:07:06,534 INFO sqlalchemy.engine.base.Engine (&apos;test@test.com&apos;, 1)</span><br><span class="line">2015-08-19 14:07:06,535 INFO sqlalchemy.engine.base.Engine SELECT addresses.id AS addresses_id, addresses.email_address AS addresses_email_address, addresses.user_id AS addresses_user_id </span><br><span class="line">FROM addresses </span><br><span class="line">WHERE %s = addresses.user_id ORDER BY addresses.id</span><br><span class="line">2015-08-19 14:07:06,535 INFO sqlalchemy.engine.base.Engine (1L,)</span><br><span class="line">[&lt;demo.Address object at 0x7f9a74139350&gt;, &lt;demo.Address object at 0x7f9a741390d0&gt;]</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>注意，上面的用法的前提是存在外键的情况下，如果没有外键，那么可以使用,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">query.join(Address, User.id==Address.user_id)    # explicit condition</span><br><span class="line">query.join(User.addresses)                       # specify relationship from left to right</span><br><span class="line">query.join(Address, User.addresses)              # same, with explicit target</span><br><span class="line">query.join(&apos;addresses&apos;)</span><br></pre></td></tr></table></figure>
<h2 id="表的别名"><a href="#表的别名" class="headerlink" title="表的别名"></a>表的别名</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from sqlalchemy.orm import aliased</span><br><span class="line">&gt;&gt;&gt; adalias1 = aliased(Address)</span><br></pre></td></tr></table></figure>
<h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><p>假设我们需要这样一个查询，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT users.*, adr_count.address_count FROM users LEFT OUTER JOIN</span><br><span class="line">    -&gt;     (SELECT user_id, count(*) AS address_count</span><br><span class="line">    -&gt;         FROM addresses GROUP BY user_id) AS adr_count</span><br><span class="line">    -&gt;     ON users.id=adr_count.user_id;</span><br><span class="line">+----+------+---------------+</span><br><span class="line">| id | name | address_count |</span><br><span class="line">+----+------+---------------+</span><br><span class="line">|  1 | jack |             2 |</span><br><span class="line">+----+------+---------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#　生成子句，等同于（select user_id ... group_by user_id）</span><br><span class="line">&gt;&gt;&gt; sbq = session.query(Address.user_id, func.count(&apos;*&apos;).label(&apos;address_count&apos;)).group_by(Address.user_id).subquery()</span><br><span class="line"></span><br><span class="line"># 联接子句，注意子句中需要使用c来调用字段内容</span><br><span class="line">&gt;&gt;&gt; session.query(User.name, sbq.c.address_count).outerjoin(sbq, User.id==sbq.c.user_id).all()</span><br><span class="line">2015-08-19 14:42:53,425 INFO sqlalchemy.engine.base.Engine SELECT users.name AS users_name, anon_1.address_count AS anon_1_address_count</span><br><span class="line">FROM users LEFT OUTER JOIN (SELECT addresses.user_id AS user_id, count(%s) AS address_count</span><br><span class="line">FROM addresses GROUP BY addresses.user_id) AS anon_1 ON users.id = anon_1.user_id</span><br><span class="line">2015-08-19 14:42:53,425 INFO sqlalchemy.engine.base.Engine (&apos;*&apos;,)</span><br><span class="line">[(&apos;jack&apos;, 2L)]</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<h2 id="包含contains"><a href="#包含contains" class="headerlink" title="包含contains"></a>包含contains</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">query.filter(User.addresses.contains(someaddress))</span><br></pre></td></tr></table></figure>
<h2 id="数据删除delete"><a href="#数据删除delete" class="headerlink" title="数据删除delete"></a>数据删除delete</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; session.delete(jack)</span><br><span class="line">&gt;&gt;&gt; session.query(User).filter_by(name=&apos;jack&apos;).count()</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<h2 id="外键配置"><a href="#外键配置" class="headerlink" title="外键配置"></a>外键配置</h2><p>在上面的例子中，删除了user－jack，但是address中的数据并没有删除。</p>
<p>cascade字段用来</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">addresses = relationship(&quot;Address&quot;, backref=&apos;user&apos;,</span><br><span class="line">    cascade=&quot;all, delete, delete-orphan&quot;)</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> db </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
            <tag> orm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[sqlalchemy(一)基本操作]]></title>
      <url>/2015/08/18/sqlalchemy/</url>
      <content type="html"><![CDATA[<p>sqlalchemy采用简单的Python语言，为高效和高性能的数据库访问设计，实现了完整的企业级持久模型。<br><a id="more"></a></p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ol>
<li>需要安装MySQLdb</li>
<li>pip install sqlalchemy</li>
</ol>
<p>安装完成后，执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;import sqlalchemy</span><br><span class="line">&gt;&gt;&gt;sqlalchemy.__version__</span><br></pre></td></tr></table></figure>
<h2 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h2><p>在sqlalchemy中，session用于创建程序与数据库之间的会话。所有对象的载入和保存都需要通过session对象。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> create_engine</span><br><span class="line"><span class="keyword">from</span> sqlalchemy.orm <span class="keyword">import</span> sessionmaker</span><br><span class="line"></span><br><span class="line">engine = create_engine(<span class="string">'mysql://user:passwd@ip:port/db'</span>, echo=<span class="keyword">True</span>)</span><br><span class="line">Session = sessionmaker(bind=engine)</span><br><span class="line"></span><br><span class="line">session = Session()</span><br><span class="line">session.execute(<span class="string">'show databases'</span>)</span><br></pre></td></tr></table></figure>
<p>其中，<code>echo</code>为<code>True</code>代表打开logging。</p>
<h2 id="创建一个映射"><a href="#创建一个映射" class="headerlink" title="创建一个映射"></a>创建一个映射</h2><p>一个映射对应着一个Python类，用来表示一个表的结构。下面创建一个person表，包括id和name两个字段。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sqlalchemy.ext.declarative <span class="keyword">import</span> declarative_base</span><br><span class="line"></span><br><span class="line">Base = declarative_base()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(Base)</span>:</span></span><br><span class="line">    __tablename__ = <span class="string">'person'</span></span><br><span class="line"></span><br><span class="line">    id   = Column(Integer, primary_key=<span class="keyword">True</span>)</span><br><span class="line">    name = Column(String(<span class="number">32</span>))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"&lt;Person(name='%s')&gt;"</span> % self.name</span><br></pre></td></tr></table></figure>
<h2 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建一个person对象</span></span><br><span class="line">person = Person(name=<span class="string">'jack'</span>)</span><br><span class="line"><span class="comment">#添加person对象，但是仍然没有commit到数据库</span></span><br><span class="line">session.add(person)</span><br><span class="line"><span class="comment">#commit操作</span></span><br><span class="line">session.commit()</span><br></pre></td></tr></table></figure>
<h3 id="如何获取id的？"><a href="#如何获取id的？" class="headerlink" title="如何获取id的？"></a>如何获取id的？</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>person = Person(name=<span class="string">'ilis'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>person.id <span class="comment">#此时还没有commit到mysql,因此无id</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>session.add(person)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>person.id <span class="comment">#同上</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>session.commit()</span><br><span class="line"><span class="number">2015</span><span class="number">-08</span><span class="number">-18</span> <span class="number">23</span>:<span class="number">08</span>:<span class="number">23</span>,<span class="number">530</span> INFO sqlalchemy.engine.base.Engine INSERT INTO person (name) VALUES (%s)</span><br><span class="line"><span class="number">2015</span><span class="number">-08</span><span class="number">-18</span> <span class="number">23</span>:<span class="number">08</span>:<span class="number">23</span>,<span class="number">531</span> INFO sqlalchemy.engine.base.Engine (<span class="string">'ilis'</span>,)</span><br><span class="line"><span class="number">2015</span><span class="number">-08</span><span class="number">-18</span> <span class="number">23</span>:<span class="number">08</span>:<span class="number">23</span>,<span class="number">532</span> INFO sqlalchemy.engine.base.Engine COMMIT</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>person.id <span class="comment">#commit后，可以获取该对象的id</span></span><br><span class="line"><span class="number">2015</span><span class="number">-08</span><span class="number">-18</span> <span class="number">23</span>:<span class="number">08</span>:<span class="number">27</span>,<span class="number">556</span> INFO sqlalchemy.engine.base.Engine BEGIN (implicit)</span><br><span class="line"><span class="number">2015</span><span class="number">-08</span><span class="number">-18</span> <span class="number">23</span>:<span class="number">08</span>:<span class="number">27</span>,<span class="number">557</span> INFO sqlalchemy.engine.base.Engine SELECT person.id AS person_id, person.name AS person_name</span><br><span class="line">FROM person</span><br><span class="line">WHERE person.id = %s</span><br><span class="line"><span class="number">2015</span><span class="number">-08</span><span class="number">-18</span> <span class="number">23</span>:<span class="number">08</span>:<span class="number">27</span>,<span class="number">557</span> INFO sqlalchemy.engine.base.Engine (<span class="number">5L</span>,)</span><br><span class="line"><span class="number">5L</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<h3 id="添加多个数据"><a href="#添加多个数据" class="headerlink" title="添加多个数据"></a>添加多个数据</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">session.add_all([</span><br><span class="line">    Person(name=<span class="string">'jack'</span>),</span><br><span class="line">    Person(name=<span class="string">'mike'</span>)</span><br><span class="line">])</span><br><span class="line">session.commit()</span><br></pre></td></tr></table></figure>
<h3 id="回滚"><a href="#回滚" class="headerlink" title="回滚"></a>回滚</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>person = Person(name=<span class="string">'test'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>session.add(person)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>session.query(person).filter(name==<span class="string">'test'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>session.query(Person).filter(Person.name==<span class="string">'test'</span>).all()</span><br><span class="line"><span class="number">2015</span><span class="number">-08</span><span class="number">-18</span> <span class="number">23</span>:<span class="number">13</span>:<span class="number">23</span>,<span class="number">265</span> INFO sqlalchemy.engine.base.Engine INSERT INTO person (name) VALUES (%s)</span><br><span class="line"><span class="number">2015</span><span class="number">-08</span><span class="number">-18</span> <span class="number">23</span>:<span class="number">13</span>:<span class="number">23</span>,<span class="number">265</span> INFO sqlalchemy.engine.base.Engine (<span class="string">'test'</span>,)</span><br><span class="line"><span class="number">2015</span><span class="number">-08</span><span class="number">-18</span> <span class="number">23</span>:<span class="number">13</span>:<span class="number">23</span>,<span class="number">267</span> INFO sqlalchemy.engine.base.Engine SELECT person.id AS person_id, person.name AS person_name</span><br><span class="line">FROM person</span><br><span class="line">WHERE person.name = %s</span><br><span class="line"><span class="number">2015</span><span class="number">-08</span><span class="number">-18</span> <span class="number">23</span>:<span class="number">13</span>:<span class="number">23</span>,<span class="number">267</span> INFO sqlalchemy.engine.base.Engine (<span class="string">'test'</span>,)</span><br><span class="line">[&lt;demo.Person object at <span class="number">0x7f4e37730510</span>&gt;]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>session.rollback()</span><br><span class="line"><span class="number">2015</span><span class="number">-08</span><span class="number">-18</span> <span class="number">23</span>:<span class="number">13</span>:<span class="number">37</span>,<span class="number">496</span> INFO sqlalchemy.engine.base.Engine ROLLBACK</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>session.query(Person).filter(Person.name==<span class="string">'test'</span>).all()</span><br><span class="line"><span class="number">2015</span><span class="number">-08</span><span class="number">-18</span> <span class="number">23</span>:<span class="number">13</span>:<span class="number">38</span>,<span class="number">690</span> INFO sqlalchemy.engine.base.Engine BEGIN (implicit)</span><br><span class="line"><span class="number">2015</span><span class="number">-08</span><span class="number">-18</span> <span class="number">23</span>:<span class="number">13</span>:<span class="number">38</span>,<span class="number">691</span> INFO sqlalchemy.engine.base.Engine SELECT person.id AS person_id, person.name AS person_name</span><br><span class="line">FROM person</span><br><span class="line">WHERE person.name = %s</span><br><span class="line"><span class="number">2015</span><span class="number">-08</span><span class="number">-18</span> <span class="number">23</span>:<span class="number">13</span>:<span class="number">38</span>,<span class="number">692</span> INFO sqlalchemy.engine.base.Engine (<span class="string">'test'</span>,)</span><br><span class="line">[]</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<h2 id="数据查询"><a href="#数据查询" class="headerlink" title="数据查询"></a>数据查询</h2><p>使用Session的query()方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#获取所有数据</span></span><br><span class="line">session.query(Person).all()</span><br><span class="line"></span><br><span class="line"><span class="comment">#获取某一列数据,类似于django的get,如果返回数据为多个则报错</span></span><br><span class="line">session.query(Person).filter(Person.name==<span class="string">'jack'</span>).one()</span><br><span class="line"></span><br><span class="line"><span class="comment">#获取返回数据的第一行</span></span><br><span class="line">session.query(Person).first()</span><br><span class="line"></span><br><span class="line"><span class="comment">#过滤数据</span></span><br><span class="line">session.query(Person.name).filter(Person.id&gt;<span class="number">1</span>).all()</span><br><span class="line"></span><br><span class="line"><span class="comment">#limit</span></span><br><span class="line">session.query(Person).all()[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#order by</span></span><br><span class="line">session.query(Person).ordre_by(-Person.id)</span><br><span class="line"></span><br><span class="line"><span class="comment">#equal/like/in</span></span><br><span class="line">query = session.query(Person)</span><br><span class="line">query.filter(Person.id==<span class="number">1</span>).all()</span><br><span class="line">query.filter(Person.id!=<span class="number">1</span>).all()</span><br><span class="line">query.filter(Person.name.like(<span class="string">'%ac%'</span>)).all()</span><br><span class="line">query.filter(Person.id.in_([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])).all()</span><br><span class="line">query.filter(~Person.id.in_([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])).all()</span><br><span class="line">query.filter(Person.name==<span class="keyword">None</span>).all()</span><br><span class="line"></span><br><span class="line"><span class="comment">#and or</span></span><br><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> and_</span><br><span class="line">query.filter(and_(Person.id==<span class="number">1</span>, Person.name==<span class="string">'jack'</span>)).all()</span><br><span class="line">query.filter(Person.id==<span class="number">1</span>, Person.name==<span class="string">'jack'</span>).all()</span><br><span class="line">query.filter(Person.id==<span class="number">1</span>).filter(Person.name==<span class="string">'jack'</span>).all()</span><br><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> or_</span><br><span class="line">query.filter(or_(Person.id==<span class="number">1</span>, Person.id==<span class="number">2</span>)).all()</span><br></pre></td></tr></table></figure>
<h3 id="使用text"><a href="#使用text" class="headerlink" title="使用text"></a>使用text</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> text</span><br><span class="line">query.filter(text(<span class="string">"id&gt;1"</span>)).all()</span><br><span class="line">query.filter(Person.id&gt;<span class="number">1</span>).all() <span class="comment">#同上</span></span><br><span class="line">query.filter(text(<span class="string">"id&gt;:id"</span>)).params(id=<span class="number">1</span>).all() <span class="comment">#使用:，params来传参</span></span><br><span class="line"></span><br><span class="line">query.from_statement(</span><br><span class="line">    text(<span class="string">"select * from person where name=:name"</span>)).\</span><br><span class="line">    params(name=<span class="string">'jack'</span>).all()</span><br></pre></td></tr></table></figure>
<h3 id="计数"><a href="#计数" class="headerlink" title="计数"></a>计数</h3><p>Query使用count()函数来实现查询计数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">query.filter(Person.id&gt;<span class="number">1</span>).count()</span><br></pre></td></tr></table></figure>
<p>group by的用法<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> func</span><br><span class="line">session.query(func.count(Person.name), Person.name),group_by(Person.name).all()</span><br></pre></td></tr></table></figure></p>
<p>实现count(*)来查询表内行数<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">session.query(func.count(<span class="string">'*'</span>)).select_from(Person).scalar()</span><br><span class="line">session.query(func.count(Person.id)).scalar()</span><br></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> db </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
            <tag> orm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[K-均值聚类算法]]></title>
      <url>/2015/07/13/kmeans/</url>
      <content type="html"><![CDATA[<p>聚类是一种无监督的学习算法，它将相似的数据归纳到同一簇中。K-均值是因为它可以按照k个不同的簇来分类，并且不同的簇中心采用簇中所含的均值计算而成。<br><a id="more"></a></p>
<h2 id="K-均值算法"><a href="#K-均值算法" class="headerlink" title="K-均值算法"></a>K-均值算法</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>K-均值是把数据集按照k个簇分类，其中k是用户给定的，其中每个簇是通过质心来计算簇的中心点。</p>
<p>主要步骤：</p>
<ul>
<li>随机确定k个初始点作为质心</li>
<li>对数据集中的每个数据点找到距离最近的簇</li>
<li>对于每一个簇，计算簇中所有点的均值并将均值作为质心</li>
<li>重复步骤2，直到任意一个点的簇分配结果不变<h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> matplotlib</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loadDataSet</span><span class="params">(fileName)</span>:</span>      <span class="comment">#general function to parse tab -delimited floats</span></span><br><span class="line">    dataMat = []                <span class="comment">#assume last column is target value</span></span><br><span class="line">    fr = open(fileName)</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> fr.readlines():</span><br><span class="line">        curLine = line.strip().split(<span class="string">'\t'</span>)</span><br><span class="line">        fltLine = map(float,curLine) <span class="comment">#map all elements to float()</span></span><br><span class="line">        dataMat.append(fltLine)</span><br><span class="line">    <span class="keyword">return</span> dataMat</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">distEclud</span><span class="params">(vecA, vecB)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> sqrt(sum(power(vecA - vecB, <span class="number">2</span>))) <span class="comment">#la.norm(vecA-vecB)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">randCent</span><span class="params">(dataSet, k)</span>:</span></span><br><span class="line">    n = shape(dataSet)[<span class="number">1</span>]</span><br><span class="line">    centroids = mat(zeros((k,n)))<span class="comment">#create centroid mat</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(n):<span class="comment">#create random cluster centers, within bounds of each dimension</span></span><br><span class="line">        minJ = min(dataSet[:,j]) </span><br><span class="line">        rangeJ = float(max(dataSet[:,j]) - minJ)</span><br><span class="line">        centroids[:,j] = mat(minJ + rangeJ * random.rand(k,<span class="number">1</span>))</span><br><span class="line">    <span class="keyword">return</span> centroids</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">kMeans</span><span class="params">(dataSet, k, distMeas=distEclud, createCent=randCent)</span>:</span></span><br><span class="line">    m = shape(dataSet)[<span class="number">0</span>]</span><br><span class="line">    clusterAssment = mat(zeros((m,<span class="number">2</span>)))<span class="comment">#create mat to assign data points </span></span><br><span class="line">                                      <span class="comment">#to a centroid, also holds SE of each point</span></span><br><span class="line">    centroids = createCent(dataSet, k)</span><br><span class="line">    clusterChanged = <span class="keyword">True</span></span><br><span class="line">    <span class="keyword">while</span> clusterChanged:</span><br><span class="line">        clusterChanged = <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):<span class="comment">#for each data point assign it to the closest centroid</span></span><br><span class="line">            minDist = inf; minIndex = <span class="number">-1</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(k):</span><br><span class="line">                distJI = distMeas(centroids[j,:],dataSet[i,:])</span><br><span class="line">                <span class="keyword">if</span> distJI &lt; minDist:</span><br><span class="line">                    minDist = distJI; minIndex = j</span><br><span class="line">            <span class="keyword">if</span> clusterAssment[i,<span class="number">0</span>] != minIndex: clusterChanged = <span class="keyword">True</span></span><br><span class="line">            clusterAssment[i,:] = minIndex,minDist**<span class="number">2</span></span><br><span class="line">        <span class="keyword">for</span> cent <span class="keyword">in</span> range(k):<span class="comment">#recalculate centroids</span></span><br><span class="line">            ptsInClust = dataSet[nonzero(clusterAssment[:,<span class="number">0</span>].A==cent)[<span class="number">0</span>]]<span class="comment">#get all the point in this cluster</span></span><br><span class="line">            centroids[cent,:] = mean(ptsInClust, axis=<span class="number">0</span>) <span class="comment">#assign centroid to mean </span></span><br><span class="line">            <span class="keyword">print</span> ptsInClust</span><br><span class="line">            <span class="keyword">print</span> mean(ptsInClust, axis=<span class="number">0</span>) </span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">return</span> centroids, clusterAssment</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">clusterClubs</span><span class="params">(numClust=<span class="number">5</span>)</span>:</span></span><br><span class="line">    datList = []</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> open(<span class="string">'places.txt'</span>).readlines():</span><br><span class="line">        lineArr = line.split(<span class="string">'\t'</span>)</span><br><span class="line">        datList.append([float(lineArr[<span class="number">4</span>]), float(lineArr[<span class="number">3</span>])])</span><br><span class="line">    datMat = mat(datList)</span><br><span class="line">    myCentroids, clustAssing = biKmeans(datMat, numClust, distMeas=distSLC)</span><br><span class="line">    fig = plt.figure()</span><br><span class="line">    rect=[<span class="number">0.1</span>,<span class="number">0.1</span>,<span class="number">0.8</span>,<span class="number">0.8</span>]</span><br><span class="line">    scatterMarkers=[<span class="string">'s'</span>, <span class="string">'o'</span>, <span class="string">'^'</span>, <span class="string">'8'</span>, <span class="string">'p'</span>, \</span><br><span class="line">                    <span class="string">'d'</span>, <span class="string">'v'</span>, <span class="string">'h'</span>, <span class="string">'&gt;'</span>, <span class="string">'&lt;'</span>]</span><br><span class="line">    axprops = dict(xticks=[], yticks=[])</span><br><span class="line">    ax0=fig.add_axes(rect, label=<span class="string">'ax0'</span>, **axprops)</span><br><span class="line">    imgP = plt.imread(<span class="string">'Portland.png'</span>)</span><br><span class="line">    ax0.imshow(imgP)</span><br><span class="line">    ax1=fig.add_axes(rect, label=<span class="string">'ax1'</span>, frameon=<span class="keyword">False</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(numClust):</span><br><span class="line">        ptsInCurrCluster = datMat[nonzero(clustAssing[:,<span class="number">0</span>].A==i)[<span class="number">0</span>],:]</span><br><span class="line">        markerStyle = scatterMarkers[i % len(scatterMarkers)]</span><br><span class="line">        ax1.scatter(ptsInCurrCluster[:,<span class="number">0</span>].flatten().A[<span class="number">0</span>], ptsInCurrCluster[:,<span class="number">1</span>].flatten().A[<span class="number">0</span>], marker=markerStyle, s=<span class="number">90</span>)</span><br><span class="line">    ax1.scatter(myCentroids[:,<span class="number">0</span>].flatten().A[<span class="number">0</span>], myCentroids[:,<span class="number">1</span>].flatten().A[<span class="number">0</span>], marker=<span class="string">'+'</span>, s=<span class="number">300</span>)</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure>
<h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p><img src="/images/kmeans-1.jpg" alt="K均值"></p>
<h3 id="算法收敛"><a href="#算法收敛" class="headerlink" title="算法收敛"></a>算法收敛</h3><p>设目标函数为</p>
<p>$$J(c, \mu) = \sum _{i=1}^m (x_i - \mu_{c_{(i)}})^2$$</p>
<p>Kmeans算法是将J调整到最小，每次调整质心，J值也会减小，同时c和$\mu$也会收敛。由于该函数是一个非凸函数，所以不能保证得到全局最优，智能确保局部最优解。</p>
<h2 id="二分K均值算法"><a href="#二分K均值算法" class="headerlink" title="二分K均值算法"></a>二分K均值算法</h2><p>为了克服K均值算法收敛于局部最小值的问题，提出了二分K均值算法。</p>
<h3 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h3><p>该算法首先将所有点作为一个簇，然后将该簇一分为2，之后选择其中一个簇继续进行划分，划分规则是按照最大化SSE（目标函数）的值。</p>
<p>主要步骤：</p>
<ul>
<li>将所有点看成一个簇</li>
<li>计算每一个簇的总误差</li>
<li>在给定的簇上进行K均值聚类，计算将簇一分为二的总误差</li>
<li>选择使得误差最小的那个簇进行再次划分</li>
<li>重复步骤2，直到簇的个数满足要求</li>
</ul>
<h3 id="具体实现-1"><a href="#具体实现-1" class="headerlink" title="具体实现"></a>具体实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">biKMeans</span><span class="params">(dataSet, k, distMeans=distEclud)</span>:</span></span><br><span class="line">    m, n = shape(dataSet)</span><br><span class="line">    clusterAssment = mat(zeros((m, <span class="number">2</span>))) <span class="comment"># init all data for index 0</span></span><br><span class="line">    centroid = mean(dataSet, axis=<span class="number">0</span>).tolist()</span><br><span class="line">    centList = [centroid]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">        clusterAssment[i, <span class="number">1</span>] = distMeans(mat(centroid), dataSet[i, :]) ** <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> len(centList) &lt; k:</span><br><span class="line">        lowestSSE = inf</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(centList)):</span><br><span class="line">            cluster = dataSet[nonzero(clusterAssment[:, <span class="number">0</span>].A == i)[<span class="number">0</span>], :] <span class="comment"># get the clust data of i</span></span><br><span class="line">            centroidMat, splitCluster = kMeans(cluster, <span class="number">2</span>, distMeans)</span><br><span class="line">            sseSplit = sum(splitCluster[:, <span class="number">1</span>]) <span class="comment">#all sse</span></span><br><span class="line">            sseNotSplit = sum(clusterAssment[nonzero(clusterAssment[:, <span class="number">0</span>].A != i)[<span class="number">0</span>], <span class="number">1</span>]) <span class="comment"># error sse</span></span><br><span class="line">            <span class="comment">#print sseSplit, sseNotSplit</span></span><br><span class="line">            <span class="keyword">if</span> sseSplit + sseNotSplit &lt; lowestSSE:</span><br><span class="line">                bestCentToSplit = i</span><br><span class="line">                bestNewCent = centroidMat</span><br><span class="line">                bestClust = splitCluster.copy()</span><br><span class="line">                lowerSEE = sseSplit + sseNotSplit</span><br><span class="line">        <span class="keyword">print</span> bestClust</span><br><span class="line">        bestClust[nonzero(bestClust[:, <span class="number">0</span>].A == <span class="number">1</span>)[<span class="number">0</span>], <span class="number">0</span>] = len(centList)</span><br><span class="line">        bestClust[nonzero(bestClust[:, <span class="number">0</span>].A == <span class="number">0</span>)[<span class="number">0</span>], <span class="number">0</span>] = bestCentToSplit</span><br><span class="line">        <span class="keyword">print</span> bestClust</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'the bestCentToSplit is: '</span>,bestCentToSplit</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'the len of bestClustAss is: '</span>, len(bestClust)</span><br><span class="line">        centList[bestCentToSplit] = bestNewCent[<span class="number">0</span>, :].tolist()[<span class="number">0</span>]</span><br><span class="line">        centList.append(bestNewCent[<span class="number">1</span>, :].tolist()[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">print</span> clusterAssment</span><br><span class="line">        clusterAssment[nonzero(clusterAssment[:, <span class="number">0</span>].A == bestCentToSplit)[<span class="number">0</span>], :] = bestClust</span><br><span class="line">        <span class="keyword">print</span> clusterAssment</span><br><span class="line">    <span class="keyword">return</span> mat(centList), clusterAssment</span><br></pre></td></tr></table></figure>
<h3 id="结果-1"><a href="#结果-1" class="headerlink" title="结果"></a>结果</h3><p><img src="/images/kmeans-2.jpg" alt="二分K均值"></p>
]]></content>
      
        <categories>
            
            <category> algorithm </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[回归]]></title>
      <url>/2015/06/25/regression/</url>
      <content type="html"><![CDATA[<p>回归的目的是预测数值型目标值。类似于$y = w_1 \cdot x_1 + w_2 \cdot x_2$，其中w称为回归系数，只要可以确定w，就可以通过输入x得到预测值。<br><a id="more"></a></p>
<h2 id="平方误差确定回归系数"><a href="#平方误差确定回归系数" class="headerlink" title="平方误差确定回归系数"></a>平方误差确定回归系数</h2><p>假设输入为x，输出为y，则平方误差可以表示为：</p>
<p>$$\sum_{i=1}^m (y_i - x_i^T w)^2)$$</p>
<p>为了让平方误差最小，令导数为0求得最佳回归系数，则</p>
<p>$$w = (X^T X)^{-1}X^Ty$$<br><!--more--><br>算法实现如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loadDataSet</span><span class="params">(fileName)</span>:</span></span><br><span class="line">    numFeat = len(open(fileName).readline().split(<span class="string">'\t'</span>)) - <span class="number">1</span> </span><br><span class="line">    dataMat = []; labelMat = []</span><br><span class="line">    fr = open(fileName)</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> fr.readlines():</span><br><span class="line">        lineArr =[]</span><br><span class="line">        curLine = line.strip().split(<span class="string">'\t'</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(numFeat):</span><br><span class="line">            lineArr.append(float(curLine[i]))</span><br><span class="line">        dataMat.append(lineArr)</span><br><span class="line">        labelMat.append(float(curLine[<span class="number">-1</span>]))</span><br><span class="line">    <span class="keyword">return</span> dataMat,labelMat</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">standRegres</span><span class="params">(xArr,yArr)</span>:</span></span><br><span class="line">    xMat = mat(xArr); yMat = mat(yArr).T</span><br><span class="line">    xTx = xMat.T*xMat</span><br><span class="line">    <span class="keyword">if</span> linalg.det(xTx) == <span class="number">0.0</span>:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"This matrix is singular, cannot do inverse"</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    ws = xTx.I * (xMat.T*yMat)</span><br><span class="line">    <span class="keyword">return</span> ws</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">regression1</span><span class="params">()</span>:</span></span><br><span class="line">    xArr, yArr = loadDataSet(<span class="string">"Ch08/ex0.txt"</span>)</span><br><span class="line">    xMat = mat(xArr)</span><br><span class="line">    yMat = mat(yArr)</span><br><span class="line">    ws = standRegres(xArr, yArr)</span><br><span class="line">    fig = plt.figure()</span><br><span class="line">    ax = fig.add_subplot(<span class="number">111</span>)</span><br><span class="line">    <span class="keyword">print</span> xMat[:, <span class="number">1</span>].flatten()</span><br><span class="line">    <span class="keyword">print</span> yMat.T[:, <span class="number">0</span>].flatten()</span><br><span class="line">    ax.scatter(xMat[:, <span class="number">1</span>].flatten(), yMat.T[:, <span class="number">0</span>].flatten().A[<span class="number">0</span>])</span><br><span class="line">    xCopy = xMat.copy() </span><br><span class="line">    xCopy.sort(<span class="number">0</span>)</span><br><span class="line">    yHat = xCopy * ws</span><br><span class="line">    ax.plot(xCopy[:, <span class="number">1</span>], yHat)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    regression1()</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/images/regression-1.jpg" alt="线性拟合"></p>
<h2 id="局部加权线性回归"><a href="#局部加权线性回归" class="headerlink" title="局部加权线性回归"></a>局部加权线性回归</h2><p>最简单的线性回归(locally weighted linear regression)具有最小均方误差的无偏估计，因此会出现欠拟合现象。通过局部加权线性回归就可以优化预测结果，局部加权的回归系数w如下：</p>
<p>$$w = (X^T WX)^{-1}X^TWy$$</p>
<p>其中，W是类似于“核”来对调整不同权值的权重。最常用的核是高斯核，如下：</p>
<p>$$w(i, j) = exp (\frac {|x^{(i)} - x|} {-2k^2})$$</p>
<p>其中，k会对权重产生影响，k越小，权重变化越快。</p>
<h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><p>通过核函数来调整权值的权重，可以让附近的点的赋予更高的权值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lwlr</span><span class="params">(testPoint,xArr,yArr,k=<span class="number">1.0</span>)</span>:</span></span><br><span class="line">    xMat = mat(xArr); yMat = mat(yArr).T</span><br><span class="line">    m = shape(xMat)[<span class="number">0</span>]</span><br><span class="line">    weights = mat(eye((m)))</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(m):                      <span class="comment">#next 2 lines create weights matrix</span></span><br><span class="line">        diffMat = testPoint - xMat[j,:]     <span class="comment">#</span></span><br><span class="line">        weights[j,j] = exp(diffMat*diffMat.T/(<span class="number">-2.0</span>*k**<span class="number">2</span>))</span><br><span class="line">    xTx = xMat.T * (weights * xMat)</span><br><span class="line">    <span class="keyword">if</span> linalg.det(xTx) == <span class="number">0.0</span>:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"This matrix is singular, cannot do inverse"</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    ws = xTx.I * (xMat.T * (weights * yMat))</span><br><span class="line">    <span class="keyword">return</span> testPoint * ws</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lwlrTest</span><span class="params">(testArr,xArr,yArr,k=<span class="number">1.0</span>)</span>:</span>  <span class="comment">#loops over all the data points and applies lwlr to each one</span></span><br><span class="line">    m = shape(testArr)[<span class="number">0</span>]</span><br><span class="line">    yHat = zeros(m)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">        yHat[i] = lwlr(testArr[i],xArr,yArr,k)</span><br><span class="line">    <span class="keyword">return</span> yHat</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">regression2</span><span class="params">()</span>:</span></span><br><span class="line">    xArr, yArr = loadDataSet(<span class="string">"Ch08/ex0.txt"</span>)</span><br><span class="line">    yhat = lwlrTest(xArr, xArr, yArr, <span class="number">0.01</span>)</span><br><span class="line">    fig = plt.figure()</span><br><span class="line">    ax = fig.add_subplot(<span class="number">111</span>)</span><br><span class="line">    xMat = mat(xArr)</span><br><span class="line">    srtInd = xMat[:, <span class="number">1</span>].argsort(<span class="number">0</span>)</span><br><span class="line">    xSort = xMat[srtInd][:, <span class="number">0</span>, :]</span><br><span class="line">    ax.plot(xSort[:, <span class="number">1</span>], yhat[srtInd])</span><br><span class="line">    ax.scatter(xMat[:, <span class="number">-1</span>].flatten(), mat(yArr).T.flatten().A[<span class="number">0</span>], s=<span class="number">2</span>, c=<span class="string">"red"</span>)</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/images/regression-2.jpg" alt="局部加权k=0.01"></p>
<p><img src="/images/regression-3.jpg" alt="局部加权k=0.003"></p>
<p>因此，k值如果越小会考虑太多的噪声影响，选择适合的k值可以得到最优的结果。</p>
<h2 id="岭回归-ridge-regression"><a href="#岭回归-ridge-regression" class="headerlink" title="岭回归 ridge regression"></a>岭回归 ridge regression</h2><h3 id="预测精度"><a href="#预测精度" class="headerlink" title="预测精度"></a>预测精度</h3><p>对于普通的线性回归模型，样本数量n和特征数量p会影响预测精度：</p>
<ul>
<li>$n \le p$，最小二乘回归会有较小的方差</li>
<li>$n \approx p$，容易产生过拟合</li>
<li>$n \ge p$，最小二乘回归得不到有意义的结果</li>
</ul>
<h3 id="岭回归算法"><a href="#岭回归算法" class="headerlink" title="岭回归算法"></a>岭回归算法</h3><p>岭回归是在平方误差的基础之上增加正则项，</p>
<p>$$\sum_{i=1}^n (y_i - \sum_{j=0}^p w_i x_{ij})^2 + \lambda \sum_{j=0}^p w_j^2, \quad \lambda &gt; 0$$</p>
<p>通过确定$\lambda$的值可以使方差和偏差之间达到一定的平衡。</p>
<p>从而对w求导，得</p>
<p>$$2 X^T (Y - XW) - 2 \lambda W$$</p>
<p>令导数为0，则</p>
<p>$$w = (X^TX + \lambda I)^{-1}X^TY$$</p>
]]></content>
      
        <categories>
            
            <category> algorithm </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[logistic回归]]></title>
      <url>/2015/06/24/logistic/</url>
      <content type="html"><![CDATA[<p>学习logistic回归。<br><a id="more"></a></p>
<blockquote>
<p>回归就是对已知公式的未知参数进行估计。比如已知公式是$y = a*x + b$，未知参数是a和b，利用多真实的(x,y)训练数据对a和b的取值去自动估计。估计的方法是在给定训练样本点和已知的公式后，对于一个或多个未知参数，机器会自动枚举参数的所有可能取值，直到找到那个最符合样本点分布的参数（或参数组合）。</p>
</blockquote>
<h2 id="logistic分布"><a href="#logistic分布" class="headerlink" title="logistic分布"></a>logistic分布</h2><p>设X是连续随机变量，X服从logistic分布是指X具有下列分布函数和密度函数：</p>
<p>$$F(x)=P(x \le x)=\frac 1 {1+e^{-(x-\mu)/\gamma}}\\<br>f(x)=F^{‘}(x)=\frac {e^{-(x-\mu)/\gamma}} {\gamma(1+e^{-(x-\mu)/\gamma})^2}$$</p>
<p>其中，$\mu$为位置参数，$\gamma$为形状参数。</p>
<p>$f(x)$与$F(x)$图像如下，其中分布函数是以$(\mu, \frac 1 2)$为中心对阵，$\gamma$越小曲线变化越快。</p>
<p><img src="/images/logistic-1.jpg" alt="logistic分布的密度函数和分布函数"></p>
<h2 id="logistic回归模型"><a href="#logistic回归模型" class="headerlink" title="logistic回归模型"></a>logistic回归模型</h2><p>二项logistic回归模型如下：</p>
<p>$$P(Y=1|x)=\frac {exp(w \cdot x + b)} {1 + exp(w \cdot x + b)} \\<br>P(Y=0|x)=\frac {1} {1 + exp(w \cdot x + b)}$$</p>
<p>其中，$x \in R^n$是输入，$Y \in {0,1}$是输出，w称为权值向量，b称为偏置，$w \cdot x$为w和x的内积。</p>
<h3 id="参数估计"><a href="#参数估计" class="headerlink" title="参数估计"></a>参数估计</h3><p>假设：</p>
<p>$$P(Y=1|x)=\pi (x), \quad P(Y=0|x)=1-\pi (x)$$</p>
<p>则似然函数为:</p>
<p>$$\prod_{i=1}^N [\pi (x_i)]^{y_i} [1 - \pi(x_i)]^{1-y_i}<br>$$</p>
<p>求对数似然函数：</p>
<p>$$L(w) = \sum_{i=1}^N [y_i \log{\pi(x_i)} + (1-y_i) \log{(1 - \pi(x_i)})]\\<br>=\sum_{i=1}^N [y_i \log{\frac {\pi (x_i)} {1 - \pi(x_i)}} + \log{(1 - \pi(x_i)})]$$</p>
<p>从而对$L(w)$求极大值，得到$w$的估计值。</p>
<p>求极值的方法可以是梯度下降法，梯度上升法等。</p>
<h2 id="梯度上升确定回归系数"><a href="#梯度上升确定回归系数" class="headerlink" title="梯度上升确定回归系数"></a>梯度上升确定回归系数</h2><p>logistic回归的sigmoid函数：</p>
<p>$$\sigma (z) = \frac 1 {1 + e^{-z}}$$</p>
<p>假设logstic的函数为:</p>
<p>$$y = w_0 + w_1 x_1 + w_2 x_2 + … + w_n x_n$$</p>
<p>可简写为:</p>
<p>$$y = w_0 + w^T x$$</p>
<p>梯度上升算法是按照上升最快的方向不断移动，每次都增加$\alpha \nabla_w f(w)$，</p>
<p>$$w = w + \alpha \nabla_w f(w) $$</p>
<p>其中，$\nabla_w f(w)$为函数导数，$\alpha$为增长的步长。</p>
<h3 id="训练算法"><a href="#训练算法" class="headerlink" title="训练算法"></a>训练算法</h3><p>本算法的主要思想根据logistic回归的sigmoid函数来将函数值映射到有限的空间内，sigmoid函数的取值范围是0~1，从而可以把数据按照0和1分为两类。在算法中，首先要初始化所有的w权值为1，每次计算一次误差并根据误差调整w权值的大小。</p>
<ul>
<li>每个回归系数都初始化为1</li>
<li>重复N次<ul>
<li>计算整个数据集合的梯度</li>
<li>使用$\alpha \cdot \nabla f(x)$来更新w向量</li>
<li>返回回归系数</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># encoding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> numpy</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sigmoid</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.0</span> / (<span class="number">1</span> + numpy.exp(-x))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loadData</span><span class="params">()</span>:</span></span><br><span class="line">    dataMat = []</span><br><span class="line">    laberMat = []</span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">"test.txt"</span>, <span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> f.readlines():</span><br><span class="line">            arry = line.strip().split()</span><br><span class="line">            dataMat.append([<span class="number">1.0</span>, float(arry[<span class="number">0</span>]), float(arry[<span class="number">1</span>])])</span><br><span class="line">            laberMat.append(float(arry[<span class="number">2</span>]))</span><br><span class="line">    <span class="keyword">return</span> numpy.mat(dataMat), numpy.mat(laberMat).transpose()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gradAscent</span><span class="params">(dataMat, laberMat, alpha=<span class="number">0.001</span>, maxCycle=<span class="number">500</span>)</span>:</span></span><br><span class="line">    <span class="string">"""general gradscent"""</span></span><br><span class="line">    start_time = time.time()</span><br><span class="line">    m, n = numpy.shape(dataMat)</span><br><span class="line">    weights = numpy.ones((n, <span class="number">1</span>)) </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(maxCycle):</span><br><span class="line">        h = sigmoid(dataMat * weights)</span><br><span class="line">        error = laberMat - h </span><br><span class="line">        weights += alpha * dataMat.transpose() * error</span><br><span class="line">    duration = time.time() - start_time</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"duration of time:"</span>, duration</span><br><span class="line">    <span class="keyword">return</span> weights</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">stocGradAscent</span><span class="params">(dataMat, laberMat, alpha=<span class="number">0.01</span>)</span>:</span></span><br><span class="line">    start_time = time.time()</span><br><span class="line">    m, n = numpy.shape(dataMat)</span><br><span class="line">    weights = numpy.ones((n, <span class="number">1</span>)) </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">        h = sigmoid(dataMat[i] * weights)</span><br><span class="line">        error = laberMat[i] - h </span><br><span class="line">        weights += alpha * dataMat[i].transpose() * error</span><br><span class="line">    duration = time.time() - start_time</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"duration of time:"</span>, duration</span><br><span class="line">    <span class="keyword">return</span> weights</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">betterStocGradAscent</span><span class="params">(dataMat, laberMat, alpha=<span class="number">0.01</span>, numIter=<span class="number">150</span>)</span>:</span></span><br><span class="line">    <span class="string">"""better one, use a dynamic alpha"""</span></span><br><span class="line">    start_time = time.time()</span><br><span class="line">    m, n = numpy.shape(dataMat)</span><br><span class="line">    weights = numpy.ones((n, <span class="number">1</span>)) </span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(numIter):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            alpha = <span class="number">4</span> / (<span class="number">1</span> + j + i) + <span class="number">0.01</span></span><br><span class="line">            h = sigmoid(dataMat[i] * weights)</span><br><span class="line">            error = laberMat[i] - h </span><br><span class="line">            weights += alpha * dataMat[i].transpose() * error</span><br><span class="line">    duration = time.time() - start_time</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"duration of time:"</span>, duration</span><br><span class="line">    <span class="keyword">return</span> weights</span><br><span class="line">    start_time = time.time()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(dataMat, laberMat, weights)</span>:</span></span><br><span class="line">    m, n = numpy.shape(dataMat) </span><br><span class="line">    min_x = min(dataMat[:, <span class="number">1</span>])[<span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">    max_x = max(dataMat[:, <span class="number">1</span>])[<span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">    xcoord1 = []; ycoord1 = []</span><br><span class="line">    xcoord2 = []; ycoord2 = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">        <span class="keyword">if</span> int(laberMat[i, <span class="number">0</span>]) == <span class="number">0</span>:</span><br><span class="line">            xcoord1.append(dataMat[i, <span class="number">1</span>]); ycoord1.append(dataMat[i, <span class="number">2</span>]) </span><br><span class="line">        <span class="keyword">elif</span> int(laberMat[i, <span class="number">0</span>]) == <span class="number">1</span>:</span><br><span class="line">            xcoord2.append(dataMat[i, <span class="number">1</span>]); ycoord2.append(dataMat[i, <span class="number">2</span>]) </span><br><span class="line">    fig = plt.figure()</span><br><span class="line">    ax = fig.add_subplot(<span class="number">111</span>)</span><br><span class="line">    ax.scatter(xcoord1, ycoord1, s=<span class="number">30</span>, c=<span class="string">"red"</span>, marker=<span class="string">"s"</span>)</span><br><span class="line">    ax.scatter(xcoord2, ycoord2, s=<span class="number">30</span>, c=<span class="string">"green"</span>)</span><br><span class="line">    x = numpy.arange(min_x, max_x, <span class="number">0.1</span>)</span><br><span class="line">    y = (-weights[<span class="number">0</span>] - weights[<span class="number">1</span>]*x) / weights[<span class="number">2</span>]</span><br><span class="line">    ax.plot(x, y)</span><br><span class="line">    plt.xlabel(<span class="string">"x1"</span>); plt.ylabel(<span class="string">"x2"</span>)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    dataMat, laberMat = loadData()</span><br><span class="line">    <span class="comment">#weights = gradAscent(dataMat, laberMat, maxCycle=500)</span></span><br><span class="line">    <span class="comment">#weights = stocGradAscent(dataMat, laberMat)</span></span><br><span class="line">    weights = betterStocGradAscent(dataMat, laberMat, numIter=<span class="number">80</span>)</span><br><span class="line">    show(dataMat, laberMat, weights)</span><br></pre></td></tr></table></figure>
<p>未优化的程序结果如下，<br><img src="/images/logistic-2.jpg" alt="普通结果"></p>
<p>随机梯度上升算法（降低了迭代的次数，算法较快，但结果不够准确）结果如下，<br><img src="/images/logistic-3.jpg" alt="随机梯度上升算法结果"></p>
<p>对$\alpha$进行优化，动态调整步长（同样降低了迭代次数，但是由于代码采用动态调整alpha，提高了结果的准确性），结果如下<br><img src="/images/logistic-4.jpg" alt="alpha优化结果"></p>
]]></content>
      
        <categories>
            
            <category> algorithm </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[SVM-非线性支持向量机及SMO算法]]></title>
      <url>/2015/06/18/ml-svm-2/</url>
      <content type="html"><![CDATA[<p>学习支持向量机。<br><a id="more"></a></p>
<h2 id="线性不可分情况"><a href="#线性不可分情况" class="headerlink" title="线性不可分情况"></a>线性不可分情况</h2><p>线性可分问题的支持向量机学习方法，对线性不可分训练数据是不适用的，为了满足函数间隔大于1的约束条件，可以对每个样本$(x_i, y_i)$引进一个松弛变量$\xi_i \ge 0$，使函数间隔加上松弛变量大于等于1,，</p>
<p>$$y_i (w \cdot x_i + b) \ge 1 - \xi_i$$</p>
<p>目标函数变为</p>
<p>$$\frac 1 2 {||w||^2} +  C \sum_{j=1}^N \xi_i$$</p>
<p>其中，C&gt;0称为惩罚参数，值越大对误分类的惩罚越大，值越小对误分类的惩罚越小。</p>
<p>因此，最小化目标函数也就是使$\frac 1 2 {||w||^2}$尽量小（间隔尽量大），同时使误分类点的个数尽量小。</p>
<p>线性不可分的线性支持向量机的学习问题变成如下凸二次规划问题：</p>
<p>$$ \min_{w,b,\xi}\frac 1 2 {||w||}^2 + C \sum_{i=1}^N \xi_i \\<br>s.t. \quad y_i(w \cdot x_i + b) \ge 1 -  \xi_i, \quad i=1,2,…,N, \xi_i \ge 0, i=1,2,…,N$$</p>
<h3 id="线性支持向量学习算法"><a href="#线性支持向量学习算法" class="headerlink" title="线性支持向量学习算法"></a>线性支持向量学习算法</h3><ul>
<li>选择惩罚参数C&gt;0，构造并求解凸二次规划问题</li>
</ul>
<p>$$ \min_\alpha \frac 1 2 \sum_{i=1}^N \sum_{j=1}^N \alpha_i \alpha_j y_i y_j (x_i \cdot x_j) - \sum_{i=1}^N \alpha_i\\<br>s.t. \quad \sum_{i=1}^N \alpha_i y_i = 0 \\<br>0 \le \alpha_i \le C, i=1,2,…,N$$</p>
<p>求得最优解$\alpha^*=(\alpha_1^*, \alpha_2^*, … , \alpha_N^*)^T$</p>
<ul>
<li>计算$w^*=\sum_{i=1}^N \alpha_i^* y_i x_i$</li>
</ul>
<p>选择$\alpha^*$的一个分量$\alpha_j^*$适合条件$0&lt;\alpha_j^*&lt;C$，计算</p>
<p>$$b^*=y_i - \sum_{i=1}^N y_i \alpha_i^*(x_i \cdot x_j)$$</p>
<ul>
<li>求得分离超平面</li>
</ul>
<p>$$w^* \cdot x + b^* = 0$$</p>
<p>分类决策函数：</p>
<p>$$f(x) = sign(w^* \cdot x + b^*)$$</p>
<h2 id="核函数"><a href="#核函数" class="headerlink" title="核函数"></a>核函数</h2><p>用线性分类方法求解非线性分类问题分为两步：首先使用一个变换将原空间的数据映射到新空间；然后在新空间里用线性分类学习方法从训练数据中学习分类模型。</p>
<p><img src="/images/ml-svm-2-1.jpg" alt="核函数的空间转换"></p>
<p>核技巧应用在支持向量机的基本思想：通过一个非线性变换将输入空间（欧式空间$R^n$或离散集合）对应于一个特征空间（希尔伯特空间H），使得在输入空间$R^n$中的超曲面模型对应于特征空间H中的超平面模型（支持向量机）。</p>
<h2 id="非线性支持向量分类机"><a href="#非线性支持向量分类机" class="headerlink" title="非线性支持向量分类机"></a>非线性支持向量分类机</h2><h3 id="非线性支持向量机"><a href="#非线性支持向量机" class="headerlink" title="非线性支持向量机"></a>非线性支持向量机</h3><p>从非线性分类训练集，通过核函数与间隔最大化或凸二次规划，学习得到的分类决策函数：</p>
<p>$$f(x)=sign(\sum_{i=1}^N \alpha_i^*y_i K(x,x_i) + b^*)$$</p>
<p>称为非线性支持向量，$K(x,z)$是正定核函数。</p>
<h3 id="学习算法"><a href="#学习算法" class="headerlink" title="学习算法"></a>学习算法</h3><ul>
<li>选择适当的核函数$K(x,z)$和适当的参数C，构造并求解最优化问题</li>
</ul>
<p>$$\min_\alpha \frac 1 2 \sum_{i=1}^N \sum_{j=1}^N \alpha_i \alpha_j y_i y_j K(x_i, x_j) - \sum_{i=1}^N \alpha_i\\<br>s.t. \quad \sum_{i=1}^N \alpha_i y_i = 0, 0&lt;\alpha_i&lt;C,i=1,2,…,N$$</p>
<p>求解最优解$\alpha^*=(\alpha_1^*, \alpha_2^*,…,\alpha_N^*)$</p>
<ul>
<li>选择$\alpha^*$的第一个正分量$0&lt;\alpha_j^*&lt;C$，计算</li>
</ul>
<p>$$b^*=y_i - \sum_{i=1}^N \alpha_i^* y_i K(x_i \cdot x_j)$$</p>
<ul>
<li>构造决策函数</li>
</ul>
<p>$$f(x)=sign(\sum_{i=1}^N \alpha_i^* y_i K(x \cdot x_i) + b^*)$$</p>
<h2 id="序列最小优化算法"><a href="#序列最小优化算法" class="headerlink" title="序列最小优化算法"></a>序列最小优化算法</h2><blockquote>
<p>SMO算法是一种启发式算法。如果所有变量都满足KKT条件，那么这个最优化问题就解决了（KKT问题是该最优化问题的充要条件），否则，选择两个变量，固定其他变量，针对这两个变量构造二次规划问题。该方法会使原始二次规划问题的目标函数变小，不断分解自问题并对子问题求解进而达到求解原问题的目的。</p>
</blockquote>
<p>由于</p>
<p>$$\sum_{i=1}^N \alpha_i y_i = 0$$</p>
<p>所以</p>
<p>$$\alpha_i = - \frac 1 {y_i} \sum_{i=2}^N \alpha_i y_i$$</p>
<h3 id="两个变量的二次规划求解"><a href="#两个变量的二次规划求解" class="headerlink" title="两个变量的二次规划求解"></a>两个变量的二次规划求解</h3><p>假设选择两个变量$\alpha_1，\alpha_2$，</p>
<p>$$\min_{\alpha_1\alpha_2} \quad = \frac 1 2 K_{11} \alpha_1^2 + \frac 1 2 K_{22} \alpha_2^2  + y_1 y_2 K_{12} \alpha_1 \alpha_2 \\<br>\quad (\alpha_1 + \alpha_2) + y_1 \alpha_1 \sum_{i=3}^N y_i \alpha_i K_{i1} + y_2\alpha_2\sum_{i=3}^N y_i \alpha_i K_{12} \\<br>s.t. \quad \alpha_1 y_1 + \alpha_2 y_2 = - \sum_{i=3}^N y_i \alpha_i = \xi \\<br>0 \le \alpha_i \le C, i=1,2$$</p>
<p>由于只有两个变量$(\alpha_i,\alpha_j)$，因此根据两变量的符号情况约束条件可用二位空间中的图表示（参考$\alpha_1 y_1 + \alpha_2 y_2 = \xi(常数)$），</p>
<p><img src="/images/ml-svm-2-2.jpg" alt="二变量优化问题"></p>
<p>L和H是$\alpha$取值的最小和最大值，如果$y_i != y_j$，则</p>
<p>$$L=\max(0,\alpha_2 - \alpha_1), H=\min(C,C+\alpha_2-\alpha_1)$$</p>
<p>如果$y_i = y_j$，则</p>
<p>$$L=\max(0,\alpha_2 + \alpha_1 + C), H=\min(C,\alpha_2+\alpha_1)$$</p>
<p>令</p>
<p>$$g(x) = \sum_{i=1}^N \alpha_i y_i K(x_i, x) + b$$</p>
<p>得到误差值：</p>
<p>$$E_i = g(x_i) - y_i = ( \sum_{i=1}^N \alpha_i y_i K(x_i, x) + b) - y_i$, \quad i = 1,2$$</p>
<p>此最优问题的解是：</p>
<p>$$\alpha_2^{new} = \alpha_2^{old} + y_2 \frac {(E_1 - E_2)} \eta$$</p>
<p>其中，</p>
<p>$$\eta = K_{11} + K_{22} - 2K_{12} = {||\phi(x_1) - \phi(x_2)||}^2$$</p>
<p>$\phi(x)$为输入空间到特征空间的映射，经过剪辑后是</p>
<p>$$f(n)=\begin{cases}<br>H,\quad \alpha_2^{new} &gt; H \\<br>\alpha_2^{new}, \quad L \le \alpha_2^{new} \le H \\<br>L,\quad \alpha_2^{new} &lt; L \end{cases}$$</p>
<p>则$\alpha_1^{new}$为</p>
<p>$$\alpha_1^{new} = \alpha_1^{old} + y_1 y_2 (\alpha_2^{old} - \alpha_2^{new})$$</p>
<h3 id="变量的选择方法"><a href="#变量的选择方法" class="headerlink" title="变量的选择方法"></a>变量的选择方法</h3><p>SMO算法在每个子问题中选择两个变量优化，其中至少一个变量是违反KKT条件的。</p>
<p>1.第1个变量的选择</p>
<p>SMO算法在外层循环中选取违反KKT条件最严重的样本点，并将其对应的变量作为第1个变量，KKT条件如下</p>
<p>$$\alpha_i = 0 &lt;=&gt; y_i g(x_i) \ge 1 \\<br>0 &lt; \alpha_i &lt; C &lt;=&gt; y_i g(x_i)=1 \\<br>\alpha_i = C &lt;=&gt; y_i g(x_i) \le 1$$</p>
<p>其中，$g(x_i) = \sum_{j=1}^N \alpha_j y_j K(x_i,x_j)+b$。</p>
<p>该检验在$\epsilon$范围内进行的，在校验过程中，外层循环首先遍历所有满足条件$0&lt;\alpha_i&lt;C$的样本点，即在间隔边界上的支持向量点，检验它们是否满足KKT条件。如果这些样本点都满足KKT条件，那么遍历整个训练集，检验它们是否满足KKT条件。</p>
<p>2.第2个变量的选择</p>
<p>SMO算法在内层循环，假设在外层循环中已经找到第一个变量$\alpha_1$，现在要在内层循环中找到第2个变量$\alpha_2$，第2个变量选择的标准是希望能使$\alpha_2$有足够的变化。根据上一节可知，$\alpha_2^{new}$是依赖$|E_1 - E_2|$的，为了加快计算速度，最简单的做法是选择$|E_1 - E_2|$最大的（如果$E_1$为负值，则选择最大的$E_i$作为$E_2$，否则选择最小的$E_i$为$E_2$，需要保存所有的$E_i$）。</p>
<p>3.计算阈值b和差值$E_i$</p>
<p>在每次完成两个变量优化后，都要重新计算阈值b。</p>
<p>由KKT条件得</p>
<p>$$\sum_{i=1}^N \alpha_i y_i K_{i1} + b = y_i$$</p>
<p>从而</p>
<p>$$b_1^{new} = y_1 - \sum_{i=3}^N \alpha_i y_i K_{i1} - \alpha_1^{new} y_1 K_{11} - \alpha_2^{new} y_2 K_{21}$$</p>
<p>由于$E_i = g(x_i) - y_i = ( \sum_{i=1}^N \alpha_i y_i K(x_i, x) + b) - y_i$, \quad i = 1,2$，则</p>
<p>$$E_1 = g(x_1) - y_1 = \sum_{i=3}^N \alpha_i y_i K_{i1} + \alpha_1^{old} y_1 K_{11} + \alpha_2^{old} y_2 K_{21} + b^{old} - y_1$$</p>
<p>将上式中的$y_i -  \sum_{i=3}^N \alpha_i y_i K_{i1} $代入$b_1^{new}$的公式中，得到</p>
<p>$$b_1^{new} = -E_1 - y_1 K_{11} (\alpha_1^{new} - \alpha_1^{old} ) - y_2 K_{21} (\alpha_2^{new} - \alpha_2^{old} ) + b^old$$</p>
<p>对于b的取值：</p>
<p>$$b^{new}=\begin{cases}b_1^{new}=b_2^{new}, \quad 0 &lt; \alpha_i^{new} &lt; C, i =1,2 \\<br>\frac {b_1^{new} + b_2^{new}} 2,\quad \alpha_i^{new} == 0 or C，满足KKT条件\end{cases}$$</p>
]]></content>
      
        <categories>
            
            <category> algorithm </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[SVM-线性可分支持向量机]]></title>
      <url>/2015/06/17/ml-svm-1/</url>
      <content type="html"><![CDATA[<p>学习支持向量机。<br><a id="more"></a></p>
<h2 id="函数间隔和几何间隔"><a href="#函数间隔和几何间隔" class="headerlink" title="函数间隔和几何间隔"></a>函数间隔和几何间隔</h2><p>给定线性可分训练数据集，通过间隔最大化或等价地求解相应的凸二次规划问题学习得到的分离超平面为</p>
<p>$$w^* \cdot x+b^* =0 $$</p>
<p>以及相应的分类决策函数</p>
<p>$$f(x) = sign (w^* \cdot x + b^*)$$</p>
<p>称为线性可分支持向量机。</p>
<p>对于给定训练集合T和超平面$(w,b)$，定义超平面$(w,b)$关于样本点$(x _i,y_i)$的函数间隔为</p>
<p>$$\hat\gamma_i = y_i(w \cdot x_i + b)$$</p>
<p>定义超平面$(w,b)$关于训练数据集T的函数间隔为超平面$(w,b)$关于T中所有样本点$(x_i,y_i)$的函数间隔之最小值，</p>
<p>$$\hat\gamma = \min_{i=1,…,N}\hat\gamma_i$$</p>
<p>对于给定的训练数据集和超平面$(w,b)$，定义超平面$(w,b)关于$样本$(x_i,y_i)$的几何间隔为</p>
<p>$$\hat\gamma_i = y_i(\frac w{||w||} \cdot x_i + \frac b{||w||})$$</p>
<p>定义超平面$(w,b)$关于训练数据集T的几何间隔为超平面$(w,b)$关于T中所有样本点$(x_i,y_i)$的几何间隔之最小值</p>
<p>$$\gamma = \min_{i=1,…,N}\gamma_i$$</p>
<p>从而得到几何间隔和函数间隔的关系:</p>
<p>$$\gamma = \frac{\hat\gamma_i}{||w||}$$</p>
<h2 id="间隔最大化"><a href="#间隔最大化" class="headerlink" title="间隔最大化"></a>间隔最大化</h2><p>对数据集合找到几何间隔最大的超平面意味着以充分大的确信度来对训练数据进行分类。</p>
<p>最大化超平面可表示为：</p>
<p>$$\max_{w,b} \quad {\gamma}\\<br>s.t.\quad  y_i(\frac w{||w||} \cdot x_i + \frac b{||w||}) \ge \gamma,\quad i=1,…,N$$</p>
<p>即最大化超平面$(w,b)$关于训练结合的间隔$\gamma$，约束条件表示的超平面$(w,b)$关于每个训练样本点的几何间隔至少为$\gamma$。</p>
<p>而函数间隔对于上述公式并没有影响，假设按比例改变为$\lambda w$和$\lambda b$，那么函数间隔改变为$\lambda \hat\gamma$</p>
<p>改变为相应的函数距离，如下</p>
<p>$$\max_{w,b} \quad \frac{\hat\gamma}{||w||} \\<br>s.t.\quad  y_i(w \cdot x_i +  b) \ge \hat\gamma,\quad i=1,…,N$$</p>
<p>由于分母和分子同时拥有$\lambda$，因此成比例改变并不会对函数间隔产生影响，从而对目标函数的优化也没有影响。</p>
<p>令$\hat\gamma$=1，代入上式，最大化$\frac1{||w||}$等价于最小化$\frac12||w||$，从而得到线性可分支持向量机学习的最优化问题</p>
<p>$$min_{w,b}\quad \frac12{||w||}^2 \\<br>s.t.\quad y_i(w\cdot x_i + b) - 1 \ge 0, \quad i=1,2,…,N$$</p>
<p>这是一个凸二次规划问题。</p>
<h2 id="支持向量"><a href="#支持向量" class="headerlink" title="支持向量"></a>支持向量</h2><p>在线性可分的情况下，训练数据集的样本点中与分离超平面距离最近的样本点的实例称为支持向量（support vector），即</p>
<p>$$y_i(w\cdot x_i+b) =1$$</p>
<p>对于y=+1的正例来说，支持向量在超平面</p>
<p>$$H_1:w\cdot x + b= 1$$</p>
<p>对于y=-1的负例来说，支持向量在超平面</p>
<p>$$H_2:w\cdot x + b = -1$$</p>
<p>如图中， H1和H2平行，之间形成一条长带，其宽度为$\frac 2 {||w||}$。在决定分离超平面时只有支持向量起作用，而其他实例点并不起作用，如果移动支持向量改变所求的解，但是如果在间隔边界（H1和H2）以外移动其他实例点，解都不会发生改变。</p>
<p><img src="/images/ml-svm-1-1.jpg" alt="support_vector"></p>
<h2 id="对偶算法"><a href="#对偶算法" class="headerlink" title="对偶算法"></a>对偶算法</h2><p>为了求解线性可分支持向量机的最优化问题，应用拉格朗日对偶性，通过求解对偶问题得到最优解。</p>
<p>定义拉格朗日函数：</p>
<p>$$L(w,b,\alpha) = \frac 1 2 {||w||}^2 - \sum_{i=0}^n \alpha_i y_i(w\cdot x_i + b) + \sum_{i=1}^N\alpha_i$$</p>
<p>其中，$\alpha = (\alpha_1, \alpha_2,…,\alpha_N)^T$为拉格朗日乘子向量。</p>
<p>根据拉格朗日对偶性，原始问题的对偶问题是极大极小问题需要先求$L(w,b,\alpha)$对(w,b)求极小，再对$\alpha$求极大：</p>
<p>$$\max_\alpha \min_{w,b} L(w,b,\alpha)$$</p>
<ul>
<li>$\min_{w,b} L(w,b,\alpha)$</li>
</ul>
<p>分别对$w,b,\alpha$求偏导数，并令其等于0，将结果带入原公式中即得</p>
<p>$$\min_{w,b} L(w,b,\alpha) = -\frac 1 2 \sum_{i-=1}^N  \sum_{j-=1}^N \alpha_i \alpha_j y_i y_j (x_i \cdot x_j) + \sum_{i=1}^N \alpha_i$$</p>
<ul>
<li>求$\min_{w,b} L(w, b, \alpha)$对$\alpha$的极大</li>
</ul>
<p>$$\max_\alpha -\frac 1 2 \sum_{i-=1}^N  \sum_{j-=1}^N \alpha_i \alpha_j y_i y_j (x_i \cdot x_j) + \sum_{i=1}^N \alpha_i \\<br>s.t.\quad \sum_{i=1}^N\alpha_i y_i=0,  \quad \alpha_i &gt; 0,i=1,2,…,N$$</p>
<p>等价于：</p>
<p>$$\min_\alpha \frac 1 2 \sum_{i-=1}^N  \sum_{j-=1}^N \alpha_i \alpha_j y_i y_j(x_i \cdot x_j) - \sum_{i=1}^N \alpha_i \\<br>s.t.\quad \sum_{i=1}^N\alpha_i y_i=0,  \quad \alpha_i &gt; 0, i=1,2,…,N$$</p>
<h2 id="线性可分支持向量机学习算法"><a href="#线性可分支持向量机学习算法" class="headerlink" title="线性可分支持向量机学习算法"></a>线性可分支持向量机学习算法</h2><p>(1)构造并求解约束最优化问题</p>
<p>$$\min_\alpha \frac 1 2 \sum_{i-=1}^N  \sum_{j-=1}^N \alpha_i \alpha_j y_i y_j(x_i \cdot x_j) - \sum_{i=1}^N \alpha_i\\<br>s.t.\quad \sum_{i=1}^N\alpha_i y_i=0,  \quad \alpha_i &gt; 0, i=1,2,…,N$$</p>
<p>(2)计算</p>
<p>$$w^* = \sum_{i=1}^N \alpha_i^* y_i x_i$$</p>
<p>并选择$\alpha^*$的一个正分量$\alpha_j^*$，计算</p>
<p>$$b^* = y_i - \sum_{i=1}^N \alpha_i^*y_i(x_i \cdot x_j)$$</p>
<p>(3)求得分离超平面</p>
<p>$$w^* \cdot x + b^* = 0$$</p>
<p>分类决策函数</p>
<p>$$f(x) = sign(w^* \cdot x + b^*)$$</p>
]]></content>
      
        <categories>
            
            <category> algorithm </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[python-多线程]]></title>
      <url>/2015/06/03/python-thread/</url>
      <content type="html"><![CDATA[<p>介绍python中的多线程。<br><a id="more"></a></p>
<h2 id="真正的多线程吗？"><a href="#真正的多线程吗？" class="headerlink" title="真正的多线程吗？"></a>真正的多线程吗？</h2><p>对于多核处理器，在同一时间确实可以多个线程独立运行，但在Python中确不是这样的了。原因在于，python虚拟机中引入了GIL这一概念。GIL（Global Interpreter Lock）全局解析器锁是用来解决共享资源访问的互斥问题，导致在python虚拟机中同一时间只能有一个线程访问python所提供的API。</p>
<pre><code>那么python是如何支持多线程的呢？
</code></pre><p>在操作系统中系统通过时钟中断进行进程的调度，而python正是参考这个原理。在python内部维护了一个内部的时钟，来记录每个线程每个时钟周期执行命令的数量。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.getcheckinterval() <span class="comment">#获取一个始终周期内执行指令数</span></span><br><span class="line"><span class="number">100</span></span><br></pre></td></tr></table></figure>
<p>当一个线程获得了python虚拟机的GIL后可以按顺序执行100条指令，然后挂起当前进程，切换下一个等待执行的线程。</p>
<pre><code>那么python如何选择下一个需要执行的线程呢？
</code></pre><p>python并没有去实现一个线程优先级调度算法，而是将线程选择问题交给了底层的操作系统，也就是说python借用了底层操作系统所提供的线程调度机制来决定下一个执行的线程。</p>
<p>因此，python使用的就是操作系统原生的线程，只是python在其基础之上提供了一套统一的抽象机制。</p>
<h2 id="线程切换"><a href="#线程切换" class="headerlink" title="线程切换"></a>线程切换</h2><p>在操作系统中，进程之间的切换需要不断保存和恢复进程之间的上下文环境，保证每一个进行都能在其对应的上下文环境中运行。python正是参考操作系统的切换机制，为每一个线程创建一个保存线程状态信息的PyFrameObject对象。在python中有有一个全局变量<code>PyThreadState *_PyThreadState_Current</code>用来保存当前活动线程的线程状态对象。</p>
<pre><code>下一线程切换需要的线程状态如何获取？
</code></pre><p>在python中通过一个单项链表来管理所有的python线程对象(保护线程的状态信息和线程信息，例如线程id)，当需要寻找一个线程对应的状态对象时，就遍历这个链表，搜索其对应的状态对象。</p>
<p>这个状态对象链表并不会受到GIL的保护，而是有其专用的锁。</p>
<p><strong>需要注意</strong></p>
<p>当前活动的python线程不一定是获得了GIL的线程，例如“主线程获得了GIL，子线程还没有申请到GIL时也没有挂起，而且主线程和子线程都是操作系统原生的线程，操作系统可能在主线程和子线程之间进行切换（操作系统的线程切换是不受python虚拟机控制的，属于操作系统自身行为）”。python虚拟机的调度是一定是获得GIL基础之上的，而操作系统级的就不一定获得GIL了。</p>
<p>虽有操作系统会把未获得GIL的线程切换为活动线程，但是该线程发现自身并没有获得GIL会自动挂起。</p>
<p>只有当所有线程都完成了初始化操作，操作系统的线程调度和Python线程调度才会一致。那时，python的线程调度会迫使当前活动线程释放GIL，导致触发GIL中维护的Event内核对象，从而触发操作系统的线程调度。（在初始化完成之前，python线程调度和操作系统调度之间没有因果关系）</p>
<h2 id="阻塞调度和线程销毁"><a href="#阻塞调度和线程销毁" class="headerlink" title="阻塞调度和线程销毁"></a>阻塞调度和线程销毁</h2><p>在python中如果有raw_input等待输入的操作时将自身阻塞后，并将等待GIL线程唤醒，这种情况成为阻塞调度。</p>
<p>在线程通过阻塞调度切换时，python内部的时钟周期技术<code>_Py_Ticker</code>依然会被保持，不会被重置。</p>
<p>python的主线程销毁和子线程销毁是不同的，子线程只需要维护引用计数，而主线程还需要销毁运行环境。</p>
<h2 id="用户级互斥和同步"><a href="#用户级互斥和同步" class="headerlink" title="用户级互斥和同步"></a>用户级互斥和同步</h2><p>上面讨论的GIL属于python内合计互斥，实现了保护内存的共享资源。而用户级互斥保护了用户程序中的共享资源。</p>
<p>python中提供了lock机制来实现线程之间的互斥。当线程通过lock.acquire获得lock之后，子线程会因为等待lock而挂起，直到主线程释放lock之后才会被Python的线程调度机制唤醒。</p>
<p>在线程执行过程中如果出现需要等待另一个lock资源的时候，需要将GIL转交给其他等待GIL的线程以避免死锁。</p>
]]></content>
      
        <categories>
            
            <category> python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[python virtualenv]]></title>
      <url>/2015/05/29/python-virtualenv/</url>
      <content type="html"><![CDATA[<p>virtualenv 是一个创建隔离的Python环境的工具，创建独立的python运行环境。<br><a id="more"></a></p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>任选一种安装方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install python-virtualenv</span><br><span class="line">sudo pip install virtualenv</span><br></pre></td></tr></table></figure>
<h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><h3 id="创建和删除"><a href="#创建和删除" class="headerlink" title="创建和删除"></a>创建和删除</h3><p>创建虚拟环境时可以添加<code>--python</code>来指定虚拟环境的python版本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">virtualenv mysite</span><br><span class="line">virtualenv mysite --python=python3.4</span><br><span class="line"></span><br><span class="line">rmvirtualenv mysite</span><br></pre></td></tr></table></figure></p>
<p>运行命令后会在当前文件夹下生成mysite文件夹，其中包含着最基本的开发库。</p>
<h3 id="运行虚拟环境"><a href="#运行虚拟环境" class="headerlink" title="运行虚拟环境"></a>运行虚拟环境</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd mysite</span><br><span class="line">source ./bin/activate</span><br></pre></td></tr></table></figure>
<p>启动虚拟环境后，可以尝试在虚拟环境内安装一个bottle，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(mysite)y@ubuntu:~/mysite$ pip install bottle</span><br><span class="line">	...</span><br><span class="line">#进入python命令行</span><br><span class="line">&gt;&gt;&gt; import bottle</span><br></pre></td></tr></table></figure>
<p>成功安装，import模块并没有报错，注意当前是在虚拟环境下安装和运行的结果。</p>
<p>退出虚拟环境，同样在python的命令行下执行import bottle，会发现bottle模块并不存在。这种情况就是virtualenv所谓的隔离效果。</p>
<h3 id="退出虚拟环境"><a href="#退出虚拟环境" class="headerlink" title="退出虚拟环境"></a>退出虚拟环境</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deactivate</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>virtualenv提供了一种隔离不同Python版本。</p>
<p>virtualenv创建的虚拟环境不会对除自己之外的其他环境造成影响，从而可以保证一个纯净的开发测试环境。</p>
<p>virtualenv创建的虚拟环境可以直接打包移动到其他机器（需要安装有同样的python版本）上运行，其所运行所需要的开发库（除python基本开发库）均包含在虚拟环境内。</p>
]]></content>
      
        <categories>
            
            <category> python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[python 模块加载]]></title>
      <url>/2015/05/27/python-module-init/</url>
      <content type="html"><![CDATA[<p>本文主要介绍python模块加载的过程。<br><a id="more"></a></p>
<h2 id="module的组成"><a href="#module的组成" class="headerlink" title="module的组成"></a>module的组成</h2><p>所有的module都是由对象和对象之间的关系组成。</p>
<h2 id="type和object"><a href="#type和object" class="headerlink" title="#type和object"></a>#type和object</h2><p>python中所有的东西都是对象，分为三类：类型type、类class和实例instance。</p>
<p>三种对象之间的两种关系：</p>
<ul>
<li>is kind of，基类和子类的关系</li>
<li>is instance of，类和对象的关系</li>
</ul>
<p>类和对象的关系可以通过内建方法<code>type</code>来辨别。</p>
<p>python中，任何一个类都是直接或间接继承自object，而每一个对象都会拥有自己的type类型，可以通过__class__属性获得。</p>
<h2 id="运行环境初始化"><a href="#运行环境初始化" class="headerlink" title="运行环境初始化"></a>运行环境初始化</h2><p>python首先需要加载多个基础的module，例如__builtin__,sys等，同时也会完成python类型系统的初始化和异常系统的初始化。</p>
<h3 id="系统module初始化"><a href="#系统module初始化" class="headerlink" title="系统module初始化"></a>系统module初始化</h3><p>Python内部维护了一个维护加载到内存的module集合，需要现在集合中查找module是否存在。如果存在直接返回该module对象，否则创建该module对象，并插入到module集合中。创建module后，需要设置module的属性。</p>
<p>由于python的module集合是一个PyDictObject对象，而PyDictObject对象在Python中是一个可变对象，所以其中维护的元素有可能在运行时被删除。对于Python的扩展module，例如sys，为了避免再一次初始化同样的module，python将所有的扩展module通过一个全局的PyDictObject对象来进行备份维护。</p>
<h3 id="启动虚拟机"><a href="#启动虚拟机" class="headerlink" title="启动虚拟机"></a>启动虚拟机</h3><p>python包括两种运行方式：命令行和脚本文件。</p>
<p>python中的run_mode函数基于AST抽象语法树 (AST, Abstract Syntax Tree)完成了字节码的编译工作，并创建PyCodeObject对象。</p>
<p>python中所有的线程都是共享同样的builtin名字空间。</p>
<h2 id="模块的动态加载"><a href="#模块的动态加载" class="headerlink" title="模块的动态加载"></a>模块的动态加载</h2><p>import功能包括：</p>
<ul>
<li>python运行时的全局module缓存的维护和搜索；</li>
<li>解析和搜索module路径的树形结构；</li>
<li>对不同文件格式的module动态加载机制。</li>
</ul>
<p>py文件中的import不会影响上一层的命名空间，只会影响各自的命名空间，也就是影响各自module自身维护的那个dict对象。但所有的import操作都会影响全局的module集合，这样的话只要再一次import该module，python虚拟机只需要将全局module集合中缓存的对象返回。</p>
<p>在module的基础之上，python提供了package机制（逻辑相关联的module需要聚合到同一package中）。也就是说通过package机制来管理module，通过module来管理class。</p>
<p>文件件中存在__init__.py文件才能成为package（多个py文件组成的文件夹）。</p>
<p>在加载package下的module时，例如a.b.c，python内部将这个module视为一个树形结构，c是b的子节点，b是a的子节点。python虚拟机在动态加载时，需要将这个树形结构分解，然后从左到右依次去sys.modules中查找每一个符号是否存在。如果已经存在，假设存在a，那么在a对应的PyModuleObject对象中保持着__path__路径信息，此时就可以在a.__path__路径中搜索b和c了。</p>
<p>del删除模块只是把模块从当前命名空间中删除，但该module依然存在于module缓存中。</p>
<h3 id="module缓存"><a href="#module缓存" class="headerlink" title="module缓存"></a>module缓存</h3><p>python中的全局module集合sys.modules被称为modules缓存，保证了module的唯一性，每当有import操作都会在该sys.modules查找，如果不存在就会将该module加入到sys.modules中。</p>
<p>如果已经加载的模块发生改变，那么需要调用<code>reload</code>函数来重新加载该模块。需要注意reload函数并不会重新创建该对象，而在在原有对象的基础上做修改。</p>
]]></content>
      
        <categories>
            
            <category> python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[python 名字、作用域和命名空间]]></title>
      <url>/2015/05/27/python-name-space/</url>
      <content type="html"><![CDATA[<p>在python中包括三个独立的命名空间：local、global和builtin，所有信息保存在PyFrameObject中。<br><a id="more"></a></p>
<h3 id="访问PyFrameObject"><a href="#访问PyFrameObject" class="headerlink" title="访问PyFrameObject"></a>访问PyFrameObject</h3><p>PyFrameObject对象是一个用于python虚拟机实现的内部对象，对应于可执行文件在执行时的栈帧，但python提供了<code>getframe</code>方法来访问该对象。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">frame = sys._getframe()</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> frame.f_code.co_name <span class="comment"># 函数名称</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> frame.f_locals <span class="comment">#局部变量</span></span><br><span class="line"><span class="keyword">print</span> frame.f_globals <span class="comment">#全局变量</span></span><br></pre></td></tr></table></figure>
<h3 id="module与命名空间"><a href="#module与命名空间" class="headerlink" title="module与命名空间"></a>module与命名空间</h3><p>py文件可以视为一个module，它的作用不仅是为了代码复用，而且可以为整个系统划分命名空间。</p>
<p>在python中，赋值语句会影响命名空间。由于命名空间和变量函数的约束关系，python中采用PyDictObject对象来存储该约束关系。</p>
<p>在一个module的内部，可能存在多个命名空间，每一个命名空间都与一个作用域对应。作用域是指一段程序的正文区域，在这个区域里可能存在多个约束条件，但除了这个区域约束条件就不起作用了。在python中，一个约束条件是否起作用，是由该约束在文本中的位置决定的，而不是动态决定，因此，python是具有<code>静态作用域</code>。</p>
<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>在python中，一个函数定义了一个Local作用域；一个module定义了一个global作用域；python自身定义的作用域builtin作用域（内建函数dir,open,range等）。</p>
<p>名字引用是指在命名空间中查找一个名字所引用的对象，不允许越过module边界。<br>属性引用是指到对象的命名空间查找名字。</p>
<h3 id="嵌套函数的命名空间"><a href="#嵌套函数的命名空间" class="headerlink" title="嵌套函数的命名空间"></a>嵌套函数的命名空间</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compare</span><span class="params">(base, value)</span>:</span></span><br><span class="line">	<span class="keyword">return</span> value &gt; base</span><br><span class="line"></span><br><span class="line">compare(<span class="number">10</span>, <span class="number">5</span>)</span><br><span class="line">compare(<span class="number">10</span>, <span class="number">20</span>)</span><br></pre></td></tr></table></figure>
<p>上面的例子中，会使用两次10来进行比较，python中提供嵌套的方法只需要设置一次10即可。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_compare</span><span class="params">(base)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">real_compare</span><span class="params">(value)</span>:</span></span><br><span class="line">		<span class="keyword">return</span> value &gt; base</span><br><span class="line"></span><br><span class="line">compare_with_10 = get_compare(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">print</span> compare_with_10(<span class="number">5</span>) <span class="comment">#False</span></span><br><span class="line"><span class="keyword">print</span> compare_with_10(<span class="number">20</span>) <span class="comment">#True</span></span><br></pre></td></tr></table></figure>
<p>上面的例子形成了一个闭包，是将名字空间和函数捆绑后的结果。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_compare</span><span class="params">(base)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">real_compare</span><span class="params">(value, base=base)</span>:</span></span><br><span class="line">		<span class="keyword">return</span> value &gt; base</span><br><span class="line"></span><br><span class="line">compare_with_10 = get_compare(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">print</span> compare_with_10(<span class="number">5</span>) <span class="comment">#False</span></span><br><span class="line"><span class="keyword">print</span> compare_with_10(<span class="number">20</span>) <span class="comment">#True</span></span><br><span class="line"><span class="keyword">print</span> compare_with_10(<span class="number">5</span>, <span class="number">1</span>) <span class="comment">#True</span></span><br></pre></td></tr></table></figure>
<h3 id="线程与module"><a href="#线程与module" class="headerlink" title="线程与module"></a>线程与module</h3><p>在python中，所有module是全局共享的。</p>
<p>pyton虚拟机是对CPU的抽象，利用不同线程轮流使用虚拟机来实现多线程。</p>
<p>python中使用GIL（Global Interpreter Lock）来实现线程同步。</p>
]]></content>
      
        <categories>
            
            <category> python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[python 对象]]></title>
      <url>/2015/05/24/python-object/</url>
      <content type="html"><![CDATA[<p>在python中，对象就是为C中的结构体在堆上申请的一块内存，一般来说，对象是不能被静态初始化的，并且不能再栈空间上生存。本文主要对Python的基本数据类型做简单的介绍。<br><a id="more"></a></p>
<h2 id="PyObject"><a href="#PyObject" class="headerlink" title="PyObject"></a>PyObject</h2><p>在python中，所有东西都是对象，而所欲的对象都拥有一些共性（object.h/PyObject）。<br>PyObject是整个python对象机制的核心。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">object</span> &#123;</span></span><br><span class="line">    PyObject_HEAD</span><br><span class="line">&#125; PyObject;</span><br></pre></td></tr></table></figure>
<p>在release模式下编译python时，PyObject如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">object</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> ob_refcnt; <span class="comment">//引用计数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">typeobject</span> *<span class="title">ob_type</span>;</span> <span class="comment">//类型</span></span><br><span class="line">&#125; PyObject;</span><br></pre></td></tr></table></figure></p>
<p>其中，ob_refcnt为int整型，实现了基于引用计数的垃圾收集机制。对于某一对象A，当有一个新的PyObject<em>引用该对象时，A的引用计数应该增加；而当这个PyObject</em>被删除时，A的引用计数应该减少；当A的引用计数减少到0时，A就可以从堆上被删除，以释放出内存供别的对象使用。<br><!--more--></p>
<h2 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h2><p>PyObject中的ob_refcnt是一个32位的整形变量，这实际蕴含着Python所有的一个假设，既对一个对象的引用不会超过一个整形变量的最大值。</p>
<h2 id="整数对象"><a href="#整数对象" class="headerlink" title="整数对象"></a>整数对象</h2><h3 id="小整数对象"><a href="#小整数对象" class="headerlink" title="小整数对象"></a>小整数对象</h3><p>在python中，所有对象都存活在堆上，python重复地使用malloc申请空间，大大降低了运行效率，造成大量内存碎片，影响整体性能。因此，在python中，对小整数对象使用了对象池技术，用来缓存所有的小整形对象（对重复的对象不需要重复的malloc）。</p>
<p>NSMALLPOSINTS和NSMALLNEGINTS来修改小整数对象池的范围（默认分别为257和-5）。</p>
<h3 id="大整数对象"><a href="#大整数对象" class="headerlink" title="大整数对象"></a>大整数对象</h3><p>对于小整数，使用对象池技术完全缓存其PyIntObject对象，而对于其他整数，python提供了一种PyIntBlock结构供大整形对象使用。PyIntBlock是通过维护一块内存（Block）来供大整数使用，并通过单向列表block_list来维护。</p>
<blockquote>
<p>Python的设计者为了提高代码执行效率放弃了类型安全使用了宏来代替函数。</p>
</blockquote>
<p>当一个PyIntObject对象被销毁时，它所占用的内存并不会被释放，而是继续被python保留着，加入到free_list所维护的自有内存链表，为其他需要创建对象的内存使用。</p>
<h2 id="字符串对象"><a href="#字符串对象" class="headerlink" title="字符串对象"></a>字符串对象</h2><p>在python中，PyStringObject是字符串对象的实现，它是一个拥有可变长度内存的对象。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">trpdef <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_VAR_HEAD <span class="comment">//ob_size字符串长度</span></span><br><span class="line">    <span class="keyword">long</span> ob_shash; <span class="comment">//字符串hash值</span></span><br><span class="line">    <span class="keyword">int</span> ob_sstate; </span><br><span class="line">    <span class="keyword">char</span> ob_sval[<span class="number">1</span>];</span><br><span class="line">&#125; PyStringObject;</span><br></pre></td></tr></table></figure>
<p>在PyStringObject中，还使用了intern机制和缓存池技术。</p>
<p>###intern机制和缓存池</p>
<p>intern机制的目的：保证被intern之后的字符串在python整个运行期间只对应唯一的一个PyStringObject对象。</p>
<p>intern机制的关键是在系统中有一个（key,value）映射的集合，记录所有被intern机制处理过的PyStringObject对象。当python在创建一个字符串时，会首先在interned中检查是否已经有该字符串对应的PyStringObject对象了，如果有，则不用创建新的，这样可以节省内存空间。其实，Python始终会为字符串创建PyStringObject对象，intern机制是在创建之后才会生效的，通常python在运行时创建一个PyStrhingObject对象temp后，基本就会销毁该对象（引用计数减1）。</p>
<p>类似小整形的缓存池，python为PyStringObject中的一个字节的字符对应的PyStringObject对象设计对象池characters。</p>
<p>Python中的处理顺序：</p>
<ul>
<li>判断是否为一个字符</li>
<li>创建PyStringObject对象进行intern操作</li>
<li>将intern结果缓存到字符缓冲池中</li>
</ul>
<p>###PyStringObject效率问题</p>
<p>在Python中”+”操作符进行字符串连接的方法效率极其低下，其根源在于python中的PyStringObject对象是一个<code>不可变对象</code>。这就意味着当进行字符串连接时，实际上必须要创建一个新的PyStringObject对象。因此，如果需要连接N个PyStringObject对象，就必须进行N-1次内存申请及内存搬运工作，严重影响python的执行效率。</p>
<blockquote>
<p>官方推荐利用PyStringObject对象的join操作来对存储在list和tuple中一组PyStringObject对象进行连接操作，只需要分配一次内存，执行效率大大提高。</p>
</blockquote>
<p>join操作会统计出list中所有PyStringObject对象的字符串长度，然后申请内存。</p>
<p>##列表对象</p>
<p>PyListObject是Python提供的对列表的抽象。它类似于C++中的vector，而不是list。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_VAR_HEAD</span><br><span class="line">    PyObject **ob_item; <span class="comment">//元素首地址</span></span><br><span class="line">    <span class="keyword">int</span> allocated; <span class="comment">//实际申请内存的个数（部分没有被使用，类似于vector）</span></span><br><span class="line">&#125; PyListObject;</span><br></pre></td></tr></table></figure>
<p>其中，ob_item为指向元素列表的指针。</p>
<p>python所采用的内存管理策略和c++中vector采取的内存管理策略一样，并不是寸多少数据就要申请对应大小的空间，这样内存管理的效率较低，因此，在每一次申请内存时PyListObject总会申请一大块内存，该内存的大小就记录在allocated中，而实际被使用的内存数量记录在ob_size中。</p>
<p>###对象缓存池</p>
<p>在创建一个新的list时，首先创建PyListObject对象，然后创建PyListObject对象所维护的元素列表；在销毁一个List时，首先销毁PyListObject所维护的列表，然后释放掉PyListObject本身，但是在释放之前python会检查缓冲池free_lists，查看其中缓存的PyListObject的数量是佛已经满了，如果没有，就将该数据对象加入到穿存池中，否则删除。</p>
<p>##Dict对象</p>
<p>与map不同，PyDictObject采用散列表(hash table)。在最优情况下，散列表能提供O（1）复杂度的搜索效率。</p>
<p>###散列表</p>
<p>散列表的基本思想是通过一个函数将需搜索的键值映射为一个整数，将这个整数视为索引值访问某片连续性的内存区域。</p>
<p>在使用散列表的过程中，不同的对象经过散列函数的作用，可能被映射为相同的散列值。随着需要存储的数据的增多，这样的冲突就会发生得越来越频繁。散列冲突是散列表不可避免的问题，当散列表的装载率（已使用空间和总空间的比值）大于2/3时，散列冲突发生的概率就会大大增加。</p>
<p>在STL库的hash table采用开链法来解决冲突，而python中采用开放地址法。当产生冲突时，python会通过一个二次探测函数f计算下一个候选位置，如果该候选位置可用，则可将待插入元素放到该位置，否则再次调用探测函数f，寻找可用位置。</p>
<p>###关联容器entry</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Py_ssize me_hash; <span class="comment">//散列值</span></span><br><span class="line">    PyObject *me_key;</span><br><span class="line">    PyObject *me_value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在PyDictObject对象生存变化的过程中，其中entry会在不同的状态间转换：Unused、Active和Dummy。</p>
<ul>
<li>Unused：当一个entry的me_key和me_value都是NULL；</li>
<li>Active：当entry中存储了一个(key，value)对时；</li>
<li>dummy：当entry中存储的（key,value）被删除后，entry的状态不能直接从Active转到unused（伪删除），否则会出现冲突探测链中断。</li>
</ul>
]]></content>
      
        <categories>
            
            <category> python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[RabbitMQ 远程连接]]></title>
      <url>/2015/04/26/rabbitmq-remote-access/</url>
      <content type="html"><![CDATA[<p>解决rabbitmq远程连接的问题。<br><a id="more"></a><br>默认情况下，rabbitmq使用<code>guest</code>来连接本地（localhost）的server，当需要远程连接时，就会失效。</p>
<pre><code>&quot;guest&quot; user can only connect via localhost
</code></pre><p>官方文档：<a href="http://www.rabbitmq.com/access-control.html" target="_blank" rel="external">http://www.rabbitmq.com/access-control.html</a></p>
<p>如果必须使用<code>guest</code>用户来进行远程登录，需要修改配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&#123;rabbit, [&#123;loopback_users, []&#125;]&#125;].</span><br></pre></td></tr></table></figure>
<p>（1）那么首先需要创建并添加一个用户<code>test</code>，让其具有管理员权限</p>
<ul>
<li>rabbitmqctl add_user rootroot </li>
<li>rabbitmqctl set_user_tags rootadministrator </li>
<li>rabbitmqctl set_permissions -p / root”.<em>“ “.</em>“ “.*”</li>
</ul>
<p>（2）修改配置文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&#123;rabbit, [&#123;loopback_users, [&quot;root&quot;]&#125;]&#125;].</span><br></pre></td></tr></table></figure></p>
<p>（3）重启rabbitmq-server</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/rabbitmq-server restart</span><br></pre></td></tr></table></figure>
<p>（4）修改host</p>
<p>修改远程客户端机器上的/etc/hosts，添加rabbit-server的IP</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xx.xx.xx.xx rabbit-server</span><br></pre></td></tr></table></figure>
<p>（5）认证</p>
<p>原文：<a href="https://pika.readthedocs.org/en/0.9.14/modules/parameters.html" target="_blank" rel="external">https://pika.readthedocs.org/en/0.9.14/modules/parameters.html</a><br>pika提供了两种认证方式：ConnectinParameters和URLParameters。</p>
<p><strong>ConnectionParameters</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set the connection parameters to connect to rabbit-server1 on port 5672# on the / virtual host using the username "guest" and password "guest"</span></span><br><span class="line">credentials = pika.PlainCredentials(<span class="string">'root'</span>, <span class="string">'root'</span>)</span><br><span class="line">parameters = pika.ConnectionParameters(<span class="string">'rabbit-server1'</span>,</span><br><span class="line">                                       <span class="number">5672</span>,</span><br><span class="line">                                       <span class="string">'/'</span>,</span><br><span class="line">                                       credentials)</span><br></pre></td></tr></table></figure>
<p><strong>URLParameters</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set the connection parameters to connect to rabbit-server1 on port 5672# on the / virtual host using the username "guest" and password "guest"</span></span><br><span class="line">parameters = pika.URLParameters(<span class="string">'amqp://guest:guest@rabbit-server1:5672/%2F'</span>)</span><br></pre></td></tr></table></figure>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><pre><code class="python"><span class="keyword">import</span> pika

i = <span class="number">1</span>

<span class="function"><span class="keyword">def</span> <span class="title">callback</span><span class="params">(ch, method, properties, body)</span>:</span>
    <span class="keyword">global</span> i
    <span class="comment">#print 'receive %r'%body</span>
    <span class="keyword">print</span> <span class="string">'receive %s'</span>%i
    i += <span class="number">1</span>
    f = open(<span class="string">'%s'</span>%i, <span class="string">'w+'</span>)
    f.write(body)
    f.close()

<span class="comment">#第一种方法</span>
<span class="comment">#credentials = pika.PlainCredentials('mtest', 'root')</span>
<span class="comment">#connection = pika.BlockingConnection(pika.ConnectionParameters('rabbit-server', 5672, '/', credentials))</span>
<span class="comment">#第二种方法</span>
parameters = pika.URLParameters(<span class="string">'amqp://mtest:root@rabbit-server:5672/%2F'</span>)
connection = pika.BlockingConnection(parameters)

channel = connection.channel()

channel.queue_declare(queue=<span class="string">'hello'</span>)

channel.basic_consume(callback, queue=<span class="string">'hello1'</span>, no_ack=<span class="keyword">True</span>)

channel.start_consuming()
</code></pre>
]]></content>
      
        <categories>
            
            <category> mq </category>
            
        </categories>
        
        
        <tags>
            
            <tag> rabbitmq </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[memcache 内存管理]]></title>
      <url>/2015/04/26/memcache-memory-management/</url>
      <content type="html"><![CDATA[<p>memcached使用预申请的方式来管理内存的分配，从而避免内存碎片化的问题。如果采用mallo和free来动态的申请和销毁内存，必然会产生大量的内存碎片。<br><a id="more"></a></p>
<h2 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h2><p>slab：内存块是memcached一次申请内存的最小单元，在memcached中一个slab的默认大小为1M；</p>
<p>slabclass：特定大小的chunk的组。</p>
<p>chunk：缓存的内存空间，一个slab被划分为若干个chunk；</p>
<p>item：存储数据的最小单元，每一个chunk都会包含一个item；</p>
<p>factor:增长因子，默认为1.25，相邻slab中的item大小与factor成比例关系；</p>
<h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>memcached使用预分配方法，避免频繁的调用malloc和free；</p>
<p>memcached通过不同的slab来管理不同chunk大小的内存块，从而满足存储不同大小的数据。</p>
<p>slab的申请是通过在使用item时申请slab大小的内存空间，然后再把内存切割为大小相同的item，挂在到slab的未使用链表上。</p>
<p>过期和被删除item并不会被free掉，memcached并不会删除已经分配的内存；</p>
<p>Memcached会优先使用已超时的记录空间，通过LRU算法；</p>
<p>memcached使用lazy expiration来判断元素是否过期，所以过期监视上不会占用cpu时间。</p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>下面主要分析memcached的内存申请和存储相关代码。</p>
<h3 id="item"><a href="#item" class="headerlink" title="item"></a>item</h3><p>item是key/value的存储单元。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">stritem</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">stritem</span> *<span class="title">next</span>;</span>      <span class="comment">/* 前后指针用于在链表slab-&gt;slots中连接前后数据 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">stritem</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">stritem</span> *<span class="title">h_next</span>;</span>    <span class="comment">/* hash chain next */</span></span><br><span class="line">    <span class="keyword">rel_time_t</span>      time;       <span class="comment">/* 最后一次访问时间 */</span></span><br><span class="line">    <span class="keyword">rel_time_t</span>      exptime;    <span class="comment">/* 过期时间 */</span></span><br><span class="line">    <span class="keyword">int</span>             nbytes;     <span class="comment">/* 数据大小 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span>  refcount;   <span class="comment">/* 引用次数 */</span></span><br><span class="line">    <span class="keyword">uint8_t</span>         nsuffix;    <span class="comment">/* suffix长度 */</span></span><br><span class="line">    <span class="keyword">uint8_t</span>         it_flags;   <span class="comment">/* ITEM_* above */</span></span><br><span class="line">    <span class="keyword">uint8_t</span>         slabs_clsid;<span class="comment">/* 所有slab的id */</span></span><br><span class="line">    <span class="keyword">uint8_t</span>         nkey;       <span class="comment">/* key长度 */</span></span><br><span class="line">    <span class="comment">/* this odd type prevents type-punning issues when we do</span></span><br><span class="line"><span class="comment">     * the little shuffle to save space when not using CAS. */</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">uint64_t</span> cas;</span><br><span class="line">        <span class="keyword">char</span> end;</span><br><span class="line">    &#125; data[]; <span class="comment">/* cas|key|suffix|value */</span></span><br><span class="line">&#125; item;</span><br></pre></td></tr></table></figure>
<h3 id="slab初始化"><a href="#slab初始化" class="headerlink" title="slab初始化"></a>slab初始化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slabs_init</span><span class="params">(<span class="keyword">const</span> <span class="keyword">size_t</span> limit, <span class="keyword">const</span> <span class="keyword">double</span> factor, <span class="keyword">const</span> <span class="keyword">bool</span> prealloc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = POWER_SMALLEST - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> size = <span class="keyword">sizeof</span>(item) + settings.chunk_size; <span class="comment">/* 得到每一个item的大小 */</span></span><br><span class="line"></span><br><span class="line">    mem_limit = limit;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (prealloc) &#123; <span class="comment">/* 预分配一块内存 */</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(slabclass, <span class="number">0</span>, <span class="keyword">sizeof</span>(slabclass)); <span class="comment">/* 把slabclass置为0，slabclass是一个slab数组，存储所有slab的信息 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (++i &lt; POWER_LARGEST &amp;&amp; size &lt;= settings.item_size_max / factor) &#123;  <span class="comment">/* 循环初始化每一个slab的内容,保证slab中item的size小于max_size/factor */</span></span><br><span class="line">        <span class="comment">/* Make sure items are always n-byte aligned */</span></span><br><span class="line">        <span class="keyword">if</span> (size % CHUNK_ALIGN_BYTES)  <span class="comment">/* 用于内存对齐 */</span></span><br><span class="line">            size += CHUNK_ALIGN_BYTES - (size % CHUNK_ALIGN_BYTES);</span><br><span class="line"></span><br><span class="line">        slabclass[i].size = size; <span class="comment">/* 初始化slabclass中item的大小 */</span></span><br><span class="line">        slabclass[i].perslab = settings.item_size_max / slabclass[i].size; <span class="comment">/* 初始化每个slab中item的数量 */</span></span><br><span class="line">        size *= factor;  <span class="comment">/* item的大小随factor逐渐增大 */</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 初始化最后一个slab,大小为最大的max_size，只有一个item */</span></span><br><span class="line">    power_largest = i;</span><br><span class="line">    slabclass[power_largest].size = settings.item_size_max;</span><br><span class="line">    slabclass[power_largest].perslab = <span class="number">1</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从源码中，可以看出来同一个slab中所有的item的大小都是固定的，</p>
<h3 id="申请slab内存"><a href="#申请slab内存" class="headerlink" title="申请slab内存"></a>申请slab内存</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">do_slabs_alloc</span><span class="params">(<span class="keyword">const</span> <span class="keyword">size_t</span> size, <span class="keyword">unsigned</span> <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">slabclass_t</span> *p;</span><br><span class="line">    <span class="keyword">void</span> *ret = <span class="literal">NULL</span>;</span><br><span class="line">    item *it = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (id &lt; POWER_SMALLEST || id &gt; power_largest) &#123; <span class="comment">/* 判断id是否合法 */</span></span><br><span class="line">        MEMCACHED_SLABS_ALLOCATE_FAILED(size, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p = &amp;slabclass[id]; <span class="comment">/* 获取slab */</span></span><br><span class="line">    assert(p-&gt;sl_curr == <span class="number">0</span> || ((item *)p-&gt;slots)-&gt;slabs_clsid == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* fail unless we have space at the end of a recently allocated page,</span></span><br><span class="line"><span class="comment">       we have something on our freelist, or we could allocate a new page */</span></span><br><span class="line">    <span class="keyword">if</span> (! (p-&gt;sl_curr != <span class="number">0</span> || do_slabs_newslab(id) != <span class="number">0</span>)) &#123; <span class="comment">/*如果sl_curr为0，没有剩余的item，那么就执行do_slabs_newslab申请内存空间*/</span></span><br><span class="line">        <span class="comment">/* We don't have more memory available */</span></span><br><span class="line">        ret = <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;sl_curr != <span class="number">0</span>) &#123; <span class="comment">/* 如果有未使用的空间，则获取该item，并从slots链表中删除该item */</span></span><br><span class="line">        <span class="comment">/* return off our freelist */</span></span><br><span class="line">        it = (item *)p-&gt;slots;</span><br><span class="line">        p-&gt;slots = it-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (it-&gt;next) it-&gt;next-&gt;prev = <span class="number">0</span>;</span><br><span class="line">        p-&gt;sl_curr--;</span><br><span class="line">        ret = (<span class="keyword">void</span> *)it;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>sl_curr来判断是否存在未使用的内容空间，如果不存在需要调用do_slabs_newslab来申请slab空间。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">do_slabs_newslab</span><span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">slabclass_t</span> *p = &amp;slabclass[id];</span><br><span class="line">    <span class="keyword">int</span> len = settings.slab_reassign ? settings.item_size_max</span><br><span class="line">        : p-&gt;size * p-&gt;perslab;</span><br><span class="line">    <span class="keyword">char</span> *ptr;</span><br><span class="line">    <span class="comment">/* 1. 判断是否超过内存限制</span></span><br><span class="line"><span class="comment">         2. 判断是否申请过内存空间</span></span><br><span class="line"><span class="comment">         3. 如果没有申请过，则申请slab-&gt;size*slab-&gt;perslab大小的整块内存</span></span><br><span class="line"><span class="comment">         4.如果申请过，调用grow_slab_list来扩大slab大小 */</span></span><br><span class="line">    <span class="keyword">if</span> ((mem_limit &amp;&amp; mem_malloced + len &gt; mem_limit &amp;&amp; p-&gt;slabs &gt; <span class="number">0</span>) ||</span><br><span class="line">        (grow_slab_list(id) == <span class="number">0</span>) ||</span><br><span class="line">        ((ptr = memory_allocate((<span class="keyword">size_t</span>)len)) == <span class="number">0</span>)) &#123;</span><br><span class="line"></span><br><span class="line">        MEMCACHED_SLABS_SLABCLASS_ALLOCATE_FAILED(id);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(ptr, <span class="number">0</span>, (<span class="keyword">size_t</span>)len);</span><br><span class="line">    split_slab_page_into_freelist(ptr, id); <span class="comment">/* 把申请的内存分配到slots链表中 */</span></span><br><span class="line"></span><br><span class="line">    p-&gt;slab_list[p-&gt;slabs++] = ptr;</span><br><span class="line">    mem_malloced += len;</span><br><span class="line">    MEMCACHED_SLABS_SLABCLASS_ALLOCATE(id);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>申请空间后，需要通过split_slab_page_into_freelist函数把申请的内存空间分配到未使用的链表中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">split_slab_page_into_freelist</span><span class="params">(<span class="keyword">char</span> *ptr, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">slabclass_t</span> *p = &amp;slabclass[id];</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">for</span> (x = <span class="number">0</span>; x &lt; p-&gt;perslab; x++) &#123; <span class="comment">/* 循环分配内存 */</span></span><br><span class="line">        do_slabs_free(ptr, <span class="number">0</span>, id);</span><br><span class="line">        ptr += p-&gt;size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">do_slabs_free</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">const</span> <span class="keyword">size_t</span> size, <span class="keyword">unsigned</span> <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">slabclass_t</span> *p;</span><br><span class="line">    item *it;</span><br><span class="line">    ...</span><br><span class="line">    p = &amp;slabclass[id];</span><br><span class="line">    <span class="comment">/* 获取内存指针，把item块挂在到slots链表中，增加sl_curr */</span></span><br><span class="line">    it = (item *)ptr;</span><br><span class="line">    it-&gt;it_flags |= ITEM_SLABBED;</span><br><span class="line">    it-&gt;prev = <span class="number">0</span>;</span><br><span class="line">    it-&gt;next = p-&gt;slots;</span><br><span class="line">    <span class="keyword">if</span> (it-&gt;next) it-&gt;next-&gt;prev = it;</span><br><span class="line">    p-&gt;slots = it;</span><br><span class="line"></span><br><span class="line">    p-&gt;sl_curr++;</span><br><span class="line">    p-&gt;requested -= size;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="获取适当大小的item"><a href="#获取适当大小的item" class="headerlink" title="获取适当大小的item"></a>获取适当大小的item</h3><p>在do_item_alloc中，调用了slabs_clsid来获取适合存储当前元素的slab id。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">slabs_clsid</span><span class="params">(<span class="keyword">const</span> <span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = POWER_SMALLEST;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (size &gt; slabclass[res].size)    <span class="comment">/* 遍历slabclass来找到适合size的item */</span></span><br><span class="line">        <span class="keyword">if</span> (res++ == power_largest)     <span class="comment">/* won't fit in the biggest slab */</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>内存预分配可以避免内存碎片以及避免动态分配造成的开销。</p>
<p>内存分配是由冗余的，当一个slab不能被它所拥有的chunk大小整除时，slab尾部剩余的空间就会被丢弃。</p>
<p>由于分配的是特定长度的内存，因此无法有效地利用所有分配的内存，例如如果将100字节的数据存储在128字节的chunk中，会造成28字节的浪费。</p>
]]></content>
      
        <categories>
            
            <category> cache </category>
            
        </categories>
        
        
        <tags>
            
            <tag> memcache </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python实现web框架simfish]]></title>
      <url>/2015/04/26/simfish-framework/</url>
      <content type="html"><![CDATA[<p>本文主要记录本人利用Python实现web框架simfish的过程。源码github地址：<a href="https://github.com/yxd123/simfish" target="_blank" rel="external">simfish</a><br><a id="more"></a></p>
<h2 id="WSGI-HTTP-Server"><a href="#WSGI-HTTP-Server" class="headerlink" title="WSGI HTTP Server"></a>WSGI HTTP Server</h2><p>wsgi模块提供了简单的simple_server，</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsgiref.simple_server.make_server(host, port, app, server_class=WSGIServer, handler_class=WSGIRequestHandler)</span><br></pre></td></tr></table></figure>
<p>官方提供的例子，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">from wsgiref.simple_server import make_server, demo_app</span><br><span class="line"></span><br><span class="line">httpd = make_server(&apos;&apos;, 8000, demo_app)</span><br><span class="line">print &quot;Serving HTTP on port 8000...&quot;</span><br><span class="line"></span><br><span class="line"># Respond to requests until process is killed</span><br><span class="line">httpd.serve_forever()</span><br><span class="line"></span><br><span class="line"># Alternative: serve one request, then exit</span><br><span class="line">httpd.handle_request()</span><br></pre></td></tr></table></figure>
<p>访问<a href="http://127.0.0.1:8000来检查是否正常运行。" target="_blank" rel="external">http://127.0.0.1:8000来检查是否正常运行。</a></p>
<p>因此，有了wsgi的帮助，我们只需要实现我们自己的demo_app了。</p>
<h3 id="demo-app"><a href="#demo-app" class="headerlink" title="demo_app"></a>demo_app</h3><p>demo_app接受两个参数environ和start_response，其中environ包含包含所有cgi和wsgi的参数变量，start<em>response是一个函数，参数为status和headers，返回结果为列表或\</em>_iter__的可迭代实例。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">demo_app</span><span class="params">(environ,start_response)</span>:</span></span><br><span class="line">    <span class="keyword">from</span> StringIO <span class="keyword">import</span> StringIO</span><br><span class="line">    stdout = StringIO()</span><br><span class="line">    <span class="keyword">print</span> &gt;&gt;stdout, <span class="string">"Hello world!"</span></span><br><span class="line">    <span class="keyword">print</span> &gt;&gt;stdout</span><br><span class="line">    h = environ.items(); h.sort()</span><br><span class="line">    <span class="keyword">for</span> k,v <span class="keyword">in</span> h:</span><br><span class="line">        <span class="keyword">print</span> &gt;&gt;stdout, k,<span class="string">'='</span>, repr(v)</span><br><span class="line">    start_response(<span class="string">"200 OK"</span>, [(<span class="string">'Content-Type'</span>,<span class="string">'text/plain'</span>)])</span><br><span class="line">    <span class="keyword">return</span> [stdout.getvalue()]</span><br></pre></td></tr></table></figure>
<p>实现自己的hello_app，替换demo_app即可。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_app</span><span class="params">(environ, start_response)</span>:</span></span><br><span class="line">    status = <span class="string">'200 OK'</span></span><br><span class="line">    response_headers = [(<span class="string">'Content-type'</span>, <span class="string">'text/plain'</span>)]</span><br><span class="line">    start_response(status, response_headers)</span><br><span class="line">    <span class="keyword">return</span> [<span class="string">'Hello world!\n'</span>]</span><br></pre></td></tr></table></figure>
<p>更多的基础细节请参考：<a href="http://www.tuicool.com/articles/aYBRBz" target="_blank" rel="external">http://www.tuicool.com/articles/aYBRBz</a></p>
<h2 id="simfish的实现"><a href="#simfish的实现" class="headerlink" title="simfish的实现"></a>simfish的实现</h2><p>web框架其实并不复杂，仅仅负责请求的分发和处理，让web后台开发变得简单、规范的一种方法。</p>
<p>本框架主要参考了bottle和webpy的源码。</p>
<h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><p>使用过web框架的人对路由并不陌生，路由就是用来记录url和callback function的映射关系。</p>
<p>在simfish中实现了三种添加路由的方法（装饰器、一次加载、随时添加），源码如下（具体内容参考注释）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Route</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Routes</span>:</span></span><br><span class="line">    <span class="string">"""FrameWork Routes"""</span></span><br><span class="line">    ROUTES = &#123;&#125; <span class="comment">#存储所有的url到callback function的映射</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(cls, url, handler)</span>:</span> </span><br><span class="line">        <span class="string">"""add route and handler to ROUTES"""</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> url.startswith(<span class="string">'/'</span>):</span><br><span class="line">            url = <span class="string">'/'</span> + url</span><br><span class="line">        <span class="keyword">if</span> re.match(<span class="string">r'^/(\w+/)*\w*$'</span>, url): <span class="comment">#这里需要使用re模块来获取正确的url</span></span><br><span class="line">            cls.ROUTES[url] = handler</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">match</span><span class="params">(cls, url)</span>:</span> <span class="comment">#用来寻找url对象的处理函数</span></span><br><span class="line">        <span class="string">"""match url in ROUTES"""</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> url:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        url = url.strip()</span><br><span class="line">        route = cls.ROUTES.get(url,<span class="keyword">None</span>) <span class="comment">#从ROUTES中查找结果</span></span><br><span class="line">        <span class="keyword">return</span> route</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">load_urls</span><span class="params">(cls, urls)</span>:</span> <span class="comment">#用于类似webpy中urls加载的方式</span></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> urls:</span><br><span class="line">            cls.add(item[<span class="number">0</span>], item[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">route</span><span class="params">(url, **kargs)</span>:</span> <span class="comment">#这是一个装饰器，@route('/')</span></span><br><span class="line">    <span class="string">"""Decorator for request handler. Same as Routes.route(url, handler)."""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(handler)</span>:</span></span><br><span class="line">        Routes.add(url, handler, **kargs)</span><br><span class="line">        <span class="keyword">return</span> handler</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure>
<p>具体使用方法参考：<a href="https://github.com/yxd123/simfish#routing" target="_blank" rel="external">routing</a></p>
<h3 id="封装request"><a href="#封装request" class="headerlink" title="封装request"></a>封装request</h3><p>在demo_app中的参数environ（它是一个字典啊！！！）中包含了request中需要的所有信息，那么我们需要把environ添加到request类中，</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Request</span><span class="params">(threading.local)</span>:</span></span><br><span class="line">    <span class="string">"""Represents a single request using thread-local namespace"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bind</span><span class="params">(self, environ)</span>:</span></span><br><span class="line">        <span class="string">"""Bind the enviroment"""</span></span><br><span class="line">        self._environ = environ</span><br></pre></td></tr></table></figure>
<p>添加获取请求方方法的方法，使用@propery让method方法可以直接调用，注意保持方法的大写（GET/POST）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@property</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">method</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""Returns the request method (GET,POST,PUT,DELETE,...)"""</span></span><br><span class="line">    <span class="keyword">return</span> self._environ.get(<span class="string">'REQUEST_METHOD'</span>, <span class="string">'GET'</span>).upper()</span><br></pre></td></tr></table></figure>
<p>如果获取请求参数呢？在django中使用如下的方法，</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">request.GET.get(<span class="string">'param'</span>, <span class="string">''</span>)</span><br><span class="line">request.POST.get(<span class="string">'param'</span>, <span class="string">''</span>)</span><br></pre></td></tr></table></figure>
<p>那么，我们需要把get和post的参数全部添加到一个字典中，在environ中”QUERY_STRING”包含了get的所有参数，而post的参数需要通过”wsgi.input”获取。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@property</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">GET</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""Returns a dict with GET parameters."""</span></span><br><span class="line">    <span class="keyword">if</span> self._GET <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        raw_dict = parse_qs(self.query_string, keep_blank_values=<span class="number">1</span>)</span><br><span class="line">        self._GET = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> key, value <span class="keyword">in</span> raw_dict.items():</span><br><span class="line">            <span class="keyword">if</span> len(value) == <span class="number">1</span>:</span><br><span class="line">                self._GET[key] = value[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self._GET[key] = value</span><br><span class="line">    <span class="keyword">return</span> self._GET</span><br></pre></td></tr></table></figure>
<p>其中，parse_qs是解析get参数的，推荐使用urlparse.parse_qs 和 urlparse.parse_qsl，目前cgi的已经废弃但保留是为了向后兼容。</p>
<p>与get请求不同之处，在post请求中需要调用cgi模块的FieldStorage来解析post请求参数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">raw_data = cgi.FieldStorage(fp=self._environ[<span class="string">'wsgi.input'</span>], environ=self._environ)</span><br></pre></td></tr></table></figure>
<p>具体参考源码：<a href="https://github.com/yxd123/simfish/blob/master/simfish.py" target="_blank" rel="external">simfish.py</a></p>
<h3 id="封装response"><a href="#封装response" class="headerlink" title="封装response"></a>封装response</h3><p>在这里主要实现了response-header和response-status的封装。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Response</span><span class="params">(threading.local)</span>:</span></span><br><span class="line">    <span class="string">"""Represents a single response using thread-local namespace."""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bind</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Clears old data and creates a brand new Response object"""</span></span><br><span class="line">        self.status = <span class="number">200</span></span><br><span class="line">        self.header = HeaderDict() <span class="comment">#继承dict的header类</span></span><br><span class="line">        self.header[<span class="string">'Content-type'</span>] = <span class="string">'text/plain'</span></span><br></pre></td></tr></table></figure>
<p>继承自threading.local可以保证每个每个线程拥有自己的request和response，并不会相互影响。</p>
<h3 id="实现template"><a href="#实现template" class="headerlink" title="实现template"></a>实现template</h3><p>这里使用bottle默认的模板，使用方法参考：<a href="https://github.com/yxd123/simfish#template" target="_blank" rel="external">template</a></p>
<h3 id="发送文件"><a href="#发送文件" class="headerlink" title="发送文件"></a>发送文件</h3><p>文件的发送与普通的string返回并不相同。首先，需要判断文件的权限，</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> filename.startswith(root):</span><br><span class="line">        response.status = <span class="number">401</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Access denied."</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(filename) <span class="keyword">or</span> <span class="keyword">not</span> os.path.isfile(filename):</span><br><span class="line">        response.status = <span class="number">404</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"File does not exist."</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.access(filename, os.R_OK):</span><br><span class="line">        response.status = <span class="number">401</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"You do not have permission to access this file."</span></span><br></pre></td></tr></table></figure>
<p>获取文件的类型，这里需要使用mimetypes模块，</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> mimetype:</span><br><span class="line">    response.header[<span class="string">'Content-type'</span>] = mimetype</span><br><span class="line"><span class="keyword">elif</span> guessmime:</span><br><span class="line">    guess = mimetypes.guess_type(filename)[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">if</span> guess:</span><br><span class="line">        response.header[<span class="string">'Content-type'</span>] = guess</span><br></pre></td></tr></table></figure>
<p>最后返回文件对象</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> mimetype == <span class="string">'application/octet-stream'</span> <span class="keyword">and</span> <span class="string">"Content-Disposition"</span> <span class="keyword">not</span> <span class="keyword">in</span> response.header:</span><br><span class="line">    response.header[<span class="string">"Content-Disposition"</span>] = <span class="string">"attachment;filename=%s"</span>%name</span><br><span class="line"><span class="keyword">elif</span> <span class="string">'Last-Modified'</span> <span class="keyword">not</span> <span class="keyword">in</span> response.header:</span><br><span class="line">    ts = time.gmtime(stats.st_mtime)</span><br><span class="line">    ts = time.strftime(<span class="string">"%a, %d %b %Y %H:%M:%S +0000"</span>, ts)</span><br><span class="line">    response.header[<span class="string">"Content-Length"</span>] = stats.st_size</span><br><span class="line">    response.header[<span class="string">'Last-Modified'</span>] = ts</span><br><span class="line"><span class="keyword">return</span> open(filename, <span class="string">'r'</span>)</span><br></pre></td></tr></table></figure>
<h3 id="跳转"><a href="#跳转" class="headerlink" title="跳转"></a>跳转</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Redirect to another url</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">redirect</span><span class="params">(url, code=<span class="number">307</span>)</span>:</span></span><br><span class="line">    <span class="string">""" Aborts execution and causes a 307 redirect """</span></span><br><span class="line">    response.status = code</span><br><span class="line">    response.header[<span class="string">'Location'</span>] = url</span><br><span class="line">    <span class="keyword">raise</span> SimFishException(<span class="string">""</span>)</span><br></pre></td></tr></table></figure>
<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Exceptions</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimFishException</span><span class="params">(Exception)</span>:</span></span><br><span class="line">    <span class="string">"""A base class for exception"""</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HTTPError</span><span class="params">(SimFishException)</span>:</span></span><br><span class="line">    <span class="string">"""Jump out to error handler"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, status, text)</span>:</span></span><br><span class="line">        self.output = text</span><br><span class="line">        self.http_status = status</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.output</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BreakSimFish</span><span class="params">(SimFishException)</span>:</span></span><br><span class="line">    <span class="string">"""Jump out of execution"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, text)</span>:</span></span><br><span class="line">        self.output = text</span><br></pre></td></tr></table></figure>
<h3 id="路由分发"><a href="#路由分发" class="headerlink" title="路由分发"></a>路由分发</h3><p>在上面已经有了如何添加路由，接下来就要实现路由的分发。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Simfish</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, environ, start_response)</span>:</span></span><br><span class="line">        self.environ = environ</span><br><span class="line">        self.start = start_response</span><br><span class="line">        request.bind(environ) <span class="comment">#绑定request和response</span></span><br><span class="line">        response.bind()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        path = request.path</span><br><span class="line">        handler = Routes.match(path) <span class="comment">#Routes类中的match方法，获取处理的callback function</span></span><br><span class="line">        result = <span class="string">""</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> handler:</span><br><span class="line">            response.status = <span class="number">404</span></span><br><span class="line">            result = <span class="string">"not Found"</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                result = handler(request)</span><br><span class="line">            <span class="keyword">except</span> SimFishException,output: <span class="comment">#捕获异常情况</span></span><br><span class="line">                result = output</span><br><span class="line">        <span class="keyword">if</span> isinstance(result, tuple) <span class="keyword">and</span> len(result) == <span class="number">2</span>: <span class="comment">#返回(response_string, mimetype)，自定义返回类型</span></span><br><span class="line">            response.header[<span class="string">'Content-type'</span>] = result[<span class="number">1</span>]</span><br><span class="line">            result = result[<span class="number">0</span>]</span><br><span class="line">        status = <span class="string">'%d %s'</span> % (response.status, HTTP_CODES[response.status]) <span class="comment">#获取返回status</span></span><br><span class="line">        self.start(status, list(response.header.items())) <span class="comment">#调用start_response</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> hasattr(result, <span class="string">'read'</span>): <span class="comment">#用于返回文件</span></span><br><span class="line">            <span class="keyword">if</span> <span class="string">'wsgi.file_wrapper'</span> <span class="keyword">in</span> self.environ:</span><br><span class="line">                <span class="keyword">return</span> self.environ[<span class="string">'wsgi.file_wrapper'</span>](result)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> iter(<span class="keyword">lambda</span>: result.read(<span class="number">8192</span>), <span class="string">''</span>)</span><br><span class="line">            <span class="keyword">return</span> iter(<span class="keyword">lambda</span>: result.read(<span class="number">8192</span>), <span class="string">''</span>)</span><br><span class="line">        <span class="keyword">elif</span> isinstance(result, basestring):</span><br><span class="line">            <span class="keyword">return</span> iter([result])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> iter(result)</span><br></pre></td></tr></table></figure>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># encoding:utf8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> simfish <span class="keyword">import</span> application, route</span><br><span class="line"></span><br><span class="line"><span class="meta">@route('/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"hello world"</span></span><br><span class="line"></span><br><span class="line">app = application(port=<span class="number">8086</span>)</span><br><span class="line">app.run()</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.tuicool.com/articles/aYBRBz" target="_blank" rel="external">http://www.tuicool.com/articles/aYBRBz</a><br><a href="http://www.bottlepy.org/docs/dev/index.html" target="_blank" rel="external">http://www.bottlepy.org/docs/dev/index.html</a><br><a href="http://webpy.org/" target="_blank" rel="external">http://webpy.org/</a></p>
]]></content>
      
        <categories>
            
            <category> python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> framework </tag>
            
            <tag> python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[python sort]]></title>
      <url>/2015/04/18/python-sort/</url>
      <content type="html"><![CDATA[<p><code>python</code>不仅提供了<code>list.sort()</code>方法来实现列表的排序，而且提供了内建<code>sorted()</code>函数来实现对复杂列表的排序以及按照字典的key和value进行排序。<br><a id="more"></a></p>
<h2 id="sorted函数原型"><a href="#sorted函数原型" class="headerlink" title="sorted函数原型"></a>sorted函数原型</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sorted(data, cmp=None, key=None, reverse=False)  </span><br><span class="line">#data为数据</span><br><span class="line">#cmp和key均为比较函数</span><br><span class="line">#reverse为排序方向，True为倒序，False为正序</span><br></pre></td></tr></table></figure>
<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><h3 id="对于列表"><a href="#对于列表" class="headerlink" title="对于列表"></a>对于列表</h3><p>直接进行排序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; sorted([5, 2, 3, 1, 4])</span><br><span class="line">[1, 2, 3, 4, 5]</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; a = [5, 2, 3, 1, 4]</span><br><span class="line">&gt;&gt;&gt; a.sort()</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">[1, 2, 3, 4, 5]</span><br></pre></td></tr></table></figure>
<h3 id="对于字典"><a href="#对于字典" class="headerlink" title="对于字典"></a>对于字典</h3><p>只对key进行排序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sorted(&#123;1: &apos;D&apos;, 2: &apos;B&apos;, 3: &apos;B&apos;, 4: &apos;E&apos;, 5: &apos;A&apos;&#125;)</span><br><span class="line">[1, 2, 3, 4, 5]</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">### key函数</span><br><span class="line"></span><br><span class="line">key函数应该接受一个参数并返回一个用于排序的key值。由于该函数只需要调用一次，因而排序速度较快。</span><br><span class="line"></span><br><span class="line">复杂列表</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<blockquote>
<p>student_tuples = [<br>    (‘john’, ‘A’, 15),<br>    (‘jane’, ‘B’, 12),<br>    (‘dave’, ‘B’, 10),<br>]<br>sorted(student_tuples, key=lambda student: student[2])   # sort by age<br>[(‘dave’, ‘B’, 10), (‘jane’, ‘B’, 12), (‘john’, ‘A’, 15)]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">如果列表内容是类的话，</span><br></pre></td></tr></table></figure></p>
<p>class Student:<br>        def <strong>init</strong>(self, name, grade, age):<br>            self.name = name<br>            self.grade = grade<br>            self.age = age<br>        def <strong>repr</strong>(self):<br>            return repr((self.name, self.grade, self.age))<br>student_objects = [<br>    Student(‘john’, ‘A’, 15),<br>    Student(‘jane’, ‘B’, 12),<br>    Student(‘dave’, ‘B’, 10),<br>]<br>sorted(student_objects, key=lambda student: student.age)   # sort by age<br>[(‘dave’, ‘B’, 10), (‘jane’, ‘B’, 12), (‘john’, ‘A’, 15)]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">字典</span><br></pre></td></tr></table></figure></p>
<p>student = [ {“name”:”xiaoming”, “score”:60}, {“name”:”daxiong”, “score”:20},<br> {“name”:”maodou”, “score”:30},<br> ]<br>student<br>[{‘score’: 60, ‘name’: ‘xiaoming’}, {‘score’: 20, ‘name’: ‘daxiong’}, {‘score’: 30, ‘name’: ‘maodou’}]<br>sorted(student, key=lambda d:d[“score”])<br>[{‘score’: 20, ‘name’: ‘daxiong’}, {‘score’: 30, ‘name’: ‘maodou’}, {‘score’: 60, ‘name’: ‘xiaoming’}]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">此外，Python提供了operator.itemgetter和attrgetter提高执行速度。</span><br></pre></td></tr></table></figure></p>
<p>from operator import itemgetter, attrgetter<br>student = [<br> (“xiaoming”,60),<br> (“daxiong”, 20),<br> (“maodou”, 30}]<br>sorted(student, key=lambda d:d[1])<br>[(‘daxiong’, 20), (‘maodou’, 30), (‘xiaoming’, 60)]<br>sorted(student, key=itemgetter(1))<br>[(‘daxiong’, 20), (‘maodou’, 30), (‘xiaoming’, 60)]</p>
</blockquote>
</blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">operator提供了多个字段的复杂排序。</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<blockquote>
<p>sorted(student, key=itemgetter(0,1)) #根据第一个字段和第二个字段<br>[(‘daxiong’, 20), (‘maodou’, 30), (‘xiaoming’, 60)]<br>operator.methodcaller()函数会按照提供的函数来计算排序。</p>
<p>messages = [‘critical!!!’, ‘hurry!’, ‘standby’, ‘immediate!!’]<br>sorted(messages, key=methodcaller(‘count’, ‘!’))<br>[‘standby’, ‘hurry!’, ‘immediate!!’, ‘critical!!!’]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">首先通过count函数对&quot;!&quot;来计算出现次数，然后按照出现次数进行排序。</span><br><span class="line"></span><br><span class="line">### CMP</span><br><span class="line"></span><br><span class="line">cmp参数是Python2.4之前使用的排序方法。</span><br></pre></td></tr></table></figure></p>
</blockquote>
</blockquote>
</blockquote>
<p>def numeric_compare(x, y):<br>        return x - y</p>
<blockquote>
<blockquote>
<blockquote>
<p>sorted([5, 2, 4, 1, 3], cmp=numeric_compare)<br>[1, 2, 3, 4, 5]<br>def reverse_numeric(x, y):<br>        return y - x<br>sorted([5, 2, 4, 1, 3], cmp=reverse_numeric)<br>[5, 4, 3, 2, 1]<br>在functools.cmp_to_key函数提供了比较功能</p>
<p>sorted([5, 2, 4, 1, 3], key=cmp_to_key(reverse_numeric))<br>[5, 4, 3, 2, 1]</p>
</blockquote>
</blockquote>
</blockquote>
<p>def cmp_to_key(mycmp):<br>    ‘Convert a cmp= function into a key= function’<br>    class K(object):<br>        def <strong>init</strong>(self, obj, *args):<br>            self.obj = obj<br>        def <strong>lt</strong>(self, other):<br>            return mycmp(self.obj, other.obj) &lt; 0<br>        def <strong>gt</strong>(self, other):<br>            return mycmp(self.obj, other.obj) &gt; 0<br>        def <strong>eq</strong>(self, other):<br>            return mycmp(self.obj, other.obj) == 0<br>        def <strong>le</strong>(self, other):<br>            return mycmp(self.obj, other.obj) &lt;= 0<br>        def <strong>ge</strong>(self, other):<br>            return mycmp(self.obj, other.obj) &gt;= 0<br>        def <strong>ne</strong>(self, other):<br>            return mycmp(self.obj, other.obj) != 0<br>    return K<br>```</p>
]]></content>
      
        <categories>
            
            <category> python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[python propety]]></title>
      <url>/2015/04/16/python-propety/</url>
      <content type="html"><![CDATA[<p>在2.6版本中，添加了一种新的类成员函数的访问方式–property。<br><a id="more"></a></p>
<h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class property([fget[, fset[, fdel[, doc]]]])</span><br><span class="line">fget：获取属性</span><br><span class="line"></span><br><span class="line">fset：设置属性</span><br><span class="line"></span><br><span class="line">fdel：删除属性</span><br><span class="line"></span><br><span class="line">doc：属性含义</span><br></pre></td></tr></table></figure>
<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><h3 id="让成员函数通过属性方式调用"><a href="#让成员函数通过属性方式调用" class="headerlink" title="让成员函数通过属性方式调用"></a>让成员函数通过属性方式调用</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._x = <span class="keyword">None</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getx</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._x</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setx</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        self._x = value</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delx</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">del</span> self._x</span><br><span class="line">    x = property(getx, setx, delx, <span class="string">"I'm the 'x' property."</span>)</span><br><span class="line">a = C()</span><br><span class="line"><span class="keyword">print</span> C.x.__doc__ <span class="comment">#打印doc</span></span><br><span class="line"><span class="keyword">print</span> a.x <span class="comment">#调用a.getx()</span></span><br><span class="line"></span><br><span class="line">a.x = <span class="number">100</span> <span class="comment">#调用a.setx()</span></span><br><span class="line"><span class="keyword">print</span> a.x</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">del</span> a.x <span class="comment">#调用a.delx()</span></span><br><span class="line">    <span class="keyword">print</span> a.x <span class="comment">#已被删除，报错</span></span><br><span class="line"><span class="keyword">except</span> Exception, e:</span><br><span class="line">    <span class="keyword">print</span> e</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">I&apos;m the &apos;x&apos; property.</span><br><span class="line">None</span><br><span class="line">100</span><br><span class="line">&apos;C&apos; object has no attribute &apos;_x&apos;</span><br></pre></td></tr></table></figure>
<h3 id="利用property装饰器，让成员函数称为只读的"><a href="#利用property装饰器，让成员函数称为只读的" class="headerlink" title="利用property装饰器，让成员函数称为只读的"></a>利用property装饰器，让成员函数称为只读的</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parrot</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._voltage = <span class="number">100000</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">voltage</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Get the current voltage."""</span></span><br><span class="line">        <span class="keyword">return</span> self._voltage</span><br><span class="line"></span><br><span class="line">a = Parrot()</span><br><span class="line"><span class="keyword">print</span> a.voltage <span class="comment">#通过属性调用voltage函数</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">print</span> a.voltage() <span class="comment">#不允许调用函数，为只读的</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="keyword">print</span> e</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">100000</span><br><span class="line">&apos;int&apos; object is not callable</span><br></pre></td></tr></table></figure>
<h3 id="利用property装饰器实现property函数的功能"><a href="#利用property装饰器实现property函数的功能" class="headerlink" title="利用property装饰器实现property函数的功能"></a>利用property装饰器实现property函数的功能</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._x = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">x</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""I'm the 'x' property."""</span></span><br><span class="line">        <span class="keyword">return</span> self._x</span><br><span class="line"></span><br><span class="line"><span class="meta">    @x.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">x</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        self._x = value</span><br><span class="line"></span><br><span class="line"><span class="meta">    @x.deleter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">x</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">del</span> self._x</span><br></pre></td></tr></table></figure>
<h2 id="其他应用"><a href="#其他应用" class="headerlink" title="其他应用"></a>其他应用</h2><h3 id="bottle源码中的应用"><a href="#bottle源码中的应用" class="headerlink" title="bottle源码中的应用"></a>bottle源码中的应用</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Request</span><span class="params">(threading.local)</span>:</span></span><br><span class="line">    <span class="string">""" Represents a single request using thread-local namespace. """</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">method</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">''' Returns the request method (GET,POST,PUT,DELETE,...) '''</span></span><br><span class="line">        <span class="keyword">return</span> self._environ.get(<span class="string">'REQUEST_METHOD'</span>, <span class="string">'GET'</span>).upper()</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">query_string</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">''' Content of QUERY_STRING '''</span></span><br><span class="line">        <span class="keyword">return</span> self._environ.get(<span class="string">'QUERY_STRING'</span>, <span class="string">''</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">input_length</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">''' Content of CONTENT_LENGTH '''</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> int(self._environ.get(<span class="string">'CONTENT_LENGTH'</span>, <span class="string">'0'</span>))</span><br><span class="line">        <span class="keyword">except</span> ValueError:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">COOKIES</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Returns a dict with COOKIES."""</span></span><br><span class="line">        <span class="keyword">if</span> self._COOKIES <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            raw_dict = Cookie.SimpleCookie(self._environ.get(<span class="string">'HTTP_COOKIE'</span>,<span class="string">''</span>))</span><br><span class="line">            self._COOKIES = &#123;&#125;</span><br><span class="line">            <span class="keyword">for</span> cookie <span class="keyword">in</span> raw_dict.values():</span><br><span class="line">                self._COOKIES[cookie.key] = cookie.value</span><br><span class="line">        <span class="keyword">return</span> self._COOKIES</span><br></pre></td></tr></table></figure>
<h3 id="在django-model中的应用，实现连表查询"><a href="#在django-model中的应用，实现连表查询" class="headerlink" title="在django model中的应用，实现连表查询"></a>在django model中的应用，实现连表查询</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">     name = models.CharField(max_length=<span class="number">30</span>)</span><br><span class="line">     tel = models.CharField(max_length=<span class="number">30</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Score</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">      pid = models.IntegerField()</span><br><span class="line">      score = models.IntegerField()</span><br><span class="line">      </span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">get_person_name</span><span class="params">()</span>:</span></span><br><span class="line">            <span class="keyword">return</span> Person.objects.get(id=pid)</span><br><span class="line"></span><br><span class="line">       name = property(get_person_name) <span class="comment">#name称为Score表的属性，通过与Person表联合查询获取name</span></span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python _、__和__xx__的区别]]></title>
      <url>/2015/04/13/python-xx/</url>
      <content type="html"><![CDATA[<p>本文为译文，版权属于原作者，在此翻译为中文分享给大家。英文原文地址：<a href="http://igorsobreira.com/2010/09/16/difference-between-one-underline-and-two-underlines-in-python.html" target="_blank" rel="external">Difference between _, __ and __xx__ in Python</a><br><a id="more"></a></p>
<h2 id="“-“单下划线"><a href="#“-“单下划线" class="headerlink" title="“_“单下划线"></a>“_“单下划线</h2><p>Python中不存在真正的私有方法。为了实现类似于c++中私有方法，可以在类的方法或属性前加一个“_”单下划线，意味着该方法或属性不应该去调用，它并不属于API。</p>
<p>在使用property时，经常出现这个问题：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseForm</span><span class="params">(StrAndUnicode)</span>:</span></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_get_errors</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"Returns an ErrorDict for the data provided for the form"</span></span><br><span class="line">        <span class="keyword">if</span> self._errors <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            self.full_clean()</span><br><span class="line">        <span class="keyword">return</span> self._errors</span><br><span class="line">    </span><br><span class="line">    errors = property(_get_errors)</span><br></pre></td></tr></table></figure>
<p>上面的代码片段来自于django源码（django/forms/forms.py）。这里的errors是一个属性，属于API的一部分，但是_get_errors是私有的，是不应该访问的，但可以通过errors来访问该错误结果。</p>
<h2 id="“-“双下划线"><a href="#“-“双下划线" class="headerlink" title="“__“双下划线"></a>“__“双下划线</h2><p>这个双下划线更会造成更多混乱，但它并不是用来标识一个方法或属性是私有的，真正作用是用来避免子类覆盖其内容。</p>
<p>让我们来看一个例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__method</span><span class="params">(self)</span>:</span> </span><br><span class="line">        <span class="keyword">print</span> <span class="string">"I'm a method in A"</span> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">method</span><span class="params">(self)</span>:</span> </span><br><span class="line">        self.__method() a = A() a.method()</span><br></pre></td></tr></table></figure>
<p>输出是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python example.py </span><br><span class="line">I&apos;m a method in A</span><br></pre></td></tr></table></figure>
<p>很好，出现了预计的结果。</p>
<p>我们给A添加一个子类，并重新实现一个__method：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__method</span><span class="params">(self)</span>:</span> </span><br><span class="line">        <span class="keyword">print</span> <span class="string">"I'm a method in B"</span> </span><br><span class="line"></span><br><span class="line">b = B() </span><br><span class="line">b.method()</span><br></pre></td></tr></table></figure>
<p>现在，结果是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python example.py</span><br><span class="line">I&apos;m a method in A</span><br></pre></td></tr></table></figure>
<p>就像我们看到的一样，B.method()不能调用B._<em>method的方法。实际上，它是”\</em>_“两个下划线的功能的正常显示。</p>
<p>因此，在我们创建一个以”__“两个下划线开始的方法时，这意味着这个方法不能被重写，它只允许在该类的内部中使用。</p>
<p>在Python中如是做的？很简单，它只是把方法重命名了，如下： </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = A()</span><br><span class="line">a._A__method()  <span class="comment"># never use this!! please!</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python example.py </span><br><span class="line">I&apos;m a method in A</span><br></pre></td></tr></table></figure>
<p>如果你试图调用a.__method，它还是无法运行的，就如上面所说，只可以在类的内部调用__method。</p>
<h2 id="“-xx-“前后各双下划线"><a href="#“-xx-“前后各双下划线" class="headerlink" title="“__xx__“前后各双下划线"></a>“__xx__“前后各双下划线</h2><p>当你看到”__this__“的时，就知道不要调用它。为什么？因为它的意思是它是用于Python调用的，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; name = &quot;igor&quot; </span><br><span class="line">&gt;&gt;&gt; name.__len__() 4 </span><br><span class="line">&gt;&gt;&gt; len(name) 4 </span><br><span class="line">&gt;&gt;&gt; number = 10 </span><br><span class="line">&gt;&gt;&gt; number.__add__(20) 30 </span><br><span class="line">&gt;&gt;&gt; number + 20 30</span><br></pre></td></tr></table></figure>
<p>“__xx__”经常是操作符或本地函数调用的magic methods。在上面的例子中，提供了一种重写类的操作符的功能。</p>
<p>在特殊的情况下，它只是python调用的hook。例如，__init__()函数是当对象被创建初始化时调用的;__new__()是用来创建实例。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CrazyNumber</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, n)</span>:</span> </span><br><span class="line">        self.n = n </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__add__</span><span class="params">(self, other)</span>:</span> </span><br><span class="line">        <span class="keyword">return</span> self.n - other </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__sub__</span><span class="params">(self, other)</span>:</span> </span><br><span class="line">        <span class="keyword">return</span> self.n + other </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span> </span><br><span class="line">        <span class="keyword">return</span> str(self.n) </span><br><span class="line"></span><br><span class="line">num = CrazyNumber(<span class="number">10</span>) </span><br><span class="line"><span class="keyword">print</span> num <span class="comment"># 10</span></span><br><span class="line"><span class="keyword">print</span> num + <span class="number">5</span> <span class="comment"># 5</span></span><br><span class="line"><span class="keyword">print</span> num - <span class="number">20</span> <span class="comment"># 30</span></span><br></pre></td></tr></table></figure>
<p>另一个例子</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Room</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span> </span><br><span class="line">        self.people = [] </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, person)</span>:</span> </span><br><span class="line">        self.people.append(person) </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span> </span><br><span class="line">        <span class="keyword">return</span> len(self.people)</span><br><span class="line"> </span><br><span class="line">room = Room() </span><br><span class="line">room.add(<span class="string">"Igor"</span>) </span><br><span class="line"><span class="keyword">print</span> len(room) <span class="comment"># 1</span></span><br></pre></td></tr></table></figure>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><ul>
<li>使用_one_underline来表示该方法或属性是私有的，不属于API；</li>
<li>当创建一个用于python调用或一些特殊情况时，使用__two_underline__；</li>
<li>使用__just_to_underlines，来避免子类的重写！</li>
</ul>
]]></content>
      
        <categories>
            
            <category> python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[redis（二）高级用法]]></title>
      <url>/2015/04/08/redis-advance-usage/</url>
      <content type="html"><![CDATA[<p>介绍redis高级用法。<br><a id="more"></a></p>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>redis的事务是一组命令的集合。事务同命令一样都是redis的最小执行单元，一个事务中的命令要么执行要么都不执行。</p>
<p>首先需要multi命令来开始事务，用exec命令来执行事务。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; hset user:1 name xiaoming</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; hset user:1 name daxiong</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; exec</span><br><span class="line">1) (integer) 0</span><br><span class="line">2) (integer) 0</span><br><span class="line">127.0.0.1:6379&gt; hgetall user:1</span><br><span class="line">1) &quot;name&quot;</span><br><span class="line">2) &quot;daxiong&quot;</span><br><span class="line">3) &quot;score&quot;</span><br><span class="line">4) &quot;61&quot;</span><br></pre></td></tr></table></figure></p>
<p>multi代表事务的开始，返回ok表示成功；</p>
<p>exec代表事务的执行，返回各个命令的执行结果；</p>
<p>在multi和exec中间添加需要执行的命令。</p>
<p>在multi开始后，所有命令都不会执行，而是全部暂时保存起来，在执行exec命令后会按照命令保存的顺序依次执行各个命令。</p>
<p>如果事务执行过程中存在失败的情况下（某一个命令执行失败后其他命令会继续执行），需要开发人员自行处理后果。</p>
<p>注意：redis不支持回滚操作，导致redis的错误异常需要开发人员处理。</p>
<h2 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h2><p>watch命令可以监控一个或多个键值的变化，一旦其中一个键被改变，之后的事务就不会执行，而且监控会一直持续到exec命令。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set key 1</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; watch key</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set key 2</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set key 3</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; exec</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; get key</span><br><span class="line">&quot;2&quot;</span><br></pre></td></tr></table></figure></p>
<h3 id="生存时间"><a href="#生存时间" class="headerlink" title="生存时间"></a>生存时间</h3><p>（1）设置key的超时时间，超时后redis会自动删除给key值，类似于memcache中的超时时间。<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">expire     key     seconds</span><br><span class="line">//设置成功返回1，失败返回0</span><br><span class="line">127.0.0.1:6379&gt; set session:aabb uid1122</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; expire session:aabb 300</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; del session:aabb</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; expire session:aabb 300</span><br><span class="line">(integer) 0</span><br><span class="line"> </span><br><span class="line">127.0.0.1:6379&gt; expire session:aabb 300</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; ttl session:aabb </span><br><span class="line">(integer) 290</span><br></pre></td></tr></table></figure></p>
<p>（2）查询剩余超时时间<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ttl     key</span><br><span class="line">127.0.0.1:6379&gt; expire session:aabb 300</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; ttl session:aabb </span><br><span class="line">(integer) 290</span><br></pre></td></tr></table></figure></p>
<p>（3）取消超时时间<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; get session:aabb</span><br><span class="line">&quot;300&quot;</span><br><span class="line">127.0.0.1:6379&gt; ttl session:aabb </span><br><span class="line">(integer) 280</span><br><span class="line">127.0.0.1:6379&gt; persist session:aabb</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; ttl session:aabb</span><br><span class="line">(integer) -1</span><br></pre></td></tr></table></figure></p>
<p>（4）如果使用设置相关的命令，会取消该键的超时间</p>
<h2 id="缓存数据"><a href="#缓存数据" class="headerlink" title="缓存数据"></a>缓存数据</h2><p>在某些情况下，需要缓存一部分网站数据，而网站数据由需要持续的更新（假如需要两个小时更新一次），那么可以采用redis进行缓存这部分数据，设置数据的超时时间为2小时，每当有请求访问的时候首先到redis中查找该数据是否存在，如果存在直接读取，如果不存在的话重新从数据库中读取该数据加载到redis中。</p>
<p>在缓存数据的时候需要考虑到被缓存数据的大小，如果缓存数据较大，会占用过多的内存资源，有必要在配置文件中限制内存的使用大小（maxmemory）。</p>
<p>当超过maxmemory的限制后，redis会根据maxmemory-policy参数指定的策略（包括LRU等算法）来删除不需要的键。</p>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>sort命令支持对集合类型、类表类型、有序集合类型进行排序。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lpush list 1 2 6 3 4 9 8</span><br><span class="line">(integer) 7</span><br><span class="line">127.0.0.1:6379&gt; sort list</span><br><span class="line">1) &quot;1&quot;</span><br><span class="line">2) &quot;2&quot;</span><br><span class="line">3) &quot;3&quot;</span><br><span class="line">4) &quot;4&quot;</span><br><span class="line">5) &quot;6&quot;</span><br><span class="line">6) &quot;8&quot;</span><br><span class="line">7) &quot;9&quot;</span><br></pre></td></tr></table></figure></p>
<p>可以对有序集合的值进行排序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd set 50 2 40 3 20 1 60 5</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; sort set</span><br><span class="line">1) &quot;1&quot;</span><br><span class="line">2) &quot;2&quot;</span><br><span class="line">3) &quot;3&quot;</span><br><span class="line">4) &quot;5&quot;</span><br></pre></td></tr></table></figure></p>
<p>sort命令可以添加desc来实现倒序排序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sort set desc</span><br><span class="line">1) &quot;5&quot;</span><br><span class="line">2) &quot;3&quot;</span><br><span class="line">3) &quot;2&quot;</span><br><span class="line">4) &quot;1&quot;</span><br></pre></td></tr></table></figure></p>
<h2 id="BY参数"><a href="#BY参数" class="headerlink" title="BY参数"></a>BY参数</h2><p>很多时候我们需要根据ID对应的对象的某一个属性进行排序，那么如何才能把多个不同的数据进行关联查询呢？<br>（1）首先，向userids中添加三个用户id<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lpush userids 1 2 3</span><br><span class="line">(integer) 3</span><br></pre></td></tr></table></figure></p>
<p>（2）其次，分别对三个用户添加分数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set user_score_1 50</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set user_score_2 30</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set user_score_3 70</span><br><span class="line">OK</span><br></pre></td></tr></table></figure></p>
<p>（3）最后，使用sort、by命令来对对用户按照默认情况以及分数的递增和递减进行排序。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sort userids</span><br><span class="line">1) &quot;1&quot;</span><br><span class="line">2) &quot;2&quot;</span><br><span class="line">3) &quot;3&quot;</span><br><span class="line">127.0.0.1:6379&gt; sort userids by user_score_*</span><br><span class="line">1) &quot;2&quot;</span><br><span class="line">2) &quot;1&quot;</span><br><span class="line">3) &quot;3&quot;</span><br><span class="line">127.0.0.1:6379&gt; sort userids by user_score_* desc</span><br><span class="line">1) &quot;3&quot;</span><br><span class="line">2) &quot;1&quot;</span><br><span class="line">3) &quot;2&quot;</span><br></pre></td></tr></table></figure></p>
<h2 id="GET参数"><a href="#GET参数" class="headerlink" title="GET参数"></a>GET参数</h2><p>get参数并不影响排序，它的作用是使sort命令返回的结果不再是元素自身的值，而是get参数中指定的键值，同by参数一样，支持字符串类型和散列类型的键。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sort userids by user_score_* get user_name_*</span><br><span class="line">1) &quot;xiaoming&quot;</span><br><span class="line">2) &quot;daxiong&quot;</span><br><span class="line">3) &quot;xiaohong&quot;</span><br><span class="line">127.0.0.1:6379&gt; sort userids by user_score_* desc get user_name_*</span><br><span class="line">1) &quot;xiaohong&quot;</span><br><span class="line">2) &quot;daxiong&quot;</span><br><span class="line">3) &quot;xiaoming&quot;</span><br></pre></td></tr></table></figure></p>
<h2 id="STORE参数"><a href="#STORE参数" class="headerlink" title="STORE参数"></a>STORE参数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">store参数用于结果保存。</span><br><span class="line"> </span><br><span class="line">sort命令是redis的复杂命令之一，使用不好会造成性能的瓶颈。</span><br><span class="line"> </span><br><span class="line">sort命令的时间复杂度是O（n+mlog(m)），其中n是排序列表（集合和有序集合）中元素的个数，m是返回元素的个数。Redis在排序前会建立一个长度为n的的容器来存储待排序元素，虽然是一个临时的过程，但是多个较大数据的排序操作则会严重影响系统的性能。</span><br><span class="line"> </span><br><span class="line">因此，在开发中需要注意：</span><br><span class="line">（1）尽可能减少排序键中的元素个数，降低n</span><br><span class="line">（2）使用Limit参数只获取需要的数据，降低n</span><br><span class="line">（3）如果要排序的数据量较大，尽可能使用store名来缓存结果。</span><br></pre></td></tr></table></figure>
<h2 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h2><p>任务队列一般适用于生产者和消费者之间通信的，那么在redis中很容易想到使用列表类型来实现任务队列，具体方法是创建一个任务队列，生产者主动lpush数据，而消费者去rpop数据，保持一个先进先出的循序。<br>但是这样存在一个问题，消费者需要主动去请求数据，周期性的请求会造成资源的浪费，因此，redis提供了一个brpop的命令来解决这个问题。<br>BRPOP     key     timeout<br>brpop命令接收两个参数，第一个参数key为键值，第二个参数timeout为超时时间。BRPOP命令取数据时候，如果暂时不存在数据，该命令会一直阻塞直到达到超时时间。如果timeout设置为0，那么就会无限等待下去。<br>优先级队列</p>
<p>基于任务队列，如何实现优先级队列呢？</p>
<p>那么可以选择多个任务队列，而每个任务队列的任务优先级是不同的。</p>
<p>redis提供了下面的命令，会从左边第一个key开始读下去知道返回一个数据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brpop key [key...] timetout</span><br></pre></td></tr></table></figure></p>
<h2 id="发布-订阅模式"><a href="#发布-订阅模式" class="headerlink" title="发布/订阅模式"></a>发布/订阅模式</h2><p>redis提供了rabitmq类似的发布订阅模式，通过生产者使用下面的命令来发布消息，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PUBLISH     CHANNEL     MESSAGE</span><br></pre></td></tr></table></figure></p>
<p>消费者通过下面的消息来订阅消息，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SUBSCRIBE     CHANNEL     MESSAGE</span><br></pre></td></tr></table></figure></p>
<p>生产者：<br><strong>向channel.test发布消息</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; publish channel.test hello</span><br><span class="line">(integer) 0 #返回0表明订阅者为0，没有发布消息</span><br><span class="line">127.0.0.1:6379&gt; publish channel.test hello</span><br><span class="line">(integer) 1 #返回n表明订阅者为n，成功发布给1个消费者</span><br></pre></td></tr></table></figure></p>
<p>消费者：<br><strong>订阅channel.test消息</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; subscribe channel.test </span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) &quot;subscribe&quot;</span><br><span class="line">2) &quot;channel.test&quot;</span><br><span class="line">3) (integer) 1</span><br><span class="line">#接收到来自channel.test的消息</span><br><span class="line">1) &quot;message&quot;</span><br><span class="line">2) &quot;channel.test&quot;</span><br><span class="line">3) &quot;hello&quot;</span><br></pre></td></tr></table></figure></p>
<h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p>redis的底层通信协议对管道提供了支持。通过管道可以一次性发送多条命令并在执行完后一次性将结果返回，当一组命令中每条命令都不依赖之前命令的执行结果时就可以将这组命令一起通过管道发出。管道通过减少客户端与redis的通信次数来实现降低往返实验累计值的目的。<br>节省空间</p>
<p>（1）精简键名和键值<br>（2）redis为每种数据类型提供了两种内部编码。例如散列类型的存储是通过散列表来实现的，redis会根据数据的多少来选择编码类型，当数据较少的时候会采用紧凑但性能稍差的内部编码方式，而数据变多时会把编码方式改为散列表。</p>
]]></content>
      
        <categories>
            
            <category> cache </category>
            
        </categories>
        
        
        <tags>
            
            <tag> redis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[redis（一） 安装以及基本数据类型操作]]></title>
      <url>/2015/04/04/redis-install-base-op/</url>
      <content type="html"><![CDATA[<p>介绍redis基本用法。<br><a id="more"></a></p>
<h2 id="redis安装和使用"><a href="#redis安装和使用" class="headerlink" title="redis安装和使用"></a>redis安装和使用</h2><h3 id="redis安装"><a href="#redis安装" class="headerlink" title="redis安装"></a>redis安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget http://download.redis.io/redis-stable.tar.gz</span><br><span class="line">tar zxvf redis-stable.tar.gz</span><br><span class="line">cd redis-stable.tar.gz</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<h3 id="redis启动"><a href="#redis启动" class="headerlink" title="redis启动"></a>redis启动</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis-server</span><br><span class="line">redis关闭</span><br><span class="line">redis-cli shutdown</span><br></pre></td></tr></table></figure>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>方法一<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis-server /path/to/redis.conf</span><br><span class="line">redis-server /path/to/redis.conf --loglevel warning //设置日志级别</span><br></pre></td></tr></table></figure></p>
<p>方法二<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis-cli</span><br><span class="line">redis &gt; CONFIG SET loglevel warning</span><br></pre></td></tr></table></figure></p>
<h3 id="多数据库的选择"><a href="#多数据库的选择" class="headerlink" title="多数据库的选择"></a>多数据库的选择</h3><p>默认情况下，客户端自动选择0号数据库。<br>可以使用select命令来选择其他数据库。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select 1</span><br></pre></td></tr></table></figure></p>
<p>redis不可以设置数据库的名称，数据库是通过编号来使用的。<br>redis只有一个全局的密码，不存在访问某个数据库的密码。</p>
<h2 id="数据库基本操作"><a href="#数据库基本操作" class="headerlink" title="数据库基本操作"></a>数据库基本操作</h2><p>（1）添加数据和查找数据，通过set/get命令添加和获取数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; select 1</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[1]&gt; set bar 1</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[1]&gt; get bar</span><br><span class="line">&quot;1&quot;</span><br><span class="line">127.0.0.1:6379[1]&gt; get aaa</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure></p>
<p>（2）判断一个键是否存在，exists命令可以判断key是否存在，存在返回1，不存在返回0<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379[1]&gt; exists bar</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379[1]&gt; exists aaa</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure></p>
<p>（3）删除数据，del命令删除key，返回值为成功删除key的个数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379[1]&gt; del aaa</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379[1]&gt; del bar</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure></p>
<p>（4）获取value的类型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379[1]&gt; set bar 1</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[1]&gt; type bar</span><br><span class="line">string</span><br></pre></td></tr></table></figure></p>
<p>（5）自增和自减，incr 、decr以及incrby和decrby实现整数的加减<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379[1]&gt; INCR ab</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379[1]&gt; INCR ab</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379[1]&gt; INCRBY ab 2</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379[1]&gt; DECR ab</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379[1]&gt; DECRBY ab 2</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure></p>
<p>（6）增加指定浮点数，incrbyfloat可以指定自增的浮点数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379[1]&gt; INCRBYFLOAT ab 1.1</span><br><span class="line">&quot;2.1&quot;</span><br></pre></td></tr></table></figure></p>
<p>（7）向尾部追加，append命令可以向字符尾部追加内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379[1]&gt; set key hello</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[1]&gt; append key world</span><br><span class="line">(integer) 10</span><br><span class="line">127.0.0.1:6379[1]&gt; get key</span><br><span class="line">&quot;helloworld&quot;</span><br></pre></td></tr></table></figure></p>
<p>（8）获取字符串长度，strlen获取value的长度<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379[1]&gt; STRLEN key</span><br><span class="line">(integer) 10</span><br></pre></td></tr></table></figure></p>
<p>（9）批量设置和获取，通过mset和mget命令可以批量执行设置和获取<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379[1]&gt; mset key1 va1 key2 va2</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[1]&gt; mget key1 key2</span><br><span class="line">1) &quot;va1&quot;</span><br><span class="line">2) &quot;va2&quot;</span><br></pre></td></tr></table></figure></p>
<p>（10）位操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">getbit key offset</span><br><span class="line">setbit key offset</span><br><span class="line">bitcount key [start] [end]</span><br><span class="line">bitop operation destkey key [key ...]</span><br></pre></td></tr></table></figure></p>
<h2 id="散列类型"><a href="#散列类型" class="headerlink" title="散列类型"></a>散列类型</h2><p>其实这里的散列类型就是类似于非结构化数据，json数据一样。<br>{<br>    “id”:1,<br>    “name”:”test”<br>}</p>
<h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p>（1）存储方法，可以通过hset和hget来设置和获取数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379[1]&gt; hset user id 1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379[1]&gt; hset user name test</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379[1]&gt; hget user id</span><br><span class="line">&quot;1&quot;</span><br><span class="line">127.0.0.1:6379[1]&gt; hget user name</span><br><span class="line">&quot;test&quot;</span><br></pre></td></tr></table></figure></p>
<p>（2）判断字段是否存在，hexists命令，返回1存在，返回0不存在<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379[1]&gt; hexists user id</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379[1]&gt; hexists user age</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure></p>
<p>（3）使用hsetnx(hset if not exists)如果不存在赋值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379[1]&gt; hsetnx user age 111</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379[1]&gt; hget user age</span><br><span class="line">&quot;111&quot;</span><br></pre></td></tr></table></figure></p>
<p>（4）增加数字<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379[1]&gt; hincrby user score 60</span><br><span class="line">(integer) 60</span><br><span class="line">127.0.0.1:6379[1]&gt; hget user score</span><br><span class="line">&quot;60&quot;</span><br></pre></td></tr></table></figure></p>
<p>（5）删除字段<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379[1]&gt; hdel user score</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379[1]&gt; hget user score</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure></p>
<h3 id="如何存储数据？"><a href="#如何存储数据？" class="headerlink" title="如何存储数据？"></a>如何存储数据？</h3><p>（1）使用散列类型存储数据，散列数据包括三部分（键、字段、字段值）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">键           字段     字段值</span><br><span class="line">post:id    field     value</span><br><span class="line">127.0.0.1:6379[1]&gt; incr userid</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379[1]&gt; hset user:1 name test</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379[1]&gt; hset user:1 score 90</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379[1]&gt; incr userid</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379[1]&gt; hset user:2 name test2</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379[1]&gt; hset user:2 score 99</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure></p>
<p> 添加了两条数据，id为1的名字为test分数为90，而id为2的名字为test2分数为90.</p>
<p>（2）获取多个字段的数据，需要使用hmget命令，并制定字段名称<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379[1]&gt; hmget user:1 name score</span><br><span class="line">1) &quot;test&quot;</span><br><span class="line">2) &quot;90&quot;</span><br></pre></td></tr></table></figure></p>
<p>（3）获取一行数据，不需要指定字段名称，只需要指出键名<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379[1]&gt; hgetall user:2</span><br><span class="line">1) &quot;name&quot;</span><br><span class="line">2) &quot;test2&quot;</span><br><span class="line">3) &quot;score&quot;</span><br><span class="line">4) &quot;99&quot;</span><br></pre></td></tr></table></figure></p>
<p>（4）只获取字段名或字段值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379[1]&gt; hkeys user:1</span><br><span class="line">1) &quot;name&quot;</span><br><span class="line">2) &quot;score&quot;</span><br><span class="line">127.0.0.1:6379[1]&gt; hvals user:1</span><br><span class="line">1) &quot;test&quot;</span><br><span class="line">2) &quot;90&quot;</span><br></pre></td></tr></table></figure></p>
<p>（5）获取字段数量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379[1]&gt; hlen user:1</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure></p>
<p>需要注意的是，散列类型无法获取所有存在的键值，也就是id，如果删除了中间某个id的话，只可以使用exist命令来判断key是否存在。</p>
<h2 id="列表类型"><a href="#列表类型" class="headerlink" title="列表类型"></a>列表类型</h2><p>类表类型解决了上述的问题。<br>类表类型是有序的，值是可以重复的。<br>列表类型是通过双向链表实现的，向列表两端添加元素的时间复杂度为O（1），获取两端元素的速度也是最快。</p>
<h3 id="基本操作-1"><a href="#基本操作-1" class="headerlink" title="基本操作"></a>基本操作</h3><p>列表的基本操作命令都是以l开头的。<br>（1）添加和弹出元素使用lpush和rpush以及lpop和rpop分别从列表的左侧和右侧添加和删除元素。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lpush user test</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; rpush user test1</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; lpop user </span><br><span class="line">&quot;test&quot;</span><br><span class="line">127.0.0.1:6379&gt; rpop user</span><br><span class="line">&quot;test1&quot;</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure></p>
<p>（2）llen查看元素个数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; llen user</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; lpush user test</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; llen user</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure></p>
<p>（3）获取列表片段<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lrange user 0 3</span><br><span class="line">1) &quot;test&quot;</span><br><span class="line">2) &quot;test1&quot;</span><br><span class="line">3) &quot;test2&quot;</span><br><span class="line">4) &quot;test3&quot;</span><br><span class="line">127.0.0.1:6379&gt; lrange user 0 2</span><br><span class="line">1) &quot;test&quot;</span><br><span class="line">2) &quot;test1&quot;</span><br><span class="line">3) &quot;test2&quot;</span><br></pre></td></tr></table></figure></p>
<p>（4）从列表中删除元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lrem     key     count     value</span><br><span class="line">@count 为删除个数，大于0的话从左边开始，小于0的话从右边开始</span><br><span class="line">@value 要删除的值</span><br></pre></td></tr></table></figure></p>
<p>我们可以把数据的id存储在列表中，当某一行数据被删除时候，只需要删除为该value为key即可，而查询数据的时候，需要先从列表中读取所有的id，再从散列表中读取数据。</p>
<p>（5）获取和设置索引元素值</p>
<p>（6）向列表中插入元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lrange user 0 -1</span><br><span class="line">1) &quot;test&quot;</span><br><span class="line">2) &quot;test1&quot;</span><br><span class="line">3) &quot;test2&quot;</span><br><span class="line">4) &quot;test3&quot;</span><br><span class="line">127.0.0.1:6379&gt; linsert user before test1 test0</span><br><span class="line">(integer) 5</span><br><span class="line">127.0.0.1:6379&gt; linsert user after test1 test1.5</span><br><span class="line">(integer) 6</span><br><span class="line">127.0.0.1:6379&gt; lrange user 0 -1</span><br><span class="line">1) &quot;test&quot;</span><br><span class="line">2) &quot;test0&quot;</span><br><span class="line">3) &quot;test1&quot;</span><br><span class="line">4) &quot;test1.5&quot;</span><br><span class="line">5) &quot;test2&quot;</span><br><span class="line">6) &quot;test3&quot;</span><br></pre></td></tr></table></figure></p>
<p>（7）将元素从一个列表转移到另外一个列表<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rdroplpush     source     destination</span><br></pre></td></tr></table></figure></p>
<p>从source列表的右侧弹出一个数据，添加到destination列表的左侧</p>
<h2 id="集合类型"><a href="#集合类型" class="headerlink" title="集合类型"></a>集合类型</h2><p>集合中不允许重复数据的出现，数据是唯一的，无序的。<br>空的散列表的HASH TABLE实现，因此操作时间复杂度为O(1)。<br>（1）增加sadd和删除srem、获取所有元素smembers，返回值标识成功添加元素的数量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd key 1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd key 2</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd key 2</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; smembers key</span><br><span class="line">1) &quot;1&quot;</span><br><span class="line">2) &quot;2&quot;</span><br><span class="line">127.0.0.1:6379&gt; srem key 2</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; smembers key</span><br><span class="line">1) &quot;1&quot;</span><br></pre></td></tr></table></figure></p>
<p>（2）判断元素是否在集合中可以使用sismember命令。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sismember key 1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; sismember key 3</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure></p>
<p>（3）集合运算<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sdiff      key     [key...]</span><br><span class="line">sinter     key     [key...]</span><br><span class="line">sunion     key     [key...]</span><br></pre></td></tr></table></figure></p>
<p>（4）获取元素个数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; scard key</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure></p>
<p>（5）集合运算并保存结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sdiffstore       destination     key [key...]</span><br><span class="line">sinterstore      destination     key[key...]</span><br><span class="line">sunionstore      destination     key[key...]</span><br></pre></td></tr></table></figure></p>
<p>（6）随机获取集合的元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">srandmember key [count]</span><br><span class="line"> 127.0.0.1:6379&gt; srandmember key 3</span><br><span class="line">1) &quot;4&quot;</span><br><span class="line">2) &quot;2&quot;</span><br><span class="line">3) &quot;3&quot;</span><br></pre></td></tr></table></figure></p>
<p>需要注意，srandmember取到的随机元素在集合比较小的情况下并不是完全随机的，由于redis的存储方法是利用哈希桶+数据链的存储方式，当桶和每个桶内元素的个数都非常小时就会造成取到相同数据的情况。</p>
<h2 id="有序集合类型-sorted-set"><a href="#有序集合类型-sorted-set" class="headerlink" title="有序集合类型 sorted set"></a>有序集合类型 sorted set</h2><p>与普通的集合类型相比，有序集合为集合中的每一个元素都关联了一个分数，这使得我们不仅可以完成插入、删除和判断元素是否存在等集合的基本操作，还能够得到分数最高（或最低）的前n个元素、获得指定分数范围内的元素等与分有关的操作，虽然集合中的元素必须是不同的，但是其分数是可以相同的。</p>
<p>有序结合和列表的使用区别：</p>
<ul>
<li>列表类型是通过链来实现的，获取靠近两端数据的速度极快，而当元素增多后，访问中间元素的数据就会变慢，所以她更适合实现如“新鲜事”或“日志”这样少访问中间元素的应用。</li>
<li>有序集合类型是使用散列和跳跃表实现的，所以即使读取位于中间部分数据的速度也很快（时间复杂度为O（log(n)））。</li>
<li>列表中不能简单地调整某个元素的位置，但有序集合可以通过调整分数来实现位置的调整。</li>
<li>有序集合更加消耗内存。</li>
</ul>
<p>###基本操作</p>
<p>（1）zadd添加元素，并设置分数score<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd students 60 xiaoming</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd students 80 daxiong</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure></p>
<p>（2）zscore获取元素分数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zscore students xiaoming</span><br><span class="line">&quot;60&quot;</span><br></pre></td></tr></table></figure></p>
<p>（3）获取排名在某个范围的列表，元素是从0开始的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zrange students 0 1</span><br><span class="line">1) &quot;xiaoming&quot;</span><br><span class="line">2) &quot;daxiong&quot;</span><br></pre></td></tr></table></figure></p>
<p>（4）获取指定分数范围的元素，用于筛选数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zrangebyscore students 0 70</span><br><span class="line">1) &quot;xiaoming&quot;</span><br><span class="line">127.0.0.1:6379&gt; zrangebyscore students 0 100</span><br><span class="line">1) &quot;xiaoming&quot;</span><br><span class="line">2) &quot;daxiong&quot;</span><br></pre></td></tr></table></figure></p>
<p>limit命令可以实现sql语句中的Limit效果<br>获取从0开始的前2个数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zrangebyscore students 0 100 limit 0 2</span><br><span class="line">1) &quot;xiaoming&quot;</span><br><span class="line">2) &quot;daxiong&quot;</span><br></pre></td></tr></table></figure></p>
<p>获取从1开始的前2个数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zrangebyscore students 0 100 limit 1 2</span><br><span class="line">1) &quot;daxiong&quot;</span><br></pre></td></tr></table></figure></p>
<p>（5）增加和减少某个元素的分数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zincrby students 5 xiaoming</span><br><span class="line">&quot;65&quot;</span><br><span class="line">127.0.0.1:6379&gt; zincrby students -5 xiaoming</span><br><span class="line">&quot;60&quot;</span><br></pre></td></tr></table></figure></p>
<p>（6）获取集合中元素个数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zcard students</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure></p>
<p>（7）获取指定分数范围内的元素个数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">zcount     key     min     max</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; zcount students 0 70</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; zcount students 0 90</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure></p>
<p>（8）删除一个或多个元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zrem     key     [key...]</span><br></pre></td></tr></table></figure></p>
<p>（9）按照排名范围来删除元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zremrangebyrank     key     start     stop</span><br></pre></td></tr></table></figure></p>
<p>（10）按照分数范围来删除元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zremrangebyscore     key     min     max</span><br></pre></td></tr></table></figure></p>
<p>（11）获取元素的排名，注意元素从0开始排序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zrank students xiaoming</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://baike.baidu.com/link?url=vLL9Cn2p07j_RVKz2HlTRcmkVVT0ZcqjGMDSAjKe95vjSqAFYwiRV9ESgRFlncNk_BP9hxHxzACjEYbHB66XI_" target="_blank" rel="external">redis入门指南</a><br><a href="http://redis.readthedocs.org/en/latest/" target="_blank" rel="external">http://redis.readthedocs.org/en/latest/</a></p>
]]></content>
      
        <categories>
            
            <category> cache </category>
            
        </categories>
        
        
        <tags>
            
            <tag> redis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[RabbitMQ topics]]></title>
      <url>/2015/03/16/rabbitmq-topics/</url>
      <content type="html"><![CDATA[<p><code>rabbitmq</code>中的<code>topic exchange</code>将路由键和某模式进行匹配，从而类似于正则匹配的方式去接收喜欢的信息。<br><a id="more"></a></p>
<h2 id="topic-exchange"><a href="#topic-exchange" class="headerlink" title="topic exchange"></a>topic exchange</h2><p>如果想使用<code>topic</code>模式，那么可以随意设置<code>routing_key</code>。相反，需要按照一定的要求设定该值。</p>
<p><code>routing_key</code>在topic模式中应该选择一组拥有特定属性的单词作为该值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">\* (star) can substitute for exactly one word.</span><br><span class="line"># (hash) can substitute for zero or more words.</span><br></pre></td></tr></table></figure>
<p>例如，如果生产者的<code>routing_key</code>设置为<code>test1.test2.test3</code>，那么消费着中绑定消息队列的<code>routing_key</code>必须可以匹配生产者的<code>routing_key</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#生产者</span></span><br><span class="line">routing_key = <span class="string">'test1.test2.test3'</span></span><br><span class="line">channel.basic_publish(exchange=<span class="string">'topic_test'</span>, routing_key=routing_key, body=message)</span><br><span class="line"></span><br><span class="line"><span class="comment">#消费者</span></span><br><span class="line">routing_key = <span class="string">'test1.*'</span> <span class="comment">#可以</span></span><br><span class="line">routing_key = <span class="string">'*.test2.*'</span> <span class="comment">#可以</span></span><br><span class="line">routing_key = <span class="string">'test3'</span> <span class="comment">#不可以</span></span><br><span class="line">channel.queue_bind(exchange=<span class="string">'topic_logs'</span>, queue=queue_name, routing_key=binding_key)</span><br></pre></td></tr></table></figure>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>生产者如下，会依次设置<code>routing_key</code>为A和B，那么需要设置两个消费者的<code>routing_key</code>来分别读取消息。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(</span><br><span class="line">host=<span class="string">'localhost'</span>))</span><br><span class="line">channel = connection.channel()</span><br><span class="line"></span><br><span class="line">channel.exchange_declare(exchange=<span class="string">'topic_test'</span>,</span><br><span class="line">type=<span class="string">'topic'</span>)</span><br><span class="line"></span><br><span class="line">message = <span class="string">"test "</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">20</span>):</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> [<span class="string">'A'</span>, <span class="string">'B'</span>]:</span><br><span class="line">        routing_key = item</span><br><span class="line">        channel.basic_publish(exchange=<span class="string">'topic_test'</span>,routing_key=routing_key, body=message+item)</span><br><span class="line">        <span class="keyword">print</span> <span class="string">" [x] Sent %r:%r"</span> % (routing_key, message)</span><br><span class="line">        time.sleep(<span class="number">2</span>)</span><br><span class="line">connection.close()</span><br></pre></td></tr></table></figure>
<p>消费者如下，启动命令分别为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python receive.py A</span><br><span class="line">python receive.py B</span><br></pre></td></tr></table></figure>
<p>消费者如下：</p>
<pre><code class="python"><span class="comment">#!/usr/bin/env python</span>
<span class="comment"># coding=utf-8</span>

<span class="keyword">import</span> pika
<span class="keyword">import</span> sys

<span class="function"><span class="keyword">def</span> <span class="title">callback</span><span class="params">(ch, method, properties, body)</span>:</span>
<span class="keyword">print</span> <span class="string">" [x] %r:%r"</span> % (method.routing_key, body,)

connection = pika.BlockingConnection(pika.ConnectionParameters(
host=<span class="string">'localhost'</span>))
channel = connection.channel()

channel.exchange_declare(exchange=<span class="string">'topic_test'</span>,
type=<span class="string">'topic'</span>)

result = channel.queue_declare(exclusive=<span class="keyword">True</span>)
queue_name = result.method.queue

binding_key = sys.argv[<span class="number">1</span>]
<span class="keyword">print</span> <span class="string">"Usage: %s [binding_key]..."</span> % (sys.argv[<span class="number">1</span>])

channel.queue_bind(exchange=<span class="string">'topic_test'</span>, queue=queue_name, routing_key=binding_key)
<span class="keyword">print</span> <span class="string">' [*] Waiting for logs. To exit press CTRL+C'</span>
channel.basic_consume(callback, queue=queue_name, no_ack=<span class="keyword">True</span>)

channel.start_consuming()
</code></pre>
]]></content>
      
        <categories>
            
            <category> mq </category>
            
        </categories>
        
        
        <tags>
            
            <tag> rabbitmq </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[RabbitMQ Routing]]></title>
      <url>/2015/03/16/rabbitmq-routing/</url>
      <content type="html"><![CDATA[<p><code>rabbitmq</code>可以通过路由选择订阅者来发布消息。<br><a id="more"></a></p>
<h2 id="Bindings"><a href="#Bindings" class="headerlink" title="Bindings"></a>Bindings</h2><p>通过下面的函数绑定Exchange与消息队列：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.queue_bind(exchange=exchange_name, queue=queue_name)</span><br></pre></td></tr></table></figure>
<p>可以通过添加<code>routing_key</code>来做路由选择，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.queue_bind(exchange=exchange_name, queue=queue_name, routing_key=&apos;black&apos;)</span><br></pre></td></tr></table></figure>
<h2 id="Direct-Exchange"><a href="#Direct-Exchange" class="headerlink" title="Direct Exchange"></a>Direct Exchange</h2><p>为了使用直接转发，可以设置<code>Exchange</code>的类型为<code>direct</code>。</p>
<p>在<code>rabbitmq</code>中直接转发的算法很简单，如果<code>binding key</code>与<code>routing key</code>相同，消息会直接添加到相应的消息队列中取。</p>
<h2 id="Multiple-bindings"><a href="#Multiple-bindings" class="headerlink" title="Multiple bindings"></a>Multiple bindings</h2><p><code>rabbitmq</code>允许一个<code>Exchange</code>绑定多个消息队列，那么该<code>Exchange</code>会把消息分别发布到绑定的多个消息队列中。</p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p><strong>生产者</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(</span><br><span class="line">host=<span class="string">'localhost'</span>))</span><br><span class="line">channel = connection.channel()</span><br><span class="line"></span><br><span class="line">channel.exchange_declare(exchange=<span class="string">'news'</span>, type=<span class="string">'fanout'</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">    message = str(i) + <span class="string">'Hello World!'</span></span><br><span class="line">    <span class="keyword">if</span> i%<span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        channel.basic_publish(exchange=<span class="string">'news'</span>, routing_key=<span class="string">'0'</span>, body=message)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        channel.basic_publish(exchange=<span class="string">'news'</span>, routing_key=<span class="string">'1'</span>, body=message)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">" [x] Sent %r"</span> % (message,)</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">connection.close()</span><br></pre></td></tr></table></figure>
<p><strong>消费者</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">parameters = pika.URLParameters(<span class="string">'amqp://mtest:root@rabbit-server:5672/%2F'</span>)</span><br><span class="line">connection = pika.BlockingConnection(parameters)</span><br><span class="line">channel = connection.channel()</span><br><span class="line"></span><br><span class="line">channel.exchange_declare(exchange=<span class="string">'news'</span>, type=<span class="string">'fanout'</span>)</span><br><span class="line"></span><br><span class="line">result = channel.queue_declare(exclusive=<span class="keyword">True</span>)</span><br><span class="line">queue_name = result.method.queue</span><br><span class="line"></span><br><span class="line">channel.queue_bind(exchange=<span class="string">'news'</span>, queue=queue_name, routing_key=sys.argv[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">' [*] Waiting for news. To exit press CTRL+C'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback</span><span class="params">(ch, method, properties, body)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">" [x] %r"</span> % (body,)</span><br><span class="line"></span><br><span class="line">channel.basic_consume(callback, queue=queue_name, no_ack=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line">channel.start_consuming()</span><br><span class="line"> </span><br><span class="line">parameters = pika.URLParameters(<span class="string">'amqp://guest:guest@rabbit-server1:5672/%2F'</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> mq </category>
            
        </categories>
        
        
        <tags>
            
            <tag> rabbitmq </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[RabbitMQ Publish/Subscribe]]></title>
      <url>/2015/03/16/rabbitmq-publish-subscribe/</url>
      <content type="html"><![CDATA[<p><code>rabbitmq</code>支持一对多的模式，一般称为发布/订阅。也就是说，生产者产生一条消息后，<code>rabbitmq</code>会把该消息分发给所有的消费者。<br><a id="more"></a></p>
<h2 id="Exchanges"><a href="#Exchanges" class="headerlink" title="Exchanges"></a>Exchanges</h2><p>之前的教程中，仅仅使用了基本的消息模型：</p>
<ul>
<li>生产者产生消息</li>
<li>把消息添加到消息队列</li>
<li>消费者接收消息</li>
</ul>
<p>而在<code>rabbitmq完整的消息模型</code>中，并不是这样的。事实上，生产者并不知道消息是否发送到队列，而是把消息直接发送给<code>Exchanges</code>。</p>
<p><code>Exchanges</code>的功能理解起来非常简单，它只负责接收生产者发送的数据并把这些数据添加到消息队列。但是，在存在多个消息队列的情况下，<code>Exchanges</code>必须知道每条消息要添加到哪一个消息队列。</p>
<p><code>rabbitmq</code>提供了几种<code>Exchanges</code>，包括:<code>direct</code>, <code>topic</code>, <code>headers</code> and <code>fanout</code>。</p>
<p>这里，仅仅介绍fanout的使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.exchange_declare(exchange=&apos;news&apos;, type=&apos;fanout&apos;)</span><br></pre></td></tr></table></figure>
<p>那么，发布消息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.basic_publish(exchange=&apos;news&apos;, routing_key=&apos;&apos;, body=message)</span><br></pre></td></tr></table></figure>
<h2 id="Temporary-queues"><a href="#Temporary-queues" class="headerlink" title="Temporary queues"></a>Temporary queues</h2><p>由于在生产者和消费者中需要指定相同的消息队列才能实现消息通信，那么如果不特殊指定某个消息队列会如何呢？<br>那么需要使用默认参数让系统给生成一个特定的消息队列。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = channel.queue_declare()</span><br></pre></td></tr></table></figure>
<h2 id="Bindings"><a href="#Bindings" class="headerlink" title="Bindings"></a>Bindings</h2><p>为了发送指定发送的消息队列，必须创建exchange和消息队列之间的关系：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.queue_bind(exchange=&apos;news&apos;, queue=result.method.queue)</span><br></pre></td></tr></table></figure>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>作为生产者的publish：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(</span><br><span class="line">host=<span class="string">'localhost'</span>))</span><br><span class="line">channel = connection.channel()</span><br><span class="line"></span><br><span class="line">channel.exchange_declare(exchange=<span class="string">'news'</span>,</span><br><span class="line">type=<span class="string">'fanout'</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">    message = str(i) + <span class="string">'Hello World!'</span></span><br><span class="line">    channel.basic_publish(exchange=<span class="string">'news'</span>, routing_key=<span class="string">''</span>, body=message)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">" [x] Sent %r"</span> % (message,)</span><br><span class="line">    <span class="keyword">import</span> time</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">connection.close()</span><br></pre></td></tr></table></figure>
<p>作为消费者的subscribe：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(</span><br><span class="line">host=<span class="string">'localhost'</span>))</span><br><span class="line">channel = connection.channel()</span><br><span class="line"></span><br><span class="line">channel.exchange_declare(exchange=<span class="string">'news'</span>, type=<span class="string">'fanout'</span>)</span><br><span class="line"></span><br><span class="line">result = channel.queue_declare(exclusive=<span class="keyword">True</span>)</span><br><span class="line">queue_name = result.method.queue</span><br><span class="line"></span><br><span class="line">channel.queue_bind(exchange=<span class="string">'news'</span>,</span><br><span class="line">queue=queue_name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">' [*] Waiting for news. To exit press CTRL+C'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback</span><span class="params">(ch, method, properties, body)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">" [x] %r"</span> % (body,)</span><br><span class="line"></span><br><span class="line">channel.basic_consume(callback, queue=queue_name, no_ack=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line">channel.start_consuming()</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> mq </category>
            
        </categories>
        
        
        <tags>
            
            <tag> rabbitmq </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[RabbitMQ Work Queues]]></title>
      <url>/2015/03/15/rabbitmq-work-queues/</url>
      <content type="html"><![CDATA[<p>RabbitMQ使用Work Queues的主要目的是为了避免资源使用密集的任务，它不同于定时任务处理的方式，而是把任务封装为消息添加到队列中。而消息队列正是共享于多个工作者中使用，它们可以随意pop出数据进行处理。<br><a id="more"></a></p>
<h2 id="消息的持久化-Message-durability"><a href="#消息的持久化-Message-durability" class="headerlink" title="消息的持久化 Message durability"></a>消息的持久化 Message durability</h2><p>为了保证<code>rabbitmq</code>意外重启等原因造成的消息丢失，通过设置消息的durable来实现数据的持久化，但是需要生产者和消费者同时设置持久化才能生效。</p>
<p>需要注意的是，<code>rabbitmq</code>并不允许更改已经创建的消息队列的属性，假如之前已经创建过非持久化的hello消息队列，那么会返回一个错误信息。</p>
<p>设置消息队列的可持久化属性（第二个参数）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.queue_declare(queue=&apos;hello&apos;, durable=True)</span><br></pre></td></tr></table></figure>
<p>在消息发送时，需要指定<code>delivery_mode</code>来实现消息持久化：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.basic_publish(exchange=&apos;&apos;, routing_key=&quot;task_queue&quot;, body=message, properties=pika.BasicProperties(delivery_mode = 2, # make message persistent))</span><br></pre></td></tr></table></figure></p>
<h2 id="平均分配-Fair-dispatch"><a href="#平均分配-Fair-dispatch" class="headerlink" title="平均分配 Fair dispatch"></a>平均分配 Fair dispatch</h2><p><code>rabbitmq</code>实现了消息均分的功能，通过设置<code>basic.qos</code>方法的<code>prefetch_count</code>来实现。它会告诉<code>rabbitmq</code>的生产者不要给一个消费者分配过多的任务，也就是说不要在消费者处理完成已经接收到的任务之前分配新的任务。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.basic_qos(prefetch_count=1)</span><br></pre></td></tr></table></figure>
<p>其中prefetch_count为可以接受处理的任务个数，如果未达到上限rabbitmq会继续向消费者推送任务。</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p><strong>生产者</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(host=<span class="string">'localhost'</span>))</span><br><span class="line">channel = connection.channel()</span><br><span class="line"></span><br><span class="line">channel.queue_declare(queue=<span class="string">'task_queue'</span>, durable=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">    message = str(i) + <span class="string">' Hello World!'</span></span><br><span class="line">    channel.basic_publish(exchange=<span class="string">''</span>,</span><br><span class="line">    routing_key=<span class="string">'task_queue'</span>,</span><br><span class="line">    body=message,</span><br><span class="line">    properties=pika.BasicProperties(delivery_mode = <span class="number">2</span>, <span class="comment"># make message persistent))</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">" [x] Sent %r"</span> % (message,)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">connection.close()</span><br></pre></td></tr></table></figure>
<p><strong>消费者</strong></p>
<pre><code class="python"><span class="comment">#!/usr/bin/env python</span>
<span class="comment"># coding=utf-8</span>

<span class="keyword">import</span> pika
<span class="keyword">import</span> time

connection = pika.BlockingConnection(pika.ConnectionParameters(host=<span class="string">'localhost'</span>))
channel = connection.channel()

channel.queue_declare(queue=<span class="string">'task_queue'</span>, durable=<span class="keyword">True</span>)
<span class="keyword">print</span> <span class="string">' [*] Waiting for messages. To exit press CTRL+C'</span>

<span class="function"><span class="keyword">def</span> <span class="title">callback</span><span class="params">(ch, method, properties, body)</span>:</span>
    <span class="keyword">print</span> <span class="string">" [x] Received %r"</span> % (body,)
    time.sleep(<span class="number">2</span>)
    <span class="keyword">print</span> <span class="string">" [x] Done"</span>
    ch.basic_ack(delivery_tag = method.delivery_tag)

channel.basic_qos(prefetch_count=<span class="number">1</span>)
channel.basic_consume(callback, queue=<span class="string">'task_queue'</span>)

channel.start_consuming()
</code></pre>
]]></content>
      
        <categories>
            
            <category> mq </category>
            
        </categories>
        
        
        <tags>
            
            <tag> rabbitmq </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[RabbitMQ Hello world]]></title>
      <url>/2015/03/14/rabbitmq-hello-world/</url>
      <content type="html"><![CDATA[<p>RabbitMQ使用AMQP通信协议（AMQP是一个提供统一消息服务的应用层标准协议，基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件不同产品，不同开发语言等条件的限制。）。<br>安装<br><a id="more"></a><br>具体教程参考：<a href="http://www.rabbitmq.com/tutorials/tutorial-one-python.html" target="_blank" rel="external">http://www.rabbitmq.com/tutorials/tutorial-one-python.html</a></p>
<h2 id="安装python的开发库"><a href="#安装python的开发库" class="headerlink" title="安装python的开发库"></a>安装python的开发库</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pip install pika==0.9.8</span><br></pre></td></tr></table></figure>
<p>安装rabbitmq服务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install rabbitmq-server</span><br></pre></td></tr></table></figure>
<p>启动rabbit服务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rabbitmq-server start</span><br><span class="line">Hello World</span><br></pre></td></tr></table></figure>
<h2 id="发送"><a href="#发送" class="headerlink" title="发送"></a>发送</h2><ul>
<li>通过使用pika第三方库来连接，本例中为localhost本地连接 </li>
<li>通过queue_declare来创建一个消息队列</li>
<li>发送消息basic_publish</li>
<li>关闭链接close</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(<span class="string">'localhost'</span>))</span><br><span class="line">channel = connection.channel()</span><br><span class="line"></span><br><span class="line">channel.queue_declare(queue=<span class="string">'hello'</span>)</span><br><span class="line"></span><br><span class="line">channel.basic_publish(exchange=<span class="string">''</span>, routing_key=<span class="string">'hello'</span>, body=<span class="string">'hello world!'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">'Sent "hello world"'</span></span><br><span class="line"></span><br><span class="line">connection.close()</span><br></pre></td></tr></table></figure>
<h2 id="接收"><a href="#接收" class="headerlink" title="接收"></a>接收</h2><ul>
<li>通过使用pika第三方库来连接，本例中为localhost本地连接。</li>
<li>通过queue_declare来创建一个消息队列（推荐，由于接收之前消息队列有可能并没有创建过）</li>
<li>指定消息队列和回调函数basic_consume</li>
<li>开始接受消息start_consuming</li>
</ul>
<pre><code class="python"><span class="comment">#!/usr/bin/env python</span>
<span class="comment"># coding=utf-8</span>

<span class="keyword">import</span> pika

<span class="function"><span class="keyword">def</span> <span class="title">callback</span><span class="params">(ch, method, properties, body)</span>:</span>
<span class="keyword">print</span> <span class="string">'receive %r'</span>%body

connection = pika.BlockingConnection(pika.ConnectionParameters(<span class="string">'localhost'</span>))
channel = connection.channel()

channel.queue_declare(queue=<span class="string">'hello'</span>)

channel.basic_consume(callback, queue=<span class="string">'hello'</span>, no_ack=<span class="keyword">True</span>)

channel.start_consuming()
</code></pre>
]]></content>
      
        <categories>
            
            <category> mq </category>
            
        </categories>
        
        
        <tags>
            
            <tag> rabbitmq </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[php后台开发（二）Laravel框架]]></title>
      <url>/2015/03/11/php-Laravel/</url>
      <content type="html"><![CDATA[<p>为了提高后台的开发效率，往往需要选择一套适合自己的开发框架，因此，选择了功能比较完善的Laravel框架，仔细学来，感觉和Python语言的框架Django非常类似。<br><a id="more"></a></p>
<h2 id="Laravel框架"><a href="#Laravel框架" class="headerlink" title="Laravel框架"></a>Laravel框架</h2><blockquote>
<p>Laravel是一套web应用开发框架，它具有富于表达性且简洁的语法，并提供了验证（authentication）、路由（routing）、session和缓存（caching）等开发过程中经常用到的工具或功能。</p>
</blockquote>
<h3 id="框架安装"><a href="#框架安装" class="headerlink" title="框架安装"></a>框架安装</h3><h4 id="安装composer"><a href="#安装composer" class="headerlink" title="安装composer"></a>安装composer</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http://docs.phpcomposer.com/download/</span><br><span class="line">curl -sS https://getcomposer.org/installer | php</span><br><span class="line">mv composer.phar /usr/bin/composer</span><br></pre></td></tr></table></figure>
<p>由于国外的景象不稳定，所以连接国内的景象，具体方法参考：<a href="http://pkg.phpcomposer.com/。（选择方法1的配置方法）" target="_blank" rel="external">http://pkg.phpcomposer.com/。（选择方法1的配置方法）</a></p>
<h3 id="安装Laravel"><a href="#安装Laravel" class="headerlink" title="安装Laravel"></a>安装Laravel</h3><p>通过composer安装Lavarel。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer global require &quot;laravel/installer=~1.1&quot;</span><br></pre></td></tr></table></figure></p>
<p>把 ~/.composer/vendor/bin 路径添加到 PATH 环境变量里, 这样laravel 可执行文件才能被命令行找到。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s ~/.composer/vendor/bin/laravel /usr/local/bin/laravel</span><br></pre></td></tr></table></figure></p>
<h3 id="创建新工程"><a href="#创建新工程" class="headerlink" title="创建新工程"></a>创建新工程</h3><h4 id="安装依赖库"><a href="#安装依赖库" class="headerlink" title="安装依赖库"></a>安装依赖库</h4><p>安装启动MCrypt PHP Extension<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install php5-mcrypt</span><br><span class="line">sudo php5enmod mcrypt</span><br><span class="line">启动Mod_rewrite 模块</span><br></pre></td></tr></table></figure></p>
<p>常见的情况修改二级route，会出现404情况，解决方法就是启动该模块。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo a2enmod rewrite</span><br></pre></td></tr></table></figure></p>
<p>安装方法（1）Laravel安装器安装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">laravel new demo</span><br></pre></td></tr></table></figure></p>
<p>安装方法（2）Composer 的 create-project 命令安装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer create-project laravel/laravel project_name</span><br></pre></td></tr></table></figure></p>
<p>安装方法（3）免安装下载完整工程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">点击下面的链接下载文件，版本为4.2</span><br><span class="line">http://files.cnblogs.com/files/coder2012/complete-laravel4-master.zip</span><br></pre></td></tr></table></figure></p>
<h3 id="使用Laravel"><a href="#使用Laravel" class="headerlink" title="使用Laravel"></a>使用Laravel</h3><h4 id="配置apache"><a href="#配置apache" class="headerlink" title="配置apache"></a>配置apache</h4><p>修改配置文件apache2.conf<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/apache2/apache2.conf</span><br></pre></td></tr></table></figure></p>
<p>修改并增加内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;Directory /&gt;</span><br><span class="line">    Options FollowSymLinks</span><br><span class="line">    AllowOverride All </span><br><span class="line">    Require all granted </span><br><span class="line">&lt;/Directory&gt;</span><br><span class="line"></span><br><span class="line">&lt;Directory /opt/work/laravel/public&gt;</span><br><span class="line">    Options Indexes FollowSymLinks</span><br><span class="line">    AllowOverride All </span><br><span class="line">    Require all granted</span><br><span class="line">&lt;/Directory&gt;</span><br></pre></td></tr></table></figure></p>
<p>修改配置文件000-default.conf<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/apache2/sites-available/000-default.conf</span><br></pre></td></tr></table></figure></p>
<p>修改内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DocumentRoot /opt/work/laravel/public</span><br></pre></td></tr></table></figure></p>
<h4 id="重启apache"><a href="#重启apache" class="headerlink" title="重启apache"></a>重启apache</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/apache2 restart</span><br></pre></td></tr></table></figure>
<p>访问<a href="http://localhost/，如果看到如下图片则表明成功。" target="_blank" rel="external">http://localhost/，如果看到如下图片则表明成功。</a></p>
]]></content>
      
        <categories>
            
            <category> php </category>
            
        </categories>
        
        
        <tags>
            
            <tag> php </tag>
            
            <tag> framework </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[php后台开发（一）hello world]]></title>
      <url>/2015/03/09/php-hello/</url>
      <content type="html"><![CDATA[<p>php hello world!<br><a id="more"></a></p>
<h2 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h2><p>开发环境为Ubuntu 12.04，选择linux+apache+php的开发环境</p>
<h3 id="安装-apache2"><a href="#安装-apache2" class="headerlink" title="安装 apache2"></a>安装 apache2</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install apache2</span><br></pre></td></tr></table></figure>
<h3 id="安装php"><a href="#安装php" class="headerlink" title="安装php"></a>安装php</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install php5</span><br></pre></td></tr></table></figure>
<h3 id="安装mysql-注意安装过程中，需要输入root密码"><a href="#安装mysql-注意安装过程中，需要输入root密码" class="headerlink" title="安装mysql(注意安装过程中，需要输入root密码)"></a>安装mysql(注意安装过程中，需要输入root密码)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install mysql-server</span><br></pre></td></tr></table></figure>
<h3 id="安装apache的解析模块"><a href="#安装apache的解析模块" class="headerlink" title="安装apache的解析模块"></a>安装apache的解析模块</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libapache2-mod-php5</span><br><span class="line">sudo apt-get install libapache2-mod-auth-mysql</span><br></pre></td></tr></table></figure>
<h3 id="安装php的mysql连接模块"><a href="#安装php的mysql连接模块" class="headerlink" title="安装php的mysql连接模块"></a>安装php的mysql连接模块</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install php5-mysql</span><br></pre></td></tr></table></figure>
<h3 id="安装处理图片的GD库"><a href="#安装处理图片的GD库" class="headerlink" title="安装处理图片的GD库"></a>安装处理图片的GD库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install php5-gd</span><br></pre></td></tr></table></figure>
<h3 id="启动apache"><a href="#启动apache" class="headerlink" title="启动apache"></a>启动apache</h3><p>默认情况下根目录为/var/www/html</p>
<p>输入测试地址<a href="http://localhost/" target="_blank" rel="external">http://localhost/</a></p>
<h4 id="改变默认开发路径"><a href="#改变默认开发路径" class="headerlink" title="改变默认开发路径"></a>改变默认开发路径</h4><p>apache2的默认文件目录的配置路径：/etc/apache2/sites-enabled/000-default.conf</p>
<p>修改DocumentRoot后的内容为开发目录的路径<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DocumentRoot /opt/webroot/xxx</span><br></pre></td></tr></table></figure></p>
<p>apache2的默认配置文件的路径：/etc/apache2/apache2.conf</p>
<p>添加文件路径的权限<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;Directory /opt/webroot/xx &gt;</span><br><span class="line">    Option Indexes FollowSymLinks</span><br><span class="line">    AllowOverride None</span><br><span class="line">    Require all granted</span><br><span class="line">&lt;/Directory&gt;</span><br></pre></td></tr></table></figure></p>
<p>hello world</p>
<p>在开发目录下，打开一个文件index.php, 输入<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"&lt;h1&gt;hello world!&lt;/h1&gt;"</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>打开:址<a href="http://localhost/就会看到结果。" target="_blank" rel="external">http://localhost/就会看到结果。</a></p>
]]></content>
      
        <categories>
            
            <category> php </category>
            
        </categories>
        
        
        <tags>
            
            <tag> php </tag>
            
            <tag> framework </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python __setattr__, __getattr__, __delattr__, __call__]]></title>
      <url>/2015/03/05/python-set-get-del-call-attr/</url>
      <content type="html"><![CDATA[<p>介绍python的几个内建函数。<br><a id="more"></a></p>
<h2 id="getattr"><a href="#getattr" class="headerlink" title="getattr"></a>getattr</h2><p><code>getattr</code>函数属于内建函数，可以通过函数名称获取<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">value = obj.attribute</span><br><span class="line">value = getattr(obj, <span class="string">"attribute"</span>)</span><br></pre></td></tr></table></figure></p>
<p>使用<code>getattr</code>来实现工厂模式</p>
<p>一个模块支持html、text、xml等格式的打印，根据传入的formate参数的不同，调用不同的函数实现几种格式的输出<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> statsout </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">output</span><span class="params">(data, format=<span class="string">"text"</span>)</span>:</span>                           </span><br><span class="line">    output_function = getattr(statsout, <span class="string">"output_%s"</span> %format) </span><br><span class="line">    <span class="keyword">return</span> output_function(data)</span><br></pre></td></tr></table></figure></p>
<h2 id="call"><a href="#call" class="headerlink" title="call"></a><strong>call</strong></h2><p><code>__call__</code>方法用于实例自身的调用：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">storage</span><span class="params">(dict)</span>:</span></span><br><span class="line">    <span class="comment"># __call__方法用于实例自身的调用</span></span><br><span class="line">    <span class="comment">#达到()调用的效果</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span> <span class="params">(self, key)</span>:</span></span><br><span class="line">         <span class="keyword">try</span>:</span><br><span class="line">             <span class="keyword">return</span> self[key]</span><br><span class="line">         <span class="keyword">except</span> KeyError, k:</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">s = storage()</span><br><span class="line">s[<span class="string">'key'</span>] = <span class="string">'value'</span></span><br><span class="line"><span class="keyword">print</span> s(key) <span class="comment">#调用__call__</span></span><br></pre></td></tr></table></figure></p>
<h2 id="getattr-1"><a href="#getattr-1" class="headerlink" title="getattr"></a><strong>getattr</strong></h2><p>从对象中读取某个属性时，首先需要从self.<strong>dicts</strong>中搜索该属性，再从<strong>getattr</strong>中查找。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span>  </span><br><span class="line">        self.name = <span class="string">'from __dicts__: zdy'</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, item)</span>:</span>  </span><br><span class="line">        <span class="keyword">if</span> item == <span class="string">'name'</span>:  </span><br><span class="line">            <span class="keyword">return</span> <span class="string">'from __getattr__: zdy'</span>  </span><br><span class="line">        <span class="keyword">elif</span> item == <span class="string">'age'</span>:  </span><br><span class="line">            <span class="keyword">return</span> <span class="number">26</span>  </span><br><span class="line"></span><br><span class="line">a = A()  </span><br><span class="line"><span class="keyword">print</span> a.name <span class="comment"># 从__dict__里获得的  </span></span><br><span class="line"><span class="keyword">print</span> a.age <span class="comment"># 从__getattr__获得的</span></span><br></pre></td></tr></table></figure></p>
<h2 id="setattr"><a href="#setattr" class="headerlink" title="setattr"></a><strong>setattr</strong></h2><p><code>__setattr__</code>函数是用来设置对象的属性，通过object中的<strong>setattr</strong>函数来设置属性：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setattr__</span><span class="params">(self, *args, **kwargs)</span>:</span>  </span><br><span class="line">        <span class="keyword">print</span> <span class="string">'call func set attr'</span>  </span><br><span class="line">        <span class="keyword">return</span> object.__setattr__(self, *args, **kwargs) </span><br><span class="line">__delattr__</span><br></pre></td></tr></table></figure>
<p><code>__delattr__</code>函数式用来删除对象的属性：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__delattr__</span><span class="params">(self, *args, **kwargs)</span>:</span>  </span><br><span class="line">        <span class="keyword">print</span> <span class="string">'call func del attr'</span>  </span><br><span class="line">        <span class="keyword">return</span> object.__delattr__(self, *args, **kwargs)</span><br></pre></td></tr></table></figure>
<p>例子</p>
<p>完整例子可以参考微博API：<a href="http://github.liaoxuefeng.com/sinaweibopy/" target="_blank" rel="external">http://github.liaoxuefeng.com/sinaweibopy/</a><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_Executable</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, client, method, path)</span>:</span></span><br><span class="line">        self._client = client</span><br><span class="line">        self._method = method</span><br><span class="line">        self._path = path</span><br><span class="line">    <span class="comment">#__call__函数实现_Executable函数对象为可调用的</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, **kw)</span>:</span></span><br><span class="line">        method = _METHOD_MAP[self._method]</span><br><span class="line">        <span class="keyword">if</span> method==_HTTP_POST <span class="keyword">and</span> <span class="string">'pic'</span> <span class="keyword">in</span> kw:</span><br><span class="line">            method = _HTTP_UPLOAD</span><br><span class="line">        <span class="keyword">return</span> _http_call(<span class="string">'%s%s.json'</span> % (self._client.api_url, self._path), method, self._client.access_token, **kw)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'_Executable (%s %s)'</span> % (self._method, self._path)</span><br><span class="line"></span><br><span class="line">    __repr__ = __str__</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_Callable</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, client, name)</span>:</span></span><br><span class="line">        self._client = client</span><br><span class="line">        self._name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, attr)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> attr==<span class="string">'get'</span>:</span><br><span class="line">　　　　　　　<span class="comment">#初始化_Executable对象，调用__init__函数</span></span><br><span class="line">            <span class="keyword">return</span> _Executable(self._client, <span class="string">'GET'</span>, self._name)</span><br><span class="line">        <span class="keyword">if</span> attr==<span class="string">'post'</span>:</span><br><span class="line">            <span class="keyword">return</span> _Executable(self._client, <span class="string">'POST'</span>, self._name)</span><br><span class="line">        name = <span class="string">'%s/%s'</span> % (self._name, attr)</span><br><span class="line">        <span class="keyword">return</span> _Callable(self._client, name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'_Callable (%s)'</span> % self._name</span><br><span class="line"></span><br><span class="line">    __repr__ = __str__</span><br></pre></td></tr></table></figure></p>
<p>而在源码中，存在下面代码片段：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">APIClient</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    API client using synchronized invocation.</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    ... </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, attr)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">'__'</span> <span class="keyword">in</span> attr:</span><br><span class="line">            <span class="keyword">return</span> getattr(self.get, attr)</span><br><span class="line">        <span class="keyword">return</span> _Callable(self, attr)</span><br></pre></td></tr></table></figure></p>
<p>因此，加入我们初始化对象，并调用某函数如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">client = APIClient(...)</span><br><span class="line"><span class="comment">#会调用__getattr__函数，从而调用__call__函数</span></span><br><span class="line">client.something.get()</span><br></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[memcache 事件模型]]></title>
      <url>/2015/02/09/memcache-event-model/</url>
      <content type="html"><![CDATA[<p>在memcachedd中，作者为了专注于缓存的设计，使用了libevent来开发事件模型。memcachedd的时间模型同nginx的类似，拥有一个主进行（master）以及多个工作者线程（woker）。<br><a id="more"></a></p>
<h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><p>在memcached中，是先对工作者线程进行初始化并启动，然后才会创建启动主线程。<br><img src="/images/memcache-event-model-1.jpg" alt="memcache_event_model"></p>
<h2 id="工作者线程"><a href="#工作者线程" class="headerlink" title="工作者线程"></a>工作者线程</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>memcached对工作者线程进行初始化，参数分别为线程数量以及<code>main_base</code>，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* start up worker threads if MT mode */</span></span><br><span class="line">thread_init(settings.num_threads, main_base);</span><br></pre></td></tr></table></figure>
<p>在memcachedd中为了避免多线程共享资源的使用使用了很多锁，这里对锁不做介绍。</p>
<h3 id="线程的结构体"><a href="#线程的结构体" class="headerlink" title="线程的结构体"></a>线程的结构体</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">pthread_t</span> thread_id;        <span class="comment">/* unique ID of this thread 线程ID*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event_base</span> *<span class="title">base</span>;</span>    <span class="comment">/* libevent handle this thread uses libevent事件*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event</span> <span class="title">notify_event</span>;</span>  <span class="comment">/* listen event for notify pipe 注册事件*/</span></span><br><span class="line">    <span class="keyword">int</span> notify_receive_fd;      <span class="comment">/* receiving end of notify pipe 管道中接收端*/</span></span><br><span class="line">    <span class="keyword">int</span> notify_send_fd;         <span class="comment">/* sending end of notify pipe 管道中发送端*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">thread_stats</span> <span class="title">stats</span>;</span>  <span class="comment">/* Stats generated by this thread 线程状态*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">conn_queue</span> *<span class="title">new_conn_queue</span>;</span> <span class="comment">/* queue of new connections to handle 消息队列*/</span></span><br><span class="line">    <span class="keyword">cache_t</span> *suffix_cache;      <span class="comment">/* suffix cache */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> item_lock_type;     <span class="comment">/* use fine-grained or global item lock */</span></span><br><span class="line">&#125; LIBEVENT_THREAD;</span><br></pre></td></tr></table></figure>
<h3 id="初始化工作者线程"><a href="#初始化工作者线程" class="headerlink" title="初始化工作者线程"></a>初始化工作者线程</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nthreads; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> fds[<span class="number">2</span>];</span><br><span class="line">    <span class="comment">/* 创建管道 */</span></span><br><span class="line">    <span class="keyword">if</span> (pipe(fds)) &#123;</span><br><span class="line">        perror(<span class="string">"Can't create notify pipe"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 设置线程管道的读写入口 */</span></span><br><span class="line">    threads[i].notify_receive_fd = fds[<span class="number">0</span>];</span><br><span class="line">    threads[i].notify_send_fd = fds[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*  设置线程属性 */</span></span><br><span class="line">    setup_thread(&amp;threads[i]);</span><br><span class="line">    <span class="comment">/* Reserve three fds for the libevent base, and two for the pipe */</span></span><br><span class="line">    stats.reserved_fds += <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="设置线程属性"><a href="#设置线程属性" class="headerlink" title="设置线程属性"></a>设置线程属性</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Set up a thread's information.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setup_thread</span><span class="params">(LIBEVENT_THREAD *me)</span> </span>&#123;</span><br><span class="line">    me-&gt;base = event_init(); <span class="comment">//初始化线程事件</span></span><br><span class="line">    <span class="keyword">if</span> (! me-&gt;base) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Can't allocate event base\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 初始化监听事件 */</span></span><br><span class="line">    <span class="comment">/* Listen for notifications from other threads */</span></span><br><span class="line">    event_set(&amp;me-&gt;notify_event, me-&gt;notify_receive_fd,</span><br><span class="line">              EV_READ | EV_PERSIST, thread_libevent_process, me);</span><br><span class="line">    <span class="comment">/* 把事件绑定到线程事件 */</span></span><br><span class="line">    event_base_set(me-&gt;base, &amp;me-&gt;notify_event);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 注册事件到监听状态 */</span></span><br><span class="line">    <span class="keyword">if</span> (event_add(&amp;me-&gt;notify_event, <span class="number">0</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Can't monitor libevent notify pipe\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="READ回调函数"><a href="#READ回调函数" class="headerlink" title="READ回调函数"></a>READ回调函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Processes an incoming "handle a new connection" item. This is called when</span></span><br><span class="line"><span class="comment"> * input arrives on the libevent wakeup pipe.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">thread_libevent_process</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">short</span> which, <span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 从管道读取消息 */</span></span><br><span class="line">    <span class="keyword">if</span> (read(fd, buf, <span class="number">1</span>) != <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> (settings.verbose &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Can't read from libevent pipe\n"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    item = cq_pop(me-&gt;new_conn_queue); <span class="comment">//读取连接</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="启动工作者线程"><a href="#启动工作者线程" class="headerlink" title="启动工作者线程"></a>启动工作者线程</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Create threads after we've done all the libevent setup. */</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nthreads; i++) &#123;</span><br><span class="line">     create_worker(worker_libevent, &amp;threads[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>create_woker</code>函数创建工作者线程，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Creates a worker thread.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">static void create_worker(void *(*func)(void *), void *arg) &#123;</span><br><span class="line">    <span class="keyword">pthread_t</span>       thread;</span><br><span class="line">    <span class="keyword">pthread_attr_t</span>  attr;</span><br><span class="line">    <span class="keyword">int</span>             ret;</span><br><span class="line"></span><br><span class="line">    pthread_attr_init(&amp;attr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((ret = pthread_create(&amp;thread, &amp;attr, func, arg)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Can't create thread: %s\n"</span>,</span><br><span class="line">                strerror(ret));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>worker_libevent</code>函数进入线程循环监听状态，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Worker thread: main event loop</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">worker_libevent</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    LIBEVENT_THREAD *me = arg;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Any per-thread setup can happen here; thread_init() will block until</span></span><br><span class="line"><span class="comment">     * all threads have finished initializing.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* set an indexable thread-specific memory item for the lock type.</span></span><br><span class="line"><span class="comment">     * this could be unnecessary if we pass the conn *c struct through</span></span><br><span class="line"><span class="comment">     * all item_lock calls...</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    me-&gt;item_lock_type = ITEM_LOCK_GRANULAR;</span><br><span class="line">    pthread_setspecific(item_lock_type_key, &amp;me-&gt;item_lock_type);</span><br><span class="line"></span><br><span class="line">    register_thread_initialized();</span><br><span class="line"></span><br><span class="line">    event_base_loop(me-&gt;base, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="主线程"><a href="#主线程" class="headerlink" title="主线程"></a>主线程</h2><h3 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">event_base</span>* <span class="title">mian_base</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* initialize main thread libevent instance */</span></span><br><span class="line">main_base = event_init();</span><br></pre></td></tr></table></figure>
<p>在<code>memcached.c</code>的主函数中，使用<code>libevent</code>的事件初始化函数来初始化<code>main_base</code>。</p>
<h3 id="初始化socket"><a href="#初始化socket" class="headerlink" title="初始化socket"></a>初始化socket</h3><p>这里只介绍tcp连接，其中使用<code>server_sockets</code>来调用<code>server_socket</code>来初始化连接。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (settings.port &amp;&amp; server_sockets(settings.port, tcp_transport,  portnumber_file)) &#123;</span><br><span class="line">            vperror(<span class="string">"failed to listzhefen on TCP port %d"</span>, settings.port);</span><br><span class="line">            <span class="built_in">exit</span>(EX_OSERR);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">server_sockets</span><span class="params">(<span class="keyword">int</span> port, <span class="keyword">enum</span> network_transport transport,</span></span></span><br><span class="line"><span class="function"><span class="params">                          FILE *portnumber_file)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (settings.inter == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> server_socket(settings.inter, port, transport, portnumber_file);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而在<code>server_socket</code>中完成了socket的初始化、绑定等操作。</p>
<h3 id="主线程事件"><a href="#主线程事件" class="headerlink" title="主线程事件"></a>主线程事件</h3><p>在主线程中通过<code>conn_new</code>函数来建立主线程和工作者线程之间的关系。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 设置线程事件 */</span></span><br><span class="line">event_set(&amp;c-&gt;event, sfd, event_flags, event_handler, (<span class="keyword">void</span> *)c);</span><br><span class="line">event_base_set(base, &amp;c-&gt;event);</span><br><span class="line">c-&gt;ev_flags = event_flags;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 注册事件到监听 */</span></span><br><span class="line"><span class="keyword">if</span> (event_add(&amp;c-&gt;event, <span class="number">0</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">"event_add"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h3><p>上面中设置了事件的回调函数<code>event_handler</code>，而在<code>event_handler</code>中，主要调用了<code>driver_machine</code>函数。</p>
<p>driver_machine看名字就知道，想发动机一样的函数，那么该函数主要是处理各种事件以及相应的处理方法。</p>
<p>这里只简要介绍一个函数调用<code>dispatch_conn_new</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatch_conn_new</span><span class="params">(<span class="keyword">int</span> sfd, <span class="keyword">enum</span> conn_states init_state, <span class="keyword">int</span> event_flags,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">int</span> read_buffer_size, <span class="keyword">enum</span> network_transport transport)</span> </span>&#123;</span><br><span class="line">    CQ_ITEM *item = cqi_new();</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (item == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        close(sfd);</span><br><span class="line">        <span class="comment">/* given that malloc failed this may also fail, but let's try */</span></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Failed to allocate memory for connection object\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> tid = (last_thread + <span class="number">1</span>) % settings.num_threads;</span><br><span class="line"></span><br><span class="line">    LIBEVENT_THREAD *thread = threads + tid; <span class="comment">//循环获取工作者线程</span></span><br><span class="line"></span><br><span class="line">    last_thread = tid;</span><br><span class="line"></span><br><span class="line">    item-&gt;sfd = sfd;</span><br><span class="line">    item-&gt;init_state = init_state;</span><br><span class="line">    item-&gt;event_flags = event_flags;</span><br><span class="line">    item-&gt;read_buffer_size = read_buffer_size;</span><br><span class="line">    item-&gt;transport = transport;</span><br><span class="line"></span><br><span class="line">    cq_push(thread-&gt;new_conn_queue, item); <span class="comment">//连接加入懂啊队列</span></span><br><span class="line"></span><br><span class="line">    memcachedD_CONN_DISPATCH(sfd, thread-&gt;thread_id);</span><br><span class="line">    buf[<span class="number">0</span>] = <span class="string">'c'</span>;</span><br><span class="line">    <span class="keyword">if</span> (write(thread-&gt;notify_send_fd, buf, <span class="number">1</span>) != <span class="number">1</span>) &#123;<span class="comment">//向管道写入消息</span></span><br><span class="line">        perror(<span class="string">"Writing to thread notify pipe"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> cache </category>
            
        </categories>
        
        
        <tags>
            
            <tag> memcache </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[memcache 概述]]></title>
      <url>/2015/02/07/memcache-summary/</url>
      <content type="html"><![CDATA[<p>memcache是一种支持分布式的缓存系统，基于网络连接（当然它也可以使用localhost）方式完成服务，本身它是一个独立于应用的程序或守护进程（Daemon方式）。<br><a id="more"></a></p>
<h2 id="本地缓存"><a href="#本地缓存" class="headerlink" title="本地缓存"></a>本地缓存</h2><p>memcached是“分布式”的内存对象缓存系统，那么就是说，那些不需要“分布”的，不需要共享的，或者干脆规模小到只有一台服务器的应用，memcached不会带来任何好处，相反还会拖慢系统效率，因为网络连接同样需要资源，即使是UNIX本地连接也一样。memcached本地读写速度要比直接PHP内存数组慢几十倍，而APC、共享内存方式都和直接数组差不多。可见，如果只是本地级缓存，使用memcached是非常不划算的。</p>
<h2 id="并发连接"><a href="#并发连接" class="headerlink" title="并发连接"></a>并发连接</h2><p>memcached使用libevent库实现网络连接服务，理论上可以处理无限多的连接，但是它和Apache不同，它更多的时候是面向稳定的持续连接的，所以它实际的并发能力是有限制的。在保守情况下memcached的最大同时连接数为200，这和Linux线程能力有关系，这个数值是可以调整的。关于libevent可以参考相关文档。</p>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p>memcached内存使用方式也和APC不同。APC是基于共享内存和MMAP的，memcachd有自己的内存分配算法和管理方式，它和共享内存没有关系，也没有共享内存的限制，通常情况下，每个memcached进程可以管理2GB的内存空间，如果需要更多的空间，可以增加进程数。</p>
<h2 id="降低数据库压力"><a href="#降低数据库压力" class="headerlink" title="降低数据库压力"></a>降低数据库压力</h2><p>memcached在很多时候都是作为数据库前端cache使用的。因为它比数据库少了很多SQL解析、磁盘操作等开销，而且它是使用内存来管理数据的，所以它可以提供比直接读取数据库更好的性能，在大型系统中，访问同样的数据是很频繁的，memcached可以大大降低数据库压力，使系统执行效率提升。</p>
<p>memcached也经常作为服务器之间数据共享的存储媒介，例如在SSO系统中保存系统单点登陆状态的数据就可以保存在memcached中，被多个应用共享。</p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>由于memcache是分布式的，在web项目中可以为不同的服务器提供共享资源。<br>由于memcache是把数据直接存储在内存中，那么为了降低数据库的压力，可以再web与数据库之间增加一层memcache缓存。而且在memcache中，内存中存储的数据是根据哈希来实现存储的，那么这样查找数据的销量就会远远高于数据库。</p>
]]></content>
      
        <categories>
            
            <category> cache </category>
            
        </categories>
        
        
        <tags>
            
            <tag> memcache </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[python 文件操作]]></title>
      <url>/2014/12/04/python-file-operate/</url>
      <content type="html"><![CDATA[<p>python文件相关操作涉及到的函数介绍。<br><a id="more"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"># os 模块</span><br><span class="line"></span><br><span class="line">os.sep 可以取代操作系统特定的路径分隔符。windows下为 &apos;\\&apos;</span><br><span class="line">os.name 字符串指示你正在使用的平台。比如对于Windows，它是&apos;nt&apos;，而对于Linux/Unix用户，它是 &apos;posix&apos;</span><br><span class="line">os.getcwd() 函数得到当前工作目录，即当前Python脚本工作的目录路径</span><br><span class="line">os.getenv() 获取一个环境变量，如果没有返回none</span><br><span class="line">os.putenv(key, value) 设置一个环境变量值</span><br><span class="line">os.listdir(path) 返回指定目录下的所有文件和目录名</span><br><span class="line">os.remove(path) 函数用来删除一个文件</span><br><span class="line">os.system(command) 函数用来运行shell命令</span><br><span class="line">os.linesep 字符串给出当前平台使用的行终止符。例如，Windows使用 &apos;\r\n&apos;，Linux使用 &apos;\n&apos; 而Mac使用 &apos;\r&apos;</span><br><span class="line">os.path.split(path)  函数返回一个路径的目录名和文件名</span><br><span class="line">os.path.isfile() 和os.path.isdir()函数分别检验给出的路径是一个文件还是目录</span><br><span class="line">os.path.exists() 函数用来检验给出的路径是否真地存在</span><br><span class="line">os.curdir  返回当前目录 (&apos;.&apos;)</span><br><span class="line">os.mkdir(path) 创建一个目录</span><br><span class="line">os.makedirs(path) 递归的创建目录</span><br><span class="line">os.chdir(dirname) 改变工作目录到dirname    </span><br><span class="line">os.path.getsize(name) 获得文件大小，如果name是目录返回0L</span><br><span class="line">os.path.abspath(name) 获得绝对路径</span><br><span class="line">os.path.normpath(path) 规范path字符串形式</span><br><span class="line">os.path.splitext()  分离文件名与扩展名</span><br><span class="line">os.path.join(path,name) 连接目录与文件名或目录</span><br><span class="line">os.path.basename(path) 返回文件名</span><br><span class="line">os.path.dirname(path) 返回文件路径</span><br><span class="line">os.walk(top,topdown=True,onerror=None)  遍历迭代目录</span><br><span class="line">os.rename(src, dst)  重命名file或者directory src到dst 如果dst是一个存在的directory, 将抛出OSError. 在Unix, 如果dst在存且是一个file, 如果用户有权限的话，它将被安静的替换. 操作将会失败在某些Unix 中如果src和dst在不同的文件系统中. 如果成功, 这命名操作将会是一个原子操作 (这是POSIX 需要). 在 Windows上, 如果dst已经存在, 将抛出OSError，即使它是一个文件. 在unix，Windows中有效。</span><br><span class="line">os.renames(old, new) 递归重命名文件夹或者文件。像rename()</span><br><span class="line"></span><br><span class="line"># shutil 模块</span><br><span class="line"></span><br><span class="line">shutil.copyfile( src, dst) 从源src复制到dst中去。当然前提是目标地址是具备可写权限。抛出的异常信息为IOException. 如果当前的dst已存在的话就会被覆盖掉</span><br><span class="line">shutil.move( src, dst)  移动文件或重命名</span><br><span class="line">shutil.copymode( src, dst) 只是会复制其权限其他的东西是不会被复制的</span><br><span class="line">shutil.copystat( src, dst) 复制权限、最后访问时间、最后修改时间</span><br><span class="line">shutil.copy( src, dst)  复制一个文件到一个文件或一个目录</span><br><span class="line">shutil.copy2( src, dst)  在copy上的基础上再复制文件最后访问时间与修改时间也复制过来了，类似于cp –p的东西</span><br><span class="line">shutil.copy2( src, dst)  如果两个位置的文件系统是一样的话相当于是rename操作，只是改名；如果是不在相同的文件系统的话就是做move操作</span><br><span class="line">shutil.copytree( olddir, newdir, True/Flase)</span><br><span class="line">把olddir拷贝一份newdir，如果第3个参数是True，则复制目录时将保持文件夹下的符号连接，如果第3个参数是False，则将在复制的目录下生成物理副本来替代符号连接</span><br><span class="line">shutil.rmtree( src ) 递归删除一个目录以及目录内的所有内容</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[python 装饰器]]></title>
      <url>/2014/11/09/python-decorator/</url>
      <content type="html"><![CDATA[<p>python装饰器为python提供了一种语法糖，本质上是一个Python函数，它可以让其他函数在不需要做任何代码变动的前提下增加额外功能，装饰器的返回值也是一个函数对象。<br><a id="more"></a></p>
<h2 id="未使用装饰器的函数嵌套"><a href="#未使用装饰器的函数嵌套" class="headerlink" title="未使用装饰器的函数嵌套"></a>未使用装饰器的函数嵌套</h2><p>deco运行，但myfunc并没有运行</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deco</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'before func'</span></span><br><span class="line">    <span class="keyword">return</span> func </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myfunc</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'myfunc() called'</span></span><br><span class="line"> </span><br><span class="line">myfunc = deco(myfunc)</span><br></pre></td></tr></table></figure>
<p>需要的deco中调用myfunc，这样才可以执行</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deco</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'before func'</span></span><br><span class="line">    func()</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'after func'</span></span><br><span class="line">    <span class="keyword">return</span> func </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myfunc</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'myfunc() called'</span></span><br><span class="line"> </span><br><span class="line">myfunc = deco(myfunc)</span><br></pre></td></tr></table></figure>
<h2 id="使用装饰器"><a href="#使用装饰器" class="headerlink" title="使用装饰器"></a>使用装饰器</h2><p>@函数名 但是它执行了两次</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deco</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'before func'</span></span><br><span class="line">    func()</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'after func'</span></span><br><span class="line">    <span class="keyword">return</span> func </span><br><span class="line"></span><br><span class="line"><span class="meta">@deco</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myfunc</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'myfunc() called'</span></span><br><span class="line"></span><br><span class="line">myfunc()</span><br></pre></td></tr></table></figure>
<p><strong>正确的用法</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deco</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_deco</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'before func'</span></span><br><span class="line">        func()</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'after func'</span></span><br><span class="line">    <span class="keyword">return</span> _deco </span><br><span class="line"></span><br><span class="line"><span class="meta">@deco</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myfunc</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'myfunc() called'</span></span><br><span class="line"> </span><br><span class="line">myfunc()</span><br></pre></td></tr></table></figure>
<h2 id="带参数的装饰器"><a href="#带参数的装饰器" class="headerlink" title="带参数的装饰器"></a>带参数的装饰器</h2><p>@带参数，使用嵌套的方法，其中装饰器有参数，函数无参数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deco</span><span class="params">(arg)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_deco</span><span class="params">(func)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> arg</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__deco</span><span class="params">()</span>:</span></span><br><span class="line">            <span class="keyword">print</span> <span class="string">'before func'</span></span><br><span class="line">            func()</span><br><span class="line">            <span class="keyword">print</span> <span class="string">'after func'</span></span><br><span class="line">        <span class="keyword">return</span> __deco</span><br><span class="line">    <span class="keyword">return</span> _deco </span><br><span class="line"></span><br><span class="line"><span class="meta">@deco('deco')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myfunc</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'myfunc() called'</span></span><br><span class="line"> </span><br><span class="line">myfunc()</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line"><span class="comment">## 函数参数传递，装饰器和函数均有参数</span></span><br><span class="line"></span><br><span class="line">只有一个固定参数arg和str</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deco</span><span class="params">(arg)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_deco</span><span class="params">(func)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> arg</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__deco</span><span class="params">(str)</span>:</span></span><br><span class="line">            <span class="keyword">print</span> <span class="string">'before func'</span></span><br><span class="line">            func(str)</span><br><span class="line">            <span class="keyword">print</span> <span class="string">'after func'</span></span><br><span class="line">        <span class="keyword">return</span> __deco</span><br><span class="line">    <span class="keyword">return</span> _deco </span><br><span class="line"></span><br><span class="line"><span class="meta">@deco('deco')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myfunc</span><span class="params">(str)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'myfunc() called '</span>, str</span><br><span class="line"> </span><br><span class="line">myfunc(<span class="string">'hello'</span>)</span><br></pre></td></tr></table></figure>
<p>未知参数个数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deco</span><span class="params">(arg)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_deco</span><span class="params">(func)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> arg</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__deco</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">            <span class="keyword">print</span> <span class="string">'before func'</span></span><br><span class="line">            func(*args, **kwargs)</span><br><span class="line">            <span class="keyword">print</span> <span class="string">'after func'</span></span><br><span class="line">        <span class="keyword">return</span> __deco</span><br><span class="line">    <span class="keyword">return</span> _deco </span><br><span class="line"></span><br><span class="line"><span class="meta">@deco('deco1')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myfunc1</span><span class="params">(str)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'myfunc1() called '</span>, str</span><br><span class="line"></span><br><span class="line"><span class="meta">@deco('deco2')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myfunc2</span><span class="params">(str1,str2)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'myfunc2() called '</span>, str1, str2</span><br><span class="line"> </span><br><span class="line">myfunc1(<span class="string">'hello'</span>)</span><br><span class="line"> </span><br><span class="line">myfunc2(<span class="string">'hello'</span>, <span class="string">'world'</span>)</span><br></pre></td></tr></table></figure>
<h2 id="class作为修饰器"><a href="#class作为修饰器" class="headerlink" title="class作为修饰器"></a>class作为修饰器</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myDecorator</span><span class="params">(object)</span>:</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, fn)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"inside myDecorator.__init__()"</span></span><br><span class="line">        self.fn = fn</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.fn()</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"inside myDecorator.__call__()"</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">@myDecorator</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">aFunction</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"inside aFunction()"</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">print</span> <span class="string">"Finished decorating aFunction()"</span></span><br><span class="line"> </span><br><span class="line">aFunction()</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myDecorator</span><span class="params">(object)</span>:</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, str)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"inside myDecorator.__init__()"</span></span><br><span class="line">        self.str = str</span><br><span class="line">        <span class="keyword">print</span> self.str</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, fn)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapped</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">            fn()</span><br><span class="line">            <span class="keyword">print</span> <span class="string">"inside myDecorator.__call__()"</span></span><br><span class="line">        <span class="keyword">return</span> wrapped</span><br><span class="line"> </span><br><span class="line"><span class="meta">@myDecorator('this is str')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">aFunction</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"inside aFunction()"</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">print</span> <span class="string">"Finished decorating aFunction()"</span></span><br><span class="line"> </span><br><span class="line">aFunction()</span><br></pre></td></tr></table></figure>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><h3 id="给函数做缓存-—-斐波拉契数列"><a href="#给函数做缓存-—-斐波拉契数列" class="headerlink" title="给函数做缓存 — 斐波拉契数列"></a>给函数做缓存 — 斐波拉契数列</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">memo</span><span class="params">(fn)</span>:</span></span><br><span class="line">    cache = &#123;&#125;</span><br><span class="line">    miss = object()</span><br><span class="line">     </span><br><span class="line"><span class="meta">    @wraps(fn)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args)</span>:</span></span><br><span class="line">        result = cache.get(args, miss)</span><br><span class="line">        <span class="keyword">if</span> result <span class="keyword">is</span> miss:</span><br><span class="line">            result = fn(*args)</span><br><span class="line">            cache[args] = result</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"> </span><br><span class="line"><span class="meta">@memo</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    <span class="keyword">return</span> fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> fib(<span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<h3 id="注册回调函数-—-web请求回调"><a href="#注册回调函数-—-web请求回调" class="headerlink" title="注册回调函数 — web请求回调"></a>注册回调函数 — web请求回调</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class MyApp():</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.func_map = &#123;&#125;</span><br><span class="line"> </span><br><span class="line">    def register(self, name):</span><br><span class="line">        def func_wrapper(func):</span><br><span class="line">            self.func_map[name] = func</span><br><span class="line">            return func</span><br><span class="line">        return func_wrapper</span><br><span class="line"> </span><br><span class="line">    def call_method(self, name=None):</span><br><span class="line">        func = self.func_map.get(name, None)</span><br><span class="line">        if func is None:</span><br><span class="line">            raise Exception(&quot;No function registered against - &quot; + str(name))</span><br><span class="line">        return func()</span><br><span class="line"> </span><br><span class="line">app = MyApp()</span><br><span class="line"> </span><br><span class="line">@app.register(&apos;/&apos;)</span><br><span class="line">def main_page_func():</span><br><span class="line">    return &quot;This is the main page.&quot;</span><br><span class="line"> </span><br><span class="line">@app.register(&apos;/next_page&apos;)</span><br><span class="line">def next_page_func():</span><br><span class="line">    return &quot;This is the next page.&quot;</span><br><span class="line"> </span><br><span class="line">print app.call_method(&apos;/&apos;)</span><br><span class="line">print app.call_method(&apos;/next_page&apos;)</span><br></pre></td></tr></table></figure>
<h3 id="mysql封装-–-很好用"><a href="#mysql封装-–-很好用" class="headerlink" title="mysql封装 – 很好用"></a>mysql封装 – 很好用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">import umysql</span><br><span class="line">from functools import wraps</span><br><span class="line"> </span><br><span class="line">class Configuraion:</span><br><span class="line">    def __init__(self, env):</span><br><span class="line">        if env == &quot;Prod&quot;:</span><br><span class="line">            self.host    = &quot;coolshell.cn&quot;</span><br><span class="line">            self.port    = 3306</span><br><span class="line">            self.db      = &quot;coolshell&quot;</span><br><span class="line">            self.user    = &quot;coolshell&quot;</span><br><span class="line">            self.passwd  = &quot;fuckgfw&quot;</span><br><span class="line">        elif env == &quot;Test&quot;:</span><br><span class="line">            self.host   = &apos;localhost&apos;</span><br><span class="line">            self.port   = 3300</span><br><span class="line">            self.user   = &apos;coolshell&apos;</span><br><span class="line">            self.db     = &apos;coolshell&apos;</span><br><span class="line">            self.passwd = &apos;fuckgfw&apos;</span><br><span class="line"> </span><br><span class="line">def mysql(sql):</span><br><span class="line"> </span><br><span class="line">    _conf = Configuraion(env=&quot;Prod&quot;)</span><br><span class="line"> </span><br><span class="line">    def on_sql_error(err):</span><br><span class="line">        print err</span><br><span class="line">        sys.exit(-1)</span><br><span class="line"> </span><br><span class="line">    def handle_sql_result(rs):</span><br><span class="line">        if rs.rows &gt; 0:</span><br><span class="line">            fieldnames = [f[0] for f in rs.fields]</span><br><span class="line">            return [dict(zip(fieldnames, r)) for r in rs.rows]</span><br><span class="line">        else:</span><br><span class="line">            return []</span><br><span class="line"> </span><br><span class="line">    def decorator(fn):</span><br><span class="line">        @wraps(fn)</span><br><span class="line">        def wrapper(*args, **kwargs):</span><br><span class="line">            mysqlconn = umysql.Connection()</span><br><span class="line">            mysqlconn.settimeout(5)</span><br><span class="line">            mysqlconn.connect(_conf.host, _conf.port, _conf.user, \</span><br><span class="line">                              _conf.passwd, _conf.db, True, &apos;utf8&apos;)</span><br><span class="line">            try:</span><br><span class="line">                rs = mysqlconn.query(sql, &#123;&#125;)      </span><br><span class="line">            except umysql.Error as e:</span><br><span class="line">                on_sql_error(e)</span><br><span class="line"> </span><br><span class="line">            data = handle_sql_result(rs)</span><br><span class="line">            kwargs[&quot;data&quot;] = data</span><br><span class="line">            result = fn(*args, **kwargs)</span><br><span class="line">            mysqlconn.close()</span><br><span class="line">            return result</span><br><span class="line">        return wrapper</span><br><span class="line"> </span><br><span class="line">    return decorator</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">@mysql(sql = &quot;select * from coolshell&quot; )</span><br><span class="line">def get_coolshell(data):</span><br><span class="line">    ... ...</span><br><span class="line">    ... ..</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">### 线程异步</span><br><span class="line"></span><br><span class="line">from threading import Thread</span><br><span class="line">from functools import wraps</span><br><span class="line"> </span><br><span class="line">def async(func):</span><br><span class="line">    @wraps(func)</span><br><span class="line">    def async_func(*args, **kwargs):</span><br><span class="line">        func_hl = Thread(target = func, args = args, kwargs = kwargs)</span><br><span class="line">        func_hl.start()</span><br><span class="line">        return func_hl</span><br><span class="line"> </span><br><span class="line">    return async_func</span><br><span class="line"> </span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    from time import sleep</span><br><span class="line"> </span><br><span class="line">    @async</span><br><span class="line">    def print_somedata():</span><br><span class="line">        print &apos;starting print_somedata&apos;</span><br><span class="line">        sleep(2)</span><br><span class="line">        print &apos;print_somedata: 2 sec passed&apos;</span><br><span class="line">        sleep(2)</span><br><span class="line">        print &apos;print_somedata: 2 sec passed&apos;</span><br><span class="line">        sleep(2)</span><br><span class="line">        print &apos;finished print_somedata&apos;</span><br><span class="line"> </span><br><span class="line">    def main():</span><br><span class="line">        print_somedata()</span><br><span class="line">        print &apos;back in main&apos;</span><br><span class="line">        print_somedata()</span><br><span class="line">        print &apos;back in main&apos;</span><br><span class="line"> </span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>注意functools.wraps()函数的作用：调用经过装饰的函数，相当于调用一个新函数，那查看函数参数，注释，甚至函数名的时候，就只能看到装饰器的相关信息，被包装函数的信息被丢掉了。</p>
<p>而wraps则可以帮你转移这些信息，具体参见<a href="http://stackoverflow.com/questions/308999/what-does-functools-wraps-do" target="_blank" rel="external">http://stackoverflow.com/questions/308999/what-does-functools-wraps-do</a> </p>
]]></content>
      
        <categories>
            
            <category> python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[python 序列]]></title>
      <url>/2014/11/01/python-list/</url>
      <content type="html"><![CDATA[<p>序列<code>list</code>是python中最基本的数据结构，序列都可以进行的操作包括索引，切片，加，乘，检查成员。<br><a id="more"></a><br>列表生成式即List Comprehensions，是Python内置的非常简单却强大的可以用来创建list的生成式。</p>
<h2 id="一个循环"><a href="#一个循环" class="headerlink" title="一个循环"></a>一个循环</h2><p>在C语言等其他语言中，for循环一般是这样的</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">x = list()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>)</span><br><span class="line">    x.append(x)</span><br><span class="line">```　　</span><br><span class="line"></span><br><span class="line">如果python也这么写，那么真该看下python的基础教程了~</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">x = [x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br></pre></td></tr></table></figure>
<p>　　<br>在上面的例子中，不仅可以嵌套for，甚至可以嵌套if语句</p>
<p>再看看，原来是什么样子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = [x for x in range(10) if x &gt; 5]</span><br></pre></td></tr></table></figure></p>
<p>　　</p>
<h2 id="两个循环呢？"><a href="#两个循环呢？" class="headerlink" title="两个循环呢？"></a>两个循环呢？</h2><p>原来可能是这样的？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x = list()</span><br><span class="line">for i in range(10):</span><br><span class="line">    for j in range(10):</span><br><span class="line">    	x.append(i + j)</span><br><span class="line">```　　</span><br><span class="line"></span><br><span class="line">现在可以这样了！！！</span><br></pre></td></tr></table></figure>
<p>x = [x + y for x in range(10) for y in range(10)]<br>```</p>
]]></content>
      
        <categories>
            
            <category> python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[webpy中的session实现]]></title>
      <url>/2014/10/22/python-webpy-session/</url>
      <content type="html"><![CDATA[<p>虽然工作中使用的是django，但是自己并不喜欢那种大而全的东西~什么都给你准备好了，自己好像一个机器人一样赶着重复的基本工作，从在学校时候就养成了追究原理的习惯，从而有了这篇session的使用和说明。<br><a id="more"></a></p>
<h2 id="webpy中的session"><a href="#webpy中的session" class="headerlink" title="webpy中的session"></a>webpy中的session</h2><p>下面为官方的例子，用session来存储页面访问的次数，从而实现对访问次数的记录。</p>
<p>需要注意的是，官方说明在调试情况下，session并不能正常的运行，所以需要在非调试摸下测试，那么就有了下面的这个例子。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> web</span><br><span class="line"></span><br><span class="line"><span class="comment">#非调试模式</span></span><br><span class="line">web.config.debug = <span class="keyword">False</span></span><br><span class="line">urls = (</span><br><span class="line">    <span class="string">"/count"</span>, <span class="string">"count"</span>,</span><br><span class="line">    <span class="string">"/reset"</span>, <span class="string">"reset"</span></span><br><span class="line">)</span><br><span class="line">app = web.application(urls, locals())</span><br><span class="line">session = web.session.Session(app, web.session.DiskStore(<span class="string">'sessions'</span>), initializer=&#123;<span class="string">'count'</span>: <span class="number">0</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">count</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GET</span><span class="params">(self)</span>:</span></span><br><span class="line">        session.count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> str(session.count)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">reset</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GET</span><span class="params">(self)</span>:</span></span><br><span class="line">        session.kill()</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure>
<p>在官方文档中，对上述debug模式的现象给出了这样的解释：</p>
<blockquote>
<p>session与调试模试下的重调用相冲突(有点类似firefox下著名的Firebug插件，使用Firebug插件分析网页时，会在火狐浏览器之外单独对该网页发起请求，所以相当于同时访问该网页两次)<br>　　<br>为了解决上述问题，官方给出了进一步的解决方法，如下</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> web</span><br><span class="line"></span><br><span class="line">urls = (<span class="string">"/"</span>, <span class="string">"hello"</span>)</span><br><span class="line"></span><br><span class="line">app = web.application(urls, globals())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> web.config.get(<span class="string">'_session'</span>) <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">    session = web.session.Session(app, web.session.DiskStore(<span class="string">'sessions'</span>), &#123;<span class="string">'count'</span>: <span class="number">0</span>&#125;)</span><br><span class="line">    web.config._session = session</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    session = web.config._session</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">hello</span>:</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">GET</span><span class="params">(self)</span>:</span></span><br><span class="line">       <span class="keyword">print</span> <span class="string">'session'</span>, session</span><br><span class="line">       session.count += <span class="number">1</span></span><br><span class="line">       <span class="keyword">return</span> <span class="string">'Hello, %s!'</span> % session.count</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">   app.run()</span><br></pre></td></tr></table></figure>
<p>由于web.session.Session会重载两次，但是在上面的_session并不会重载两次，因为上面多了一个判断_session是否存在于web.config中。</p>
<p>其实，在web.py文件中，定义了config，而Storage在下面的图中并没有特殊的结果，像字典一样~</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#web.py</span><br><span class="line">config = storage()</span><br><span class="line"></span><br><span class="line">#utils.py</span><br><span class="line">storage = Storage</span><br></pre></td></tr></table></figure>
<h2 id="webpy的子程序中使用session"><a href="#webpy的子程序中使用session" class="headerlink" title="webpy的子程序中使用session"></a>webpy的子程序中使用session</h2><p>虽然官方文档中提到，只能在主程序中使用session，但是通过添加<code>__init__.py</code>可以条用到该页面的session，也就是说一样使用session。</p>
<p>官方给出的方法更加合理化一点，通过应用处理器，加载钩子(loadhooks)</p>
<p>在webpy中，应用处理器为<code>app.add_processor(my_processor)</code>，下面的代码添加到上述的完整例子中，可以再处理请求前和处理请求后分别条用<code>my_loadhook()``和my_unloadhook()</code>,</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_loadhook</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"my load hook"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_unloadhook</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"my unload hook"</span></span><br><span class="line"></span><br><span class="line">app.add_processor(web.loadhook(my_loadhook))</span><br><span class="line">app.add_processor(web.unloadhook(my_unloadhook))</span><br></pre></td></tr></table></figure>
<p>从而，可以再web.loadhook()中加载session信息，在处理之前从web.ctx.session中获取session了，甚至可以在应用处理器中添加认证等操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#main.py</span><br><span class="line">def session_hook():</span><br><span class="line">　　web.ctx.session = session</span><br><span class="line">app.add_processor(web.loadhook(session_hook))</span><br><span class="line"></span><br><span class="line">#views.py</span><br><span class="line">class edit:</span><br><span class="line">    def GET(self):</span><br><span class="line">        try:</span><br><span class="line">            session = web.ctx.session</span><br><span class="line">            username = session.username</span><br><span class="line">            if not username:</span><br><span class="line">                return web.redirect(&apos;/login&apos;)</span><br><span class="line">        except Exception as e:</span><br><span class="line">            return web.redirect(&apos;/login&apos;)</span><br><span class="line">        return render_template(&apos;edit.html&apos;)</span><br></pre></td></tr></table></figure>
<h2 id="session-id"><a href="#session-id" class="headerlink" title="session id"></a>session id</h2><p>对于服务器来说，怎样才能区分不同客户端呢，怎样才能区分不同客户端的session呢？</p>
<p>是通过sessionid来实现的，最初我还傻傻的分不清session和cookie，以及不同用户之间的信息室如何分配的！</p>
<p>生成sessionid的代码段，其中包含了随机数、时间、ip以及秘钥,</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_generate_session_id</span><span class="params">(self)</span>:</span></span><br><span class="line">	<span class="string">"""Generate a random id for session"""</span></span><br><span class="line">	<span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">		rand = os.urandom(<span class="number">16</span>)</span><br><span class="line">		now = time.time()</span><br><span class="line">		secret_key = self._config.secret_key</span><br><span class="line">		session_id = sha1(<span class="string">"%s%s%s%s"</span> % (rand, now, utils.safestr(web.ctx.ip), secret_key))</span><br><span class="line">		session_id = session_id.hexdigest()</span><br><span class="line">		<span class="keyword">if</span> session_id <span class="keyword">not</span> <span class="keyword">in</span> self.store:</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">	<span class="keyword">return</span> session_id</span><br></pre></td></tr></table></figure>
<p>　　<br>在客户端访问服务器时，服务器会根据上述信息来计算一个针对客户端唯一的sessionid，并通过cookie保存在客户端中。</p>
<p>客户端用cookie保存了sessionID，当我们请求服务器的时候，会把这个sessionID一起发给服务器，服务器会到内存中搜索对应的sessionID，如果找到了对应的 sessionID，说明我们处于登录状态，有相应的权限；如果没有找到对应的sessionID，这说明：要么是我们把浏览器关掉了（后面会说明为什 么），要么session超时了（没有请求服务器超过20分钟），session被服务器清除了，则服务器会给你分配一个新的sessionID。你得重新登录并把这个新的sessionID保存在cookie中。 </p>
<h2 id="session的结构"><a href="#session的结构" class="headerlink" title="session的结构"></a>session的结构</h2><p>上面提到了session在webpy中式一种dict的方式存储，</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Session</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""Session management for web.py</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    __slots__ = [</span><br><span class="line">        <span class="string">"store"</span>, <span class="string">"_initializer"</span>, <span class="string">"_last_cleanup_time"</span>, <span class="string">"_config"</span>, <span class="string">"_data"</span>, </span><br><span class="line">        <span class="string">"__getitem__"</span>, <span class="string">"__setitem__"</span>, <span class="string">"__delitem__"</span></span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, app, store, initializer=None)</span>:</span></span><br><span class="line">        self.store = store</span><br><span class="line">        self._initializer = initializer</span><br><span class="line">        self._last_cleanup_time = <span class="number">0</span></span><br><span class="line">        self._config = utils.storage(web.config.session_parameters)</span><br><span class="line">        self._data = utils.threadeddict()</span><br><span class="line">        </span><br><span class="line">        self.__getitem__ = self._data.__getitem__</span><br><span class="line">        self.__setitem__ = self._data.__setitem__</span><br><span class="line">        self.__delitem__ = self._data.__delitem__</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> app:</span><br><span class="line">            app.add_processor(self._processor)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__contains__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> name <span class="keyword">in</span> self._data</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> getattr(self._data, name)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setattr__</span><span class="params">(self, name, value)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> name <span class="keyword">in</span> self.__slots__:</span><br><span class="line">            object.__setattr__(self, name, value)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            setattr(self._data, name, value)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__delattr__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        delattr(self._data, name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_processor</span><span class="params">(self, handler)</span>:</span></span><br><span class="line">        <span class="string">"""Application processor to setup session for every request"""</span></span><br><span class="line">        self._cleanup()</span><br><span class="line">        self._load()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> handler()</span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            self._save()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_load</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Load the session from the store, by the id from cookie"""</span></span><br><span class="line">        cookie_name = self._config.cookie_name</span><br><span class="line">        cookie_domain = self._config.cookie_domain</span><br><span class="line">        cookie_path = self._config.cookie_path</span><br><span class="line">        httponly = self._config.httponly</span><br><span class="line">        self.session_id = web.cookies().get(cookie_name)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># protection against session_id tampering</span></span><br><span class="line">        <span class="keyword">if</span> self.session_id <span class="keyword">and</span> <span class="keyword">not</span> self._valid_session_id(self.session_id):</span><br><span class="line">            self.session_id = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">        self._check_expiry()</span><br><span class="line">        <span class="keyword">if</span> self.session_id:</span><br><span class="line">            d = self.store[self.session_id]</span><br><span class="line">            self.update(d)</span><br><span class="line">            self._validate_ip()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.session_id:</span><br><span class="line">            self.session_id = self._generate_session_id()</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self._initializer:</span><br><span class="line">                <span class="keyword">if</span> isinstance(self._initializer, dict):</span><br><span class="line">                    self.update(deepcopy(self._initializer))</span><br><span class="line">                <span class="keyword">elif</span> hasattr(self._initializer, <span class="string">'__call__'</span>):</span><br><span class="line">                    self._initializer()</span><br><span class="line"> </span><br><span class="line">        self.ip = web.ctx.ip</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_check_expiry</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># check for expiry</span></span><br><span class="line">        <span class="keyword">if</span> self.session_id <span class="keyword">and</span> self.session_id <span class="keyword">not</span> <span class="keyword">in</span> self.store:</span><br><span class="line">            <span class="keyword">if</span> self._config.ignore_expiry:</span><br><span class="line">                self.session_id = <span class="keyword">None</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> self.expired()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_validate_ip</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># check for change of IP</span></span><br><span class="line">        <span class="keyword">if</span> self.session_id <span class="keyword">and</span> self.get(<span class="string">'ip'</span>, <span class="keyword">None</span>) != web.ctx.ip:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> self._config.ignore_change_ip:</span><br><span class="line">               <span class="keyword">return</span> self.expired() </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_save</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.get(<span class="string">'_killed'</span>):</span><br><span class="line">            self._setcookie(self.session_id)</span><br><span class="line">            self.store[self.session_id] = dict(self._data)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self._setcookie(self.session_id, expires=<span class="number">-1</span>)</span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_setcookie</span><span class="params">(self, session_id, expires=<span class="string">''</span>, **kw)</span>:</span></span><br><span class="line">        cookie_name = self._config.cookie_name</span><br><span class="line">        cookie_domain = self._config.cookie_domain</span><br><span class="line">        cookie_path = self._config.cookie_path</span><br><span class="line">        httponly = self._config.httponly</span><br><span class="line">        secure = self._config.secure</span><br><span class="line">        web.setcookie(cookie_name, session_id, expires=expires, domain=cookie_domain, httponly=httponly, secure=secure, path=cookie_path)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_generate_session_id</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Generate a random id for session"""</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            rand = os.urandom(<span class="number">16</span>)</span><br><span class="line">            now = time.time()</span><br><span class="line">            secret_key = self._config.secret_key</span><br><span class="line">            session_id = sha1(<span class="string">"%s%s%s%s"</span> %(rand, now, utils.safestr(web.ctx.ip), secret_key))</span><br><span class="line">            session_id = session_id.hexdigest()</span><br><span class="line">            <span class="keyword">if</span> session_id <span class="keyword">not</span> <span class="keyword">in</span> self.store:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> session_id</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_valid_session_id</span><span class="params">(self, session_id)</span>:</span></span><br><span class="line">        rx = utils.re_compile(<span class="string">'^[0-9a-fA-F]+$'</span>)</span><br><span class="line">        <span class="keyword">return</span> rx.match(session_id)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_cleanup</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Cleanup the stored sessions"""</span></span><br><span class="line">        current_time = time.time()</span><br><span class="line">        timeout = self._config.timeout</span><br><span class="line">        <span class="keyword">if</span> current_time - self._last_cleanup_time &gt; timeout:</span><br><span class="line">            self.store.cleanup(timeout)</span><br><span class="line">            self._last_cleanup_time = current_time</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">expired</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Called when an expired session is atime"""</span></span><br><span class="line">        self._killed = <span class="keyword">True</span></span><br><span class="line">        self._save()</span><br><span class="line">        <span class="keyword">raise</span> SessionExpired(self._config.expired_message)</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kill</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Kill the session, make it no longer available"""</span></span><br><span class="line">        <span class="keyword">del</span> self.store[self.session_id]</span><br><span class="line">        self._killed = <span class="keyword">True</span></span><br></pre></td></tr></table></figure>
<p>在webpy的session中，存储方式包括两种DiskStore和DBStore，分别为硬盘存储和数据库存储。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DiskStore</span><span class="params">(Store)</span>:</span></span><br><span class="line">	<span class="string">"""</span></span><br><span class="line"><span class="string">	Store for saving a session on disk</span></span><br><span class="line"><span class="string">	"""</span></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DBStore</span><span class="params">(Store)</span>:</span></span><br><span class="line">	<span class="string">"""</span></span><br><span class="line"><span class="string">	Store for saving a session in database</span></span><br><span class="line"><span class="string">	Needs a table with following columns:</span></span><br><span class="line"><span class="string">		session_id CHAR(128) UNIQUE NOT NULL,</span></span><br><span class="line"><span class="string">		atime DATATIME NOT NULL DEFAULT current_timestamp,</span></span><br><span class="line"><span class="string">		data TEXT</span></span><br><span class="line"><span class="string">	"""</span></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">```　　</span><br><span class="line"></span><br><span class="line">而session的存储也可以看出来，把sessionid作为key来存储session信息</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_save</span><span class="params">(self)</span>:</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> self.get(<span class="string">'_killed'</span>):</span><br><span class="line">		self._set_cookie(self.session_id)</span><br><span class="line">		self.store[self.session_id] = dict(self._data)</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		self._setcookie(self.session_id, expires=<span class="number">-1</span>)</span><br></pre></td></tr></table></figure>
<p>　　</p>
<p>参考</p>
<p><a href="http://doc.outofmemory.cn/python/webpy-cookbook/" target="_blank" rel="external">http://doc.outofmemory.cn/python/webpy-cookbook/</a></p>
<p><a href="http://webpy.org/docs/0.3/tutorial" target="_blank" rel="external">http://webpy.org/docs/0.3/tutorial</a></p>
]]></content>
      
        <categories>
            
            <category> python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> framework </tag>
            
            <tag> python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[python 守护进程]]></title>
      <url>/2014/10/22/python-deamon/</url>
      <content type="html"><![CDATA[<p>python守护进程与linux c实现原理是一样的。<br><a id="more"></a></p>
<p>第一个fork是为了让shell返回，同时让你完成setsid（从你的控制终端移除，这样就不会意外地收到信号）。setsid使得这个进程成为“会话领导（session leader）”，即如果这个进程打开任何终端，该终端就会成为此进程的控制终端。我们不需要一个守护进程有任何控制终端，所以我们又fork一次。在第二次fork之后，此进程不再是一个“会话领导”，这样它就能打开任何文件（包括终端）且不会意外地再次获得一个控制终端</p>
<p>另外说明：<br>umask()函数为进程设置文件模式创建屏蔽字，并返回以前的值<br>在shell命令行输入：umask 就可知当前文件模式创建屏蔽字<br>常见的几种umask值是002，022和027，002阻止其他用户写你的文件，022阻止同组成员和其他用户写你的文件，027阻止同组成员写你的文件以及其他用户读写或执行你的文件<br>rwx-rwx-rwx  代表是777  所有的人都具有权限读写与执行</p>
<p>chmod()改变文件的权限位<br>int dup(int filedes) 返回新文件描述符一定是当前文件描述符中的最小数值<br>int dup2(int filedes, int filedes2);这两个函数返回的新文件描述符与参数filedes共享同一个文件表项。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*-coding:utf-8-*-</span></span><br><span class="line"><span class="keyword">import</span> sys, os</span><br><span class="line"></span><br><span class="line"><span class="string">'''将当前进程fork为一个守护进程</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    注意：如果你的守护进程是由inetd启动的，不要这样做！inetd完成了</span></span><br><span class="line"><span class="string">    所有需要做的事情，包括重定向标准文件描述符，需要做的事情只有</span></span><br><span class="line"><span class="string">    chdir() 和 umask()了</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">daemonize</span><span class="params">(stdin=<span class="string">'/dev/null'</span>,stdout= <span class="string">'/dev/null'</span>, stderr= <span class="string">'dev/null'</span>)</span>:</span></span><br><span class="line">    <span class="string">'''Fork当前进程为守护进程，重定向标准文件描述符</span></span><br><span class="line"><span class="string">        （默认情况下定向到/dev/null）</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="comment">#Perform first fork.</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        pid = os.fork()</span><br><span class="line">        <span class="keyword">if</span> pid &gt; <span class="number">0</span>:</span><br><span class="line">            sys.exit(<span class="number">0</span>)  <span class="comment">#first parent out</span></span><br><span class="line">    <span class="keyword">except</span> OSError, e:</span><br><span class="line">        sys.stderr.write(<span class="string">"fork #1 failed: (%d) %s\n"</span> %(e.errno, e.strerror))</span><br><span class="line">        sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#从母体环境脱离</span></span><br><span class="line">    os.chdir(<span class="string">"/"</span>)</span><br><span class="line">    os.umask(<span class="number">0</span>)</span><br><span class="line">    os.setsid()</span><br><span class="line">    <span class="comment">#执行第二次fork</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        pid = os.fork()</span><br><span class="line">        <span class="keyword">if</span> pid &gt; <span class="number">0</span>:</span><br><span class="line">            sys.exit(<span class="number">0</span>) <span class="comment">#second parent out</span></span><br><span class="line">    <span class="keyword">except</span> OSError, e:</span><br><span class="line">        sys.stderr.write(<span class="string">"fork #2 failed: (%d) %s]n"</span> %(e.errno,e.strerror))</span><br><span class="line">        sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#进程已经是守护进程了，重定向标准文件描述符</span></span><br><span class="line">    <span class="keyword">for</span> f <span class="keyword">in</span> sys.stdout, sys.stderr: f.flush()</span><br><span class="line">    si = file(stdin, <span class="string">'r'</span>)</span><br><span class="line">    so = file(stdout,<span class="string">'a+'</span>)</span><br><span class="line">    se = file(stderr,<span class="string">'a+'</span>,<span class="number">0</span>)</span><br><span class="line">    os.dup2(si.fileno(), sys.stdin.fileno())</span><br><span class="line">    os.dup2(so.fileno(), sys.stdout.fileno())</span><br><span class="line">    os.dup2(se.fileno(), sys.stderr.fileno())</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_example_main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">'''示例函数：每秒打印一个数字和时间戳'''</span></span><br><span class="line">    <span class="keyword">import</span> time</span><br><span class="line">    sys.stdout.write(<span class="string">'Daemon started with pid %d\n'</span> % os.getpid())</span><br><span class="line">    sys.stdout.write(<span class="string">'Daemon stdout output\n'</span>)</span><br><span class="line">    sys.stderr.write(<span class="string">'Daemon stderr output\n'</span>)</span><br><span class="line"></span><br><span class="line">    c = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        sys.stdout.write(<span class="string">'%d: %s\n'</span> %(c, time.ctime()))</span><br><span class="line">        sys.stdout.flush()</span><br><span class="line">        c = c+<span class="number">1</span></span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    daemonize()</span><br><span class="line">    _example_main()</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[哈希算法（二）一致性哈希]]></title>
      <url>/2014/09/17/hash-consistent/</url>
      <content type="html"><![CDATA[<p>一致性哈希算法在1997年由麻省理工学院提出的一种分布式哈希（DHT）实现算法，设计目标是为了解决因特网中的热点(Hot spot)问题，经常用于分布式、负载均衡等。<br><a id="more"></a></p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>一致哈希是一种特殊的哈希算法。在使用一致哈希算法后，哈希表中平均只需要对 个关键字重新映射，其中 是关键字的数量，是映射节点数量。</p>
<p>然而在传统的哈希表中，添加或删除一个映射节点的几乎需要对所有关键字进行重新映射。</p>
<p>原来的映射大概是这样的，如下图，</p>
<p><img src="/images/hash-consistent-1.png" alt="图片1"></p>
<p>没当加入或删除一个新的节点可能都会造成每个节点的映射发生变化，如果黄色的节点代表服务器，那么每一次更新服务器的数量都会造成每个服务器上蓝色的映射节点都会发生变化，当集群数量庞大时每次增删节点所需要的修改操作就会过于庞大。</p>
<p>而在一致性哈希中映射是这样的，如下图，一般一致性hash取值范围为-2^32~2^32，分布在一个圆上</p>
<p><img src="/images/hash-consistent-2.gif" alt="图片2"></p>
<p>下面画的比较丑，就凑合看吧~~</p>
<p>其中，黄色节点作为映射节点（实节点），蓝色节点为需要映射到映射节点的key节点，<br>首先，看左边的图，把8个蓝色的key通过hash取值散列在一个范围为0~2^32的圆上<br>其次，选择三个黄色节点作为映射节点，按照圆的顺时针方向，把蓝色节点与黄色节点建立映射关系<br>最后，由于1节点负载为4，最大，那么我们为了降低1节点的负载情况，增加黄色的映射节点4，依然按照顺时针的方向修改原映射，那么只需要改变蓝色的节点7、8以及黄色节点1</p>
<p><img src="/images/hash-consistent-3.png" alt="图片3"></p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>　　一般为了方便起见，我们把黄色的映射节点称为实节点，也就是固定不变的，而蓝色的节点称为虚节点，虚节点需要映射到实节点，每次实节点的增删只会影响距离它最近的节点。</p>
<p>在这里使用C++实现了ConsistentHash算法</p>
<p><img src="/images/hash-consistent-4.png" alt="图片4"></p>
<p>在存储节点方面，本程序只是简单的使用链表，最好的方式当然是红黑树了，当然为了简单起见，就用了链表，主要是理解一致性hash的原理~~</p>
<p><a href="https://github.com/yxd123/algorithm-notes/tree/master/ConsistentHash" target="_blank" rel="external">源码下载</a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://blog.csdn.net/cywosp/article/details/23397179" target="_blank" rel="external">http://blog.csdn.net/cywosp/article/details/23397179</a><br><a href="http://zh.wikipedia.org/wiki/一致哈希" target="_blank" rel="external">http://zh.wikipedia.org/wiki/一致哈希</a><br><a href="http://baike.baidu.com/view/1588037.htm?fr=aladdin" target="_blank" rel="external">http://baike.baidu.com/view/1588037.htm?fr=aladdin</a></p>
]]></content>
      
        <categories>
            
            <category> algorithm </category>
            
        </categories>
        
        
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[哈希算法（一）]]></title>
      <url>/2014/09/04/hash-basic/</url>
      <content type="html"><![CDATA[<p>本文介绍基本的哈希算法。<br><a id="more"></a><br>哈希是大家比较常见一个词语，在编程中也经常用到，但是大多数人都是知其然而不知其所以然，再加上这几天想写一个一致性哈希算法，突然想想对哈希也不是很清楚，所以，抽点时间总结下Hash知识。本文参考了很多博文，感谢大家的无私分享。</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><code>Hash</code>，一般翻译做“散列”，也有直接音译为“哈希”的。那么哈希函数的是什么样的？大概就是 <code>value = hash(key)</code>，我们希望key和value之间是唯一的映射关系。</p>
<p>大家使用的最多的就是哈希表（Hash table，也叫散列表），是根据关键码值(Key value)而直接进行访问的数据结构，通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度，这个映射函数叫做哈希函数或散列函数。</p>
<p>实际中的Hash主要有两种应用：加密和压缩。</p>
<p>在加密方面，Hash哈希是把一些不同长度的信息转化成杂乱的128位的编码,这些编码值叫做HASH值，最广泛应用的Hash算法有MD4、MD5、SHA1。</p>
<p>在压缩方面，Hash哈希是指把一个大范围映射到一个小范围，往往是为了节省空间，使得数据容易保存。</p>
<h2 id="Hash的特点"><a href="#Hash的特点" class="headerlink" title="Hash的特点"></a>Hash的特点</h2><p>主要原理就是把大范围映射到小范围，因此输入范围必须和小范围相当或者比它更小，否则增加冲突。</p>
<p>Hash函数逼近单向函数，所以可以用来对数据进行加密。</p>
<p>单项函数：如果某个函数在给定输入的时候，很容易计算出其结果来；而当给定结果的时候，很难计算出输入来。</p>
<p>不同的应用对Hash函数有着不同的要求：用于加密的Hash函数主要考虑它和单项函数的差距，而用于查找的Hash函数主要考虑它映射到小范围的冲突率。</p>
<h2 id="Hash算法"><a href="#Hash算法" class="headerlink" title="Hash算法"></a>Hash算法</h2><p><code>Hash</code>的产生方式大体可以分为三种基本方法：<code>加法、乘法和移位</code>。</p>
<p>加法哈希是通过遍历数据中的元素然后每次对某个初始值进行加操作，其中加的值和这个数据的一个元素相关。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/********************************</span><br><span class="line"> *加法哈希</span><br><span class="line"> *@key   输入字符串</span><br><span class="line"> *@prime 素数</span><br><span class="line"> ********************************/</span><br><span class="line">int additiveHash(string key, int prime)</span><br><span class="line">&#123;</span><br><span class="line">    int hash, i;</span><br><span class="line">    for(hash = key.length(), i = 0; i &lt; key.length(); ++i)</span><br><span class="line">    &#123; </span><br><span class="line">        hash += int(key.at(i));</span><br><span class="line">    &#125;</span><br><span class="line">    return (hash%prime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>乘法哈希是通过遍历数据中的元素然后每次对初始值进行乘法操作，其中乘的值无需和数据有关系。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/********************************</span><br><span class="line"> *乘法哈希</span><br><span class="line"> *@key   输入字符串</span><br><span class="line"> *@prime 素数</span><br><span class="line"> ********************************/</span><br><span class="line">int bernstein(string key)</span><br><span class="line">&#123;</span><br><span class="line">    int hash, i;</span><br><span class="line">    for(hash = 0, i = 0; i &lt; key.length(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        hash = 33*hash + int(key.at(i));</span><br><span class="line">    &#125;</span><br><span class="line">    return hash;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/********************************</span><br><span class="line"> *32位FNV算法(乘法)</span><br><span class="line"> *@key   输入字符串</span><br><span class="line"> *@prime 素数</span><br><span class="line"> ********************************/</span><br><span class="line">int M_SHIFT = 0;</span><br><span class="line">int M_MASK = 0x8765fed1;</span><br><span class="line">int FNVHash(string key)</span><br><span class="line">&#123;</span><br><span class="line">    int hash = (int)2166136261L;</span><br><span class="line">    for(int i = 0; i &lt; key.length(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        hash = (hash * 16777619)^int(key.at(i));</span><br><span class="line">    &#125;</span><br><span class="line">    if(M_SHIFT == 0)</span><br><span class="line">        return hash;</span><br><span class="line">    return (hash ^ (hash &gt;&gt; M_SHIFT)) &amp; M_MASK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在JAVA中，哈希函数使用的就是乘法哈希：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * JAVA自己带的算法</span><br><span class="line"> */</span><br><span class="line">public static int java(String str) &#123;</span><br><span class="line">    int h = 0;</span><br><span class="line">    int off = 0;</span><br><span class="line">    int len = str.length();</span><br><span class="line">    for (int i = 0; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        h = 31 * h + str.charAt(off++);</span><br><span class="line">    &#125;</span><br><span class="line">    return h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>移位哈希是通过遍历数据中的元素然后每次对初始值进行移位操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/********************************</span><br><span class="line"> *旋转哈希（移位）</span><br><span class="line"> *@key   输入字符串</span><br><span class="line"> *@prime 素数</span><br><span class="line"> ********************************/</span><br><span class="line">int rotatingHash(string key, int prime)</span><br><span class="line">&#123;</span><br><span class="line">    int hash, i;</span><br><span class="line">    for(hash = key.length(), i = 0; i &lt; key.length(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        hash = (hash &lt;&lt; 4)^(hash &gt;&gt; 28)^int(key.at(i));</span><br><span class="line">    &#125;</span><br><span class="line">    return (hash%prime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>实际情况下，很多哈希函数都是包含加法、乘法和移位操作来实现的，例如MD5。</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>为什么prime的取值是素数？ 有科学依据么？ 有待验证</p>
<p>有人是这样说的取素数，可以降低碰撞的概率。但是并没有很好的说明原因，如果哪位有想法希望能留下您的想法，分享给大家。</p>
]]></content>
      
        <categories>
            
            <category> algorithm </category>
            
        </categories>
        
        
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C语言中的内存分配与释放]]></title>
      <url>/2013/06/23/malloc-and-free-in-c/</url>
      <content type="html"><![CDATA[<p>对C语言一直都是抱着学习的态度，很多都不懂，今天突然被问道C语言的内存分配问题，说了一些自己知道的，但感觉回答的并不完善，所以才有这篇笔记，总结一下C语言中内存分配的主要内容。<br><a id="more"></a></p>
<h2 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题　"></a>相关问题　</h2><p>刚刚在一篇博文看到一个简单的问题：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//code1</span></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">toStr</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *s = <span class="string">"abcdefghijkl"</span>;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; toStr() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//code2</span></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">toStr</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> s[] = <span class="string">"abcdefghijkl"</span>;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; toStr() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两段代码都很简单，输出一段字符，类型不同，一个是char*字符串，一个是char[]数据。</p>
<p>结果你知道吗? 这个我确实知道，相信大部分人也都回知道，必然有一个不好使，或者两个都不好使！！！都对就没意思了~</p>
<p>结果：第一个正确输出，第二个输出乱码。</p>
<p>原因在于局部变量的作用域和内存分配的问题，第一char*是指向一个常量，作用域为函数内部，被分配在程序的常量区，直到整个程序结束才被销毁，所以在程序结束前常量还是存在的。而第二个是数组存放的，作用域为函数内部，被分配在栈中，就会在函数调用结束后被释放掉，这时你再调用，肯定就错误了。</p>
<h2 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h2><pre><code>什么是局部变量、全局变量和静态变量？
</code></pre><p>顾名思义，局部变量就是在一个有限的范围内的变量，作用域是有限的，对于程序来说，在一个函数体内部声明的普通变量都是局部变量，局部变量会在栈上申请空间，函数结束后，申请的空间会自动释放。而全局变量是在函数体外申请的，会被存放在全局（静态区）上，知道程序结束后才会被结束，这样它的作用域就是整个程序。静态变量和全局变量的存储方式相同，在函数体内声明为static就可以使此变量像全局变量一样使用，不用担心函数结束而被释放。</p>
<p>相关函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(<span class="keyword">void</span> *p)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*一般这样用</span></span><br><span class="line"><span class="comment">Struct elem *p;</span></span><br><span class="line"><span class="comment">p = (struct elem*)malloc(sizeof(struct elem))</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">void free(p)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="malloc原理"><a href="#malloc原理" class="headerlink" title="malloc原理"></a>malloc原理</h3><p>malloc函数的实质体现在，它有一个将可用的内存块连接为一个长长的列表的所谓空闲链表。调用malloc函数时，它沿连接表寻找一个大到足以满足用户请求所需要的内存块。然后，将该内存块一分为二（一块的大小与用户请求的大小相等，另一块的大小就是剩下的字节）。接下来，将分配给用户的那块内存传给用户，并将剩下的那块（如果有的话）返回到连接表上。调用free函数时，它将用户释放的内存块连接到空闲链上。到最后，空闲链会被切成很多的小内存片段，如果这时用户申请一个大的内存片段，那么空闲链上可能没有可以满足用户要求的片段了。于是，malloc函数请求延时，并开始在空闲链上翻箱倒柜地检查各内存片段，对它们进行整理，将相邻的小空闲块合并成较大的内存块。如果无法获得符合要求的内存块，malloc函数会返回NULL指针，因此在调用malloc动态申请内存块时，一定要进行返回值的判断。</p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul>
<li>栈区（stack）—由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。</li>
<li>堆区（heap）—一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表</li>
<li>全局区（静态区）（static）—全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。  程序结束后由系统释放。</li>
<li>常量区—常量字符串就是放在这里的，直到程序结束后由系统释放。上面的问题就在这里！！！<br>代码区—存放函数体的二进制代码。</li>
</ul>
<p>直接搬运的代码，确实很好！！容易理解</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.cpp    </span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>; <span class="comment">//全局初始化区</span></span><br><span class="line"><span class="keyword">char</span> *p1; <span class="comment">//全局未初始化区</span></span><br><span class="line">    </span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> b; <span class="comment">//栈</span></span><br><span class="line">    <span class="keyword">char</span> s[] = <span class="string">"abc"</span>; <span class="comment">//栈</span></span><br><span class="line">    <span class="keyword">char</span> *p2; <span class="comment">//栈</span></span><br><span class="line">    <span class="keyword">char</span> *p3 = <span class="string">"123456"</span>; <span class="comment">//123456\\0在常量区，p3在栈上。</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> c =<span class="number">0</span>;<span class="comment">//全局（静态）初始化区</span></span><br><span class="line">    p1 = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">10</span>);    </span><br><span class="line">    p2 = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">20</span>);<span class="comment">//分配得来得10和20字节的区域就在堆区。</span></span><br><span class="line">    <span class="built_in">strcpy</span>(p1, <span class="string">"123456"</span>); <span class="comment">//123456\\0放在常量区，编译器可能会将它与p3所指向的"123456"优化成一个地方。        </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此外，还有realloc(重新分配内存)、calloc（初始化为0）、alloca（在栈上申请内存，自动释放）等。</p>
]]></content>
      
        <categories>
            
            <category> c </category>
            
        </categories>
        
        
        <tags>
            
            <tag> c </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux内核设计与实现笔记（二） 内存管理、进程地址空间]]></title>
      <url>/2013/06/01/linux-memory/</url>
      <content type="html"><![CDATA[<p>linux内存管理。<br><a id="more"></a></p>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="页"><a href="#页" class="headerlink" title="页"></a>页</h3><p>物理页作为内存管理的基本单位。<br>内存管理单元通常以页<code>page</code>为单位进行处理。</p>
<h3 id="区"><a href="#区" class="headerlink" title="区"></a>区</h3><p>由于页位于内存中特定的物理地址上，所以不能将其用于一些特定的任务，故内核把页划分为不同的区。</p>
<blockquote>
<p>硬件在内存寻址方面的问题</p>
</blockquote>
<p>一些硬件只能通过内存地址来执行直接内存访问（DMA - Direct Memory Access）;<br>一些体系结构其内存的物理寻址范围大于虚拟寻址范围，故，内存不能永久地映射到内核空间。</p>
<p>解决方法，通过创建三种不同的分区：</p>
<ul>
<li>ZONE_DMA–专门执行DMA</li>
<li>ZONE_NORMAL–正常映射的页</li>
<li>ZONE_HIGHMEM–高端内存，不能永久映射到内核空间</li>
</ul>
<h3 id="获得页"><a href="#获得页" class="headerlink" title="获得页"></a>获得页</h3><p>内核提供了一种请求内存的底层机制，并提供了对它进行访问的几个接口，以页为单位分配内存,<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct page* <span class="title">alloc_pages</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> gfp_mask, <span class="keyword">unsigned</span> <span class="keyword">int</span> order)</span></span></span><br><span class="line"><span class="function"><span class="comment">//该函数分配2^order个连续的物理页，并返回第一个页的page结构体</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">struct page* <span class="title">alloc_page</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> gfp_mask)</span></span></span><br><span class="line"><span class="function"><span class="comment">//order=0</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">page_address</span><span class="params">(struct page* page)</span></span></span><br><span class="line"><span class="function"><span class="comment">//该函数返回page物理页当前的逻辑地址</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> _<span class="title">get_free_pages</span><span class="params">(<span class="keyword">unsigned</span> it gfp_mask, <span class="keyword">unsigned</span> <span class="keyword">int</span> order)</span></span></span><br><span class="line"><span class="function"><span class="comment">//该函数分配2^order个连续的物理页，但返回第一个页的逻辑地址</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> _<span class="title">get_free_page</span><span class="params">(<span class="keyword">unsigned</span> it gfp_mask）</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment">//order=0</span></span></span></span><br></pre></td></tr></table></figure></p>
<h3 id="释放页"><a href="#释放页" class="headerlink" title="释放页"></a>释放页</h3><p>申请空间了，自然总要释放掉,<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _free_pages(struct page *page, <span class="keyword">unsigned</span> <span class="keyword">int</span> order)</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free_pages</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> addr, <span class="keyword">unsigned</span> <span class="keyword">int</span> order)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free_page</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> addr)</span></span></span><br><span class="line"><span class="function"><span class="comment">//释放页时，要谨慎，如果释放错误的页，可能会导致系统崩溃</span></span></span><br></pre></td></tr></table></figure></p>
<h3 id="kmalloc与vmalloc"><a href="#kmalloc与vmalloc" class="headerlink" title="kmalloc与vmalloc"></a>kmalloc与vmalloc</h3><p>kmalloc与malloc类似，可以获得以字节为单位的一块内核内存，并且内存区在物理上是连续的。<br><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">kmalloc</span><span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"><span class="comment">//flags是分类器标志</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kfree</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* ptr)</span></span></span><br><span class="line"><span class="function"><span class="comment">//这个要对应使用，谨慎vmalloc的不同之处在于，分配的内存虚拟地址是连续的，而物理地址则是无需连续的。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">vmalloc</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> size)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vfree</span><span class="params">(<span class="keyword">void</span>* addr)</span></span></span><br></pre></td></tr></table></figure></p>
<p>大多数情况下，只有硬件设备需要得到物理地址连续的内存。vmalloc仅在为了获得大块内存时才使用。</p>
<h3 id="Slab层"><a href="#Slab层" class="headerlink" title="Slab层"></a>Slab层</h3><p>slab分配器扮演了通用数据结构缓存层的角色，<br>通过slab层可以缓存频繁分配和释放的数据结构，避免内存碎片，提高性能。</p>
<p>slab层把不同的对象划分为高速缓存组，每个高速缓存都存放不同类型的对象。然后高速缓存又被划分为不同的slab。slab由一个或多个物理上连续的页组成。每个slab有三种状态：满、部分满或空。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">page + page + ... + page = a slab</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建高速缓存</span></span><br><span class="line"><span class="keyword">kmem_cache_t</span>* kem_cache_create(<span class="keyword">const</span> <span class="keyword">char</span>* name...)</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁高速缓存</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kmem_cache_destroy</span><span class="params">(<span class="keyword">kmem_cache_t</span> *cachep)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//获取对象</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">kmem_cache_alloc</span><span class="params">(<span class="keyword">kmem_cache_t</span> *cachep, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"><span class="comment">//该函数从给定的高速缓存中返回一个指向对象的指针。如果告诉缓存的所有slab中都没有空闲对象，那么slab层必须通过kmem_getpages获取新的页</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//释放对象</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kmem_cache_free</span><span class="params">(...)</span></span></span><br></pre></td></tr></table></figure>
<h2 id="CPU的分配"><a href="#CPU的分配" class="headerlink" title="CPU的分配"></a>CPU的分配</h2><p>一般来说，每个CPU的数据存放在一个数组中。数组中的每一项对应着系统上存在的一个处理器。由于这个数据对于当前处理器是唯一的，其他处理器不能访问它，故不需要加锁进行操作。</p>
<p>使用每个CPU数据可以减少数据锁定（省去数据上锁），大大减少缓存失效（避免同步，不断刷新缓存）。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个类型为type，名字为name的实例</span></span><br><span class="line">DECLARE_PER_CPUT(type, name);</span><br><span class="line">DEFINE_PER_CPU(type, name);</span><br><span class="line"></span><br><span class="line"><span class="comment">//增加处理器上的name值</span></span><br><span class="line">get_cput_var(name)++;</span><br><span class="line"></span><br><span class="line"><span class="comment">//激活内核抢占</span></span><br><span class="line">put_cput_var(name);</span><br><span class="line"></span><br><span class="line"><span class="comment">//增加指定处理器CPU上的name值</span></span><br><span class="line">per_cpu(name, cpu)++;</span><br><span class="line">运行时的每个CPU数据</span><br><span class="line"></span><br><span class="line"><span class="comment">//分配对象</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">alloc_percpu</span><span class="params">(type)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* _<span class="title">alloc_percpu</span><span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">size_t</span> align)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//释放对象</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free_percpu</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>*)</span></span></span><br></pre></td></tr></table></figure></p>
<h2 id="进程地址空间"><a href="#进程地址空间" class="headerlink" title="进程地址空间"></a>进程地址空间</h2><p>Linux操作系统采用虚拟内存技术，因此，系统中的所有进程之间以虚拟方式共享内存。</p>
<p>现代采用虚拟内存的操作系统通常都使用独立连续的地址空间，而不是分段的。因此，进程地址空间之间彼此互不相干，两个不同的进程可以在它们各自的地址空间的相同地址内存放不同的数据。但是，进程之间也可以选择共享地址空间，这样的进程就是所谓的线程。</p>
<p>进程只能访问有效范围内的内存地址。每个内存区域也具有相应进程必须遵循的特定访问属性，如只读、只写等属性。如果一个进程访问了不在有效范围中的地址，或以不正确的方式访问有效地址，那么内核就会种植该进程，并返回“段错误”信息。</p>
<h3 id="内存描述符"><a href="#内存描述符" class="headerlink" title="内存描述符"></a>内存描述符</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//内存描述符结构体 linx/sched.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">mmap</span>;</span></span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>fork</code>函数通过利用<code>copy_mm</code>函数复制父进程的内存描述符，而子进程中的<code>mm_struct</code>是通过<code>allocate_mm</code>宏从<code>mm_cachep slab</code>缓存中得到的。</p>
<p>如果父进程希望和其子进程共享地址空间，那么在调用clone时，设置<code>CLONE_VM</code>标志，内核就不需要调用<code>alloc_mm</code>函数了，而仅仅需要用<code>copy_mm</code>函数将内存域指向进程的内存描述符。调用<code>exit_mm</code>函数，销毁内存描述符。</p>
<blockquote>
<p>注意：内核线程没有进程地址空间，也没有相关的内存描述符。所以内核线程对应的进程描述符中mm域为NULL，这也正式内核线程的真实含义–没有用户上下文。</p>
</blockquote>
<h3 id="内存区域"><a href="#内存区域" class="headerlink" title="内存区域"></a>内存区域</h3><p>内存区域在内核中经常被称为虚拟内存区域或VMA。<br>内核将每个内存区域作为一个单独的内存管理对象，每个内存区域都有一直的属性。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//内存区域结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">vm_mm</span>;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="操作内存区域"><a href="#操作内存区域" class="headerlink" title="操作内存区域"></a>操作内存区域</h3><p>为了方便执行对内存区域的操作，内核定义了许多的辅助函数。linux/mm.h<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//搜索内存区域--通过红黑树 mm/mmap.c</span></span><br><span class="line"><span class="function">struct vm_area_struct *<span class="title">find_vma</span><span class="params">(struct mm_struct* mm, <span class="keyword">unsigned</span> <span class="keyword">long</span> addr)</span></span></span><br><span class="line"><span class="function"><span class="comment">//该函数在指定的地址空间中搜索第一个vm_end大于addr的内存区域</span></span></span><br><span class="line"><span class="function">struct vm_area_struct* <span class="title">find_vma_prev</span><span class="params">(struct mm_struct *mm, <span class="keyword">unsigned</span> <span class="keyword">long</span> addr, struct vm_area_struct **pprev)</span></span></span><br><span class="line"><span class="function"><span class="comment">//它返回第一个小于addr的VMA</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> struct vm_area_struct* <span class="title">find_vma_intersection</span><span class="params">(struct mm_struct *mm, <span class="keyword">unsigned</span> <span class="keyword">long</span> start_addr, <span class="keyword">unsigned</span> <span class="keyword">long</span> end_addr)</span></span></span><br><span class="line"><span class="function"><span class="comment">//返回第一个和指定地址区间相交的VMA</span></span></span><br></pre></td></tr></table></figure></p>
<h3 id="创建删除地址空间"><a href="#创建删除地址空间" class="headerlink" title="创建删除地址空间"></a>创建删除地址空间</h3><p>内核使用do_mmap()函数创建一个新的线性地址空间。这可能会导致扩展已存在的内存区域（和一个已经存在的相邻地址空间的访问权限相同）或创建一个新的区域。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建地址区间</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">do_mmap</span><span class="params">(....)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">mmap</span><span class="params">(..)</span></span></span><br><span class="line"><span class="function"><span class="comment">//删除地址空间</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_munmap</span><span class="params">(...)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">munmap</span><span class="params">(...)</span></span></span><br></pre></td></tr></table></figure></p>
<h3 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h3><p>虽然应用程序操作的对象是映射到物理内存上的虚拟内存，但是处理器直接操作的确实物理内存。所以每当一个程序访问一个虚拟地址时，首先必须将虚拟地址转化为物理地址，然后处理器才能解析地址访问请求。地址的转换工作需要通过查询页表才能完成。也就是说，地址转换需要虚拟地址分段，每段虚拟地址都是一个索引指向页表，而页表项指向下一级别的页表或最终物理页面。</p>
<p>Linux使用三级页表完成地址转换，利用多级页表能够节约地址转换占用的存放空间。</p>
<ul>
<li>顶级页–页全局目录(PGD)，指向PMD</li>
<li>二级页–中间页目录(PMD)，指向页表</li>
<li>最低级页–页表，指向物理页</li>
</ul>
<p>搜索页表的工作是硬件完成的。</p>
<p>由于几乎每次对虚拟内存的访问都需解析它，才可以得到物理内存中的对应地址，所以也表操作的性能非常关键。为了加快搜索速度，多数体系结构都实现了一个翻译后缓冲器（translation lookaside buffer,TLB）。</p>
]]></content>
      
        <categories>
            
            <category> cs </category>
            
        </categories>
        
        
        <tags>
            
            <tag> linux </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
