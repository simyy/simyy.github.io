<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>simyy</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://simyy.cn/"/>
  <updated>2018-04-19T00:36:49.000Z</updated>
  <id>http://simyy.cn/</id>
  
  <author>
    <name>simyy</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>git</title>
    <link href="http://simyy.cn/2018/04/12/git/"/>
    <id>http://simyy.cn/2018/04/12/git/</id>
    <published>2018-04-12T00:30:42.000Z</published>
    <updated>2018-04-19T00:36:49.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/15240979783937.jpg" alt=""></p><p>Git是一个开源的分布式版本控制系统。</p><a id="more"></a><h2 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h2><p>Git的作者是大名鼎鼎的<code>Linus（Linux的创始人</code>）。</p><blockquote><p><a href="http://geek.csdn.net/news/detail/30067" target="_blank" rel="noopener"><code>Linux创始人Linus Torvalds访谈，Git的十年之旅</code></a> <a href="https://www.linuxfoundation.org/blog/10-years-of-git-an-interview-with-git-creator-linus-torvalds/" target="_blank" rel="noopener">英文</a></p></blockquote><h3 id="为什么要创建Git？"><a href="#为什么要创建Git？" class="headerlink" title="为什么要创建Git？"></a>为什么要创建Git？</h3><p><strong>阶段一</strong>：起初参与Linux开源项目的代码是由Linus本人通过<code>diff和patch</code>命令来<code>手动</code>为别人整合代码的，但是代码库之大<code>很难</code>继续通过<code>手工方式管理</code>了。</p><p><strong>阶段二</strong>：为了解决上一个问题，开始使用版本控制工具<code>BitKeeper</code>，但注意它<code>并非开源的</code>。</p><p><strong>阶段三</strong>：开发Samba的Andrew试图破解BitKeeper的协议，被BitMover公司发现并收回Linux社区的免费使用权。</p><p><strong>阶段四</strong>：工具没了，咋整？Linus花了两周时间自己用C写了一个<code>分布式版本控制系统</code>，这就是<code>Git</code>！一个月之内，Linux系统的源码已经由Git管理了！</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><img src="/images/15240979976862.jpg" alt=""></p><h3 id="工作区-amp-版本库"><a href="#工作区-amp-版本库" class="headerlink" title="工作区&amp;版本库"></a>工作区&amp;版本库</h3><p>在初始化git版本库之后会生成一个隐藏的文件<code>.git</code> ，可以将该文件理解为git的<code>版本库</code>。</p><p>项目文件夹属于<code>工作区</code>，在<code>.git</code> 文件夹里面还有很多文件，其中有一个<code>index 文件</code>就是<code>暂存区（也可以叫做 stage）</code> 。</p><blockquote><p>每当编辑好一个或几个文件后，通过add操作把它加入到暂存区，然后接着修改其他文件，改好后放入暂存区，循环反复直到修改完毕，最后使用 commit 命令，将暂存区的内容永久保存到本地仓库。这个过程其实就是构建项目快照的过程，当我们提交时，git 会使用暂存区的这些信息生成tree对象，也就是项目快照，永久保存到数据库中，因此也可以说暂存区是用来构建项目快照的区域。</p></blockquote><p><img src="/images/15240980359546.jpg" alt=""></p><p>git还为我们自动生成了一个分支<code>master（默认分支）</code>以及指向该分支的<code>指针head</code>·。</p><h3 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h3><p><code>objects</code>是用来存储git数据，具体可以分为<code>blob</code>、<code>tree</code>和<code>commit</code>。</p><hr><p><code>blob</code>用来存放项目文件的内容，但是不包括文件的路径、名字、格式等其它描述信息。项目的任意文件的任意版本都是以blob的形式存放的。</p><p><code>tree</code>用来表示目录。项目就是一个目录，其中包括文件、子目录，因此 tree 中有 blob、子tree。</p><blockquote><p><code>blob</code>和<code>tree</code>是使用 sha-1值引用的（将文件中的内容通过通过计算生成一个 40 位长度的hash值，其特点：由文件内容计算出的hash值hash值相同，文件内容相同）。</p></blockquote><p><code>commit</code>表示一次提交，有parent字段，用来引用父提交。指向了一个顶层 tree，表示了项目的快照，还有一些其它的信息，比如上一个提交，committer、author、message 等信息。</p><hr><p><img src="/images/15240980465160.jpg" alt=""></p><blockquote><p>从顶层的 tree 纵览整个树状的结构，叶子结点就是blob，表示文件的内容，非叶子结点表示项目的目录，而<code>顶层的 tree 对象就代表了当前项目的快照</code>。</p></blockquote><h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><p><img src="/images/15240980763614.jpg" alt=""></p><p><code>分支的目的</code>是让我们可以并行的进行开发。</p><p>比如我们当前正在开发功能，但是需要修复一个紧急bug，我们不可能在这个项目正在修改的状态下修复 bug，因为这样会引入更多的bug。</p><p>分支的实现其实很简单，我们可以先看一下 .git/HEAD 文件，它保存了当前的分支，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~/work/communitycenter   features/0412 ●✚  cat .git/HEAD</span><br><span class="line">ref: refs/heads/features/0412</span><br></pre></td></tr></table></figure><p><code>Git 的分支</code>本质上仅仅是指向提交<code>对象的可变指针</code>。 Git 的默认分支名字是<code>master</code>。 在多次提交操作之后，你其实已经有一个指向最后那个提交对象的 commit。 它会在每次的提交操作中自动向前移动。</p><blockquote><p>Git 的 “master” 分支并不是一个特殊分支。 它就跟其它分支完全没有区别。 之所以几乎每一个仓库都有 master 分支，是因为 git init 命令默认创建它，并且大多数人都懒得去改动它。</p></blockquote><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="Config"><a href="#Config" class="headerlink" title="Config"></a>Config</h3><p>修改分支之前应该需要修改好用户名和邮箱，这样才知道当前的修改属于谁。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config user.email xxxx 设置邮箱</span><br><span class="line">git config user.name yyyy 设置用户名</span><br></pre></td></tr></table></figure><h3 id="Merge-amp-Rebase"><a href="#Merge-amp-Rebase" class="headerlink" title="Merge &amp; Rebase"></a>Merge &amp; Rebase</h3><p>在 git 中合并分支有两种选择：<code>merge</code>和<code>rebase</code>，但是无论哪一种，都有可能产生冲突。</p><blockquote><p>冲突的产生：两个已经提交的分支的<code>相同文件相同位置的的不同操作进行了合并</code>。</p></blockquote><p><img src="/images/15240981123981.jpg" alt=""></p><p>由于并行开发，<code>master</code>分支和<code>feature</code>分支出现了并行情况，并且同时更改了相同文件的相同位置，造成了冲突。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;HEAD</span><br><span class="line">other code</span><br><span class="line"></span><br><span class="line">========</span><br><span class="line"></span><br><span class="line">your code</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;your branch name</span><br></pre></td></tr></table></figure><h3 id="Merge"><a href="#Merge" class="headerlink" title="Merge"></a>Merge</h3><p><code>Merge</code>会把不同分支的commit合并（<code>保留commit的时间线</code>）起来，通过新增一个新的commit来实现冲突的解决。</p><p>在没有冲突的情况下，<code>Merge</code>合并情况如下，其中<code>7</code>为合并的<code>commit</code>，</p><p><img src="/images/15240981214130.jpg" alt=""></p><blockquote><p>如果发生冲突的话，<code>Merge</code>命令会自动合并，否则需要人工解决这些冲突。</p></blockquote><p>如果提示<code>Automatic merge failed; fix conflicts and then commit the result.</code>，说明自动合并失败。</p><p>此时可以通过<code>git status</code>来查看冲突情况，一般会有这样的提示<code>both modified:   xxxxx</code>。</p><hr><p> <code>merge</code>是一种<code>不修改分支历史提交记录</code>的方式，这也是我们常用的方式。</p><hr><h3 id="Rebase"><a href="#Rebase" class="headerlink" title="Rebase"></a>Rebase</h3><p><code>Rebase</code>会把从<code>Merge Base</code>以来的所有提交以补丁的形式一个一个重新达到目标分支上。</p><p><img src="/images/15240981289836.jpg" alt=""></p><hr><p>与<code>Merge</code>不同，<code>Rebase</code>会重新修改基于远程分支的commit，使得目标分支合并该分支的时候会直接<code>Fast Forward</code>，即不会产生任何冲突，提交历史是一条线，这对强迫症患者可谓是一大福音。</p><p>由于一条线提交历史也可以保证分支功能在master分支上是<code>有序的</code>。</p><hr><p><code>Rebase</code>还可以用来修改历史commit，一般在写代码的时候经常会提交一些无效的commit，这些commit不利于代码review，从commit中不能获得此次的改动点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">commit af6922a5d3d31a4f3816a27a14476f62a533579e</span><br><span class="line">Author: xxxx</span><br><span class="line">Date:   Fri Mar 16 10:17:50 2018 +0800</span><br><span class="line">    fix bug</span><br><span class="line">...</span><br><span class="line">commit 71966c45a79dcf7ae13842feea61d61ba77fa120</span><br><span class="line">Author: xxxx</span><br><span class="line">Date:   Thu Mar 15 19:58:03 2018 +0800</span><br><span class="line">    fix bg</span><br></pre></td></tr></table></figure><p>可使用<code>Rebase</code>命令如下，其中xxx代表base为xxx的commit。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i &lt;comment-id&gt;</span><br></pre></td></tr></table></figure></p><p>执行结果如下，其中可以通过修改<code>pick</code>来实现修改commit操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pick e0f56d9 fix bug</span><br><span class="line">s f3s0281 fix bug</span><br><span class="line">s a310682 fix bug</span><br><span class="line">s 1902931 fix bug</span><br><span class="line"></span><br><span class="line"># Commands:</span><br><span class="line"># p, pick = use commit</span><br><span class="line"># r, reword = use commit, but edit the commit message</span><br><span class="line"># e, edit = use commit, but stop for amending</span><br><span class="line"># s, squash = use commit, but meld into previous commit</span><br><span class="line"># f, fixup = like &quot;squash&quot;, but discard this commit&apos;s log message</span><br><span class="line"># x, exec = run command (the rest of the line) using shell</span><br><span class="line"># d, drop = remove commit</span><br></pre></td></tr></table></figure></p><p><strong>一般使用的姿势如下：</strong></p><p>通过<code>edit</code>来修改目标commit的内容</p><p><img src="/images/15240981389227.jpg" alt=""></p><p>通过<code>squash</code>来合并多个commit的内容</p><p><img src="/images/15240981445332.jpg" alt=""></p><hr><h3 id="Branch、Checkout、Revert、Reset"><a href="#Branch、Checkout、Revert、Reset" class="headerlink" title="Branch、Checkout、Revert、Reset"></a>Branch、Checkout、Revert、Reset</h3><p>创建分支的两种方式：</p><p><code>git branch new_branch</code> =&gt; 创建新分支</p><p><code>git checkout -b new_branch</code> =&gt; 创建并切换到新分支</p><hr><p><code>Revert</code>一般被称为反向提交。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git revert &lt;comment-id&gt;</span><br></pre></td></tr></table></figure><blockquote><p>什么是反向提交呢，就是旧版本添加了的内容，要在新版本中删除，旧版本中删除了的内容，要在新版本中添加。这在分支已经推送到远程仓库的情境下非常有用。</p></blockquote><p><code>Revert也不会修改历史提交记录</code>，实际的操作相当于是检出目标提交的项目快照到工作区与暂存区，然后用一个新的提交完成版本的<code>回退</code>。</p><hr><p>与<code>Revert</code>很像，<code>Reset</code>用来在当前分支进行版本的“回退”，不同的是，<code>Reset 是会修改历史提交记录的</code>。</p><p><code>Reset</code>常用的选项有三个，分别是<code>soft</code>,  <code>mixed</code>, <code>hard</code>，他们的作用域依次增大。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --&lt;option&gt; &lt;comment-id&gt;</span><br></pre></td></tr></table></figure><p><code>soft</code>选项仅会修改分支指向，而不修改工作区与暂存区的内容，可以重新做一次提交，形成一个新的 commit，常用与撤销临时提交的场景。</p><blockquote><p><code>soft</code>可用于上面多个无效commit的合并（只使用于合并当前commit之前的连续commit）。</p></blockquote><p><code>mixed</code>比<code>soft</code>的作用域多了一个 暂存区，实际上<code>mixed 选项与 soft 只差了一个 add 操作</code>。</p><p><code>hard</code>选项会导致工作区内容“丢失”，因此在使用 <code>hard</code> 选项时，一定要确保知道自己在做什么，避免丢失分支内容。</p><blockquote><p>如果真的误用了<code>hard</code>，造成了数据丢失怎么办？<br>如果真的误操作了，也不要慌，因为只要 git 一般不会主动删除本地仓库中的内容，根据你丢失的情况，可以进行找回，解决方法有两种：<br>一、使用 <code>git reset --hard ORIG_HEAD</code>立即恢复<br>二、使用 <code>reflog</code>命令查看之前分支的引用</p></blockquote><h3 id="Stash"><a href="#Stash" class="headerlink" title="Stash"></a>Stash</h3><p><code>stash</code>将工作区与暂存区中的内容做一个提交并保存起来，然后使用<code>reset hard</code>选项恢复工作区与暂存区内容。我们可以随时使用 <code>stash apply</code> 将修改应用回来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git stash</span><br><span class="line">git stash apply</span><br></pre></td></tr></table></figure><blockquote><p>使用场景：有时，我们在一个分支上做了一些工作，修改了很多代码，而这时需要切换到另一个分支干点别的事。但又不想将只做了一半的工作提交。在曾经这样做过，将当前的修改做一次提交，message 填写 half of work，然后切换另一个分支去做工作，完成工作后，切换回来使用 <code>reset —soft</code>（重新提交commit）或者是 <code>commit amend</code>（修改commit）。</p></blockquote><h3 id="cherry-pick"><a href="#cherry-pick" class="headerlink" title="cherry-pick"></a>cherry-pick</h3><p><code>cherry-pick</code>用于把另一个本地分支的commit修改应用到当前分支。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git cherry-pick &lt;comment-id&gt;</span><br></pre></td></tr></table></figure><blockquote><p>如果在cherry-pick 的过程中出现了冲突？和rebase和merge一样，都需要手动解决冲突再提交。</p></blockquote><h3 id="set-upstream"><a href="#set-upstream" class="headerlink" title="set-upstream"></a>set-upstream</h3><p><code>set-upstream</code>用于设置分支跟踪关系。</p><p>一般本地新建一个分支再往远程仓库推送的时候，需要指定远程仓库的目标分支。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git push --set-upstream origin &lt;new_branch&gt;</span><br><span class="line">git branch --set-upstream-to=&lt;target branch&gt; &lt;new_branch&gt;</span><br></pre></td></tr></table></figure></p><h3 id="pull-amp-fetch"><a href="#pull-amp-fetch" class="headerlink" title="pull &amp; fetch"></a>pull &amp; fetch</h3><p><code>pull</code>=<code>fetch</code>+<code>merge</code>。</p><p><code>pull</code>是下拉远程分支并与本地分支合并。<code>fetch</code>只是下拉远程分支，并不会发生合并需要手动执行合并。</p><p>也可以采用<code>rebase</code>模式，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull --rebase</span><br></pre></td></tr></table></figure></p><p>该命令做了以下内容：<br>一、把你 commit 到本地仓库的内容，取出来放到暂存区(<code>stash</code>)（这时你的工作区是干净的）<br>二、然后从远端拉取代码到本地，由于工作区是干净的，所以不会有冲突<br>三、从暂存区把你之前提交的内容取出来，跟拉下来的代码合并</p><blockquote><p><code>rebase</code>在拉代码前要确保你本地工作区是干净的，如果你本地修改的内容没完全 commit 或者 stash，就会 rebase 失败。</p></blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.coding.net/blog/principle-of-Git" target="_blank" rel="noopener">https://blog.coding.net/blog/principle-of-Git</a><br><a href="http://www.bootcss.com/p/git-guide/" target="_blank" rel="noopener">http://www.bootcss.com/p/git-guide/</a><br><a href="https://www.cnblogs.com/dogdogwang/p/7072931.html" target="_blank" rel="noopener">https://www.cnblogs.com/dogdogwang/p/7072931.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/15240979783937.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;Git是一个开源的分布式版本控制系统。&lt;/p&gt;
    
    </summary>
    
      <category term="版本管理" scheme="http://simyy.cn/categories/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="git" scheme="http://simyy.cn/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>区块链</title>
    <link href="http://simyy.cn/2017/12/21/block-chain/"/>
    <id>http://simyy.cn/2017/12/21/block-chain/</id>
    <published>2017-12-21T12:53:55.000Z</published>
    <updated>2018-03-27T05:11:51.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/blockchain-1.jpg" alt="区块链"></p><p>简单介绍区块链技术。</p><a id="more"></a><h3 id="什么是区块链"><a href="#什么是区块链" class="headerlink" title="什么是区块链"></a>什么是区块链</h3><p>区块链实际是一种去中心化的分布式数据库（记账系统）。</p><p>区块链的主要特点：</p><ul><li>去中心化：无中心节点，系统内节点的权利和义务是均等的</li><li>集体维护：系统中数据块由整个系统中所有节点共同维护</li><li>高度透明：源代码开源，保证了记账和规则的公开透明</li><li>去信任：从技术上保证在没有第三方机构的情况交易的信任问题</li><li>匿名：由于信任问题不需要考虑，所以交易可以在匿名下进行</li></ul><h2 id="中心化"><a href="#中心化" class="headerlink" title="中心化"></a>中心化</h2><p>区块链本质上是一个去中心化的巨大账本数据库。作为比特币的底层技术，区块链是由一串使用密码学相关联所产生的数据块组成，每一个数据块中包含了多次比特币网络有效确认（一次有效交易检验被称为一次确认）的信息。</p><h2 id="集体维护"><a href="#集体维护" class="headerlink" title="集体维护"></a>集体维护</h2><p>随着交易不断产生，矿工需要不断创造新的区块来记录最新的交易，因此会导致这个帐本会一直增长延长。</p><p>每一个节点（每台连击到区块链网络上的电脑）都有一份完整的已有区块链备份记录，而且区块链上保留有所有关于每个节点的比特币交易信息，这些信息也被记录在完整的区块链上。</p><p>区块链帐本完全对外公开，这意味着区块链的区块生成和交易都可以自行查询。</p><p>新区块的生成将奖励给首次挖取次区块的矿工，这使得矿工有利可图，从而成为了矿工挖矿的主要动机。</p><blockquote><p>值得注意是：矿工挖矿会得到奖励，从而激励矿工不断挖矿，挖矿的过程中会记录交易信息从而不断重复这个过程。</p></blockquote><h2 id="去信任"><a href="#去信任" class="headerlink" title="去信任"></a>去信任</h2><p>首先，交易信息要写入到当前最先产生的区块中。</p><p>有了区块链之后，当一个用户想要进行历史交易的验证时，可以通过一系列基于密码学与数据结构学的运算追踪交易所属的区块，从而完成验证。</p><p>此外，对于随机数答案难度的调整可以控制新区块的生成速度；私钥的保密性可以保证和实现匿名交易；对于历史交易数据的剪枝可以实现硬盘空间的回收：经过中本聪的测算，经过完全剪枝的区块链数据一年只生成4.2MB的数据量。</p><p>区块链系统同任何一个数字系统一样，都离不开计算机硬件的支持。区块链集体记账的特点要求每个支持交易的节点都能够为系统提供计算能力，由此提出了一种鼓励节点竞相提供计算能力的机制<code>挖矿</code>。</p><p>每个节点接收到交易信息以后，生成新的区块并计算该区块的随机数答案，最快得到答案的节点将促成这笔交易的实现，完成交易的区块记录，并将该区块广播至所有节点。同时该节点将有可能获得一枚新的电子货币作为奖励。由于其过程很像矿工挖矿，因此节点提供算力的过程也叫作挖矿。通过挖矿，可以强制性保证块链中的数据按时间顺序存储，保持比特币网络的中立性，且允许比特币网络上不同的计算机对系统状态达成一致。</p><h2 id="区块链原理"><a href="#区块链原理" class="headerlink" title="区块链原理"></a>区块链原理</h2><p>区块链是由多个区块构成的一个链式结构。</p><h3 id="区块计算方式"><a href="#区块计算方式" class="headerlink" title="区块计算方式"></a>区块计算方式</h3><p>哈希值是固定长度的数值，用来标识唯一数据。</p><p>哈希通过将索引、前个哈希、时间戳、数据、随机数作为输入后计算得出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CryptoJS.SHA256(index + previousHash + timestamp + data + nonce)</span><br></pre></td></tr></table></figure><p>哈希值类似于：0000018035a828da0…</p><p>开头的四个 0 是有效哈希的基本要求，开头 0 的个数被称为难度值（difficulty），这就是众所周知的工作量证明系统（Proof-of-Work）。</p><h3 id="如何避免区块修改"><a href="#如何避免区块修改" class="headerlink" title="如何避免区块修改"></a>如何避免区块修改</h3><p>由于每一个块的哈希值都是根据前一个块来计算的，而且</p><p>如果我们有一个这样的区块链 A → B → C，有人想修改区块 A 上的数据。会发生下面情况：</p><p>修改区块 A 上的数据。<br>区块 A 的哈希变动，因为计算哈希所用的数据变化了。<br>区块 A 无效，因为它的哈希不是四个 0 开头。<br>区块 B 的哈希变动，因为计算区块 B 的哈希所用到的区块 A 的哈希值变化了。<br>区块 B 无效，因为它的哈希不是四个 0 开头。<br>区块 C 的哈希变动，因为计算区块 C 的哈希所用到的区块 B 的哈希值变化了。<br>区块 C 无效，因为它的哈希不是四个 0 开头。<br>修改一个区块的唯一方式就是重新开采这个区块以及它之后的所有区块。因为新的区块不断增加，基本不可能修改区块链。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><blockquote><p>比特币是有限的?</p></blockquote><p>由于比特币总值是有限的，所以不能允许无穷无尽的通过挖矿来新增比特币，所以协议设定的挖矿所得新币数目会逐渐减少，而且该设计也使得新币是按照约定速率而产生的。</p><p>那么问题来了，如果当所有块都被挖出后，比特币将无法进行交易，那剩下的比特币改怎样？</p><blockquote><p>怎么确保一份交易账单真实有效？</p></blockquote><p>如何在一个没有信任中心的系统中认证一个事情的真假？这里有个假定，就是好人比坏人多，即整个系统内百分之五十以上的人会严格遵守比特币协议的规则。比特币对交易是由矿工来确认的，也就是说我们认为好矿工比坏矿工多，对于错误的账单，好矿工都是会拒绝的。那么坏人就无法进行伪造、篡改。</p><p>比特币的交易认证包含两个事情：一是各路矿工对新区块数学难题的求解，一是全体同志对求解出答案的矿工的答案进行验证。</p><p>挖矿的难度设计出了一个基本固定的十分钟时间，当你提出一笔交易，接下来这十分钟时间内比特币系统对你的这笔交易申请进行验证，看看你是不是有这笔钱。矿工们会努力进行求解，第一个算得结果的人会把结果广播出去，让大家来评判对错，如果对的话，大家就会认可这笔交易。</p><p>账单的确认实际上是在试图向区块链添加新的区块，也就是要计算出新的区块。</p><blockquote><p>比特币的神秘发明人</p></blockquote><p>比特币的发明人一直是个迷。2009年一个网名叫中本聪的人在密码学邮件列表里发了一篇论文，讲述了这种不依赖于信任关系的金融交易系统，随后中本聪开发了第一款比特币系统。可是没人知道他的真实身份，他有意隐藏自己的一切身份信息。无数技术牛人试图通过各种方式寻找这个天才黑客数学家的线索，都没能如愿。</p><p>目前来讲，我们不知道他是一个人还是一个团队，不知道他所在的地区和时区，只知道他精通英语、数学、计算机。</p><blockquote><p>如何看点比特币的疯狂？</p></blockquote><p>荷兰郁金香也不过如此，都是人性的贪婪造成的现象。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://blog.jobbole.com/112551/" target="_blank" rel="noopener">http://blog.jobbole.com/112551/</a><br><a href="http://blog.jobbole.com/110860/" target="_blank" rel="noopener">http://blog.jobbole.com/110860/</a><br><a href="https://www.jianshu.com/p/214acff6c9bd" target="_blank" rel="noopener">https://www.jianshu.com/p/214acff6c9bd</a><br><a href="http://bitcoin-on-nodejs.ebookchain.org/1-%E4%BA%86%E8%A7%A3%E5%8A%A0%E5%AF%86%E8%B4%A7%E5%B8%81/5-%E5%8A%A0%E5%AF%86%E8%B4%A7%E5%B8%81%E5%B0%B1%E6%98%AF%E8%B4%A7%E5%B8%81.html" target="_blank" rel="noopener">http://bitcoin-on-nodejs.ebookchain.org/1-%E4%BA%86%E8%A7%A3%E5%8A%A0%E5%AF%86%E8%B4%A7%E5%B8%81/5-%E5%8A%A0%E5%AF%86%E8%B4%A7%E5%B8%81%E5%B0%B1%E6%98%AF%E8%B4%A7%E5%B8%81.html</a><br><a href="http://www.ruanyifeng.com/blog/2017/12/blockchain-tutorial.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2017/12/blockchain-tutorial.html</a><br><a href="http://lucky521.github.io/blog/design/2015/12/26/bitcoin.html#%E6%AF%94%E7%89%B9%E5%B8%81%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener">http://lucky521.github.io/blog/design/2015/12/26/bitcoin.html#%E6%AF%94%E7%89%B9%E5%B8%81%E5%8D%8F%E8%AE%AE</a><br><a href="https://www.jianshu.com/p/e710a389a3f1" target="_blank" rel="noopener">https://www.jianshu.com/p/e710a389a3f1</a><br><a href="https://program-think.blogspot.com/2017/08/GFW-Resilio-Sync.html" target="_blank" rel="noopener">https://program-think.blogspot.com/2017/08/GFW-Resilio-Sync.html</a><br><a href="https://program-think.blogspot.com/2017/09/Introduction-DHT-Kademlia-Chord.html" target="_blank" rel="noopener">https://program-think.blogspot.com/2017/09/Introduction-DHT-Kademlia-Chord.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/blockchain-1.jpg&quot; alt=&quot;区块链&quot;&gt;&lt;/p&gt;
&lt;p&gt;简单介绍区块链技术。&lt;/p&gt;
    
    </summary>
    
      <category term="cs" scheme="http://simyy.cn/categories/cs/"/>
    
    
      <category term="blockchain" scheme="http://simyy.cn/tags/blockchain/"/>
    
  </entry>
  
  <entry>
    <title>mysql 事务和索引</title>
    <link href="http://simyy.cn/2017/12/07/db-lock-index/"/>
    <id>http://simyy.cn/2017/12/07/db-lock-index/</id>
    <published>2017-12-07T10:03:48.000Z</published>
    <updated>2017-12-07T10:06:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录下对事务隔离的理解。</p><a id="more"></a><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>存储引擎<code>InnoDB</code>支持<code>事务</code>、<code>行级锁</code>。</p><h2 id="并发问题"><a href="#并发问题" class="headerlink" title="并发问题"></a>并发问题</h2><p>当两个事务同时进行的时候，两者之间互相不知道对方的存在，对自身所处的环境过分乐观，从而没有对操作的数据做一定的保护处理，导致出现以下问题：</p><p><code>更新丢失</code>：两个事务同时读取某一数据，但不同时进行更新操作，导致数据被覆盖的问题（重点在于<code>覆盖更新</code>）。</p><p><code>脏读</code>：一个事务修改了数据但是没有提交，另外一个事务会读取到这些未被提交的数据（重点在于<code>读取未提交的数据</code>）。</p><p><code>不可重复读</code>：一个事务在执行的过程中由于其他事务提交了新数据导致前后两次读取的内容不同（重点在于<code>两次读取内容的不同</code>）。</p><p><code>幻读</code>：一个事务由于其他事务同时的插入或删除造成按照相同条件的两次检索结果不同（重点在于<code>读取条数的不同</code>）。</p><h2 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h2><p><code>InnoDB</code>支持四种隔离级别：</p><ul><li><code>未提交读（read uncommited）</code></li><li><code>提交读（read commited）</code></li><li><code>可重复读（repeatable read）</code></li><li><code>串行化（serializable）</code></li></ul><blockquote><p>默认隔离级别为<code>可重复读</code>。</p></blockquote><p>四个隔离级别逐渐增强。</p><p><code>更新丢失</code>：可以通过CAS（对数据添加对应的版本）来实现数据的更新，当发现数据版本发生变化，则可触发回滚操作。</p><p><code>提交读</code>及以上隔离级别设定，一个事务只能读取另一个事务已经提交的数据，就避免了上面的脏读现象。</p><blockquote><p><code>提交读</code>是通过只读取提交后的数据来避免脏读问题。</p></blockquote><p><code>InnoDB</code>的<code>可重复读</code>并<code>不保证</code>避免<code>幻读</code>，需要应用使用<code>加锁读</code>来保证。而这个加锁度使用到的机制就是<code>next-keylocks</code>,<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM t_bitfly LOCK IN SHARE MODE;</span><br></pre></td></tr></table></figure></p><h2 id="next-key-lock"><a href="#next-key-lock" class="headerlink" title="next-key lock"></a>next-key lock</h2><p><code>InnoDB</code>支持的锁的类型包括：<code>共享锁S</code>、<code>排他锁X</code>、<code>意向共享IS</code>、<code>意向排他IX</code>。</p><blockquote><p>为了方便检查表级锁和行级锁之间的冲突，引入了意向锁。<br>意向锁是表锁，仅仅代表要对某行记录进行操作，只有在对行加锁时，才会判断是否冲突。</p></blockquote><p><code>InnoDB</code>中行锁的算法包括：</p><ul><li><code>record lock</code>：当个行记录上的锁；</li><li><code>gap lock</code>：间隙锁，锁定一个范围（<code>不包括记录本身</code>），为了避免幻读现象（保证同一事物两次读取内容系那个痛）；</li><li><code>next-key lock</code>：锁定一个范围，并且<code>锁定记录本身</code>，解决幻读问题。</li></ul><blockquote><p>间隙锁的区间是右闭区间，例如[1, 5)。</p></blockquote><p>具体例子可以<a href="http://www.cnblogs.com/zhoujinyi/p/3435982.html" target="_blank" rel="noopener">查看</a>。</p><h3 id="普通索引"><a href="#普通索引" class="headerlink" title="普通索引"></a>普通索引</h3><p>对于普通的索引(a)来说，<code>InnoDB</code>的行查询都采用了<code>next-key lock</code>算法，锁定不是单个值，而是一个范围（间隙）。</p><p>例如，如果表中已有[1, 3, 5, 8, 11]，那么所有的间隙如下，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(-无穷, 1] (1, 3] (3, 5] (5, 8] (8, 11] (11, +无穷]</span><br></pre></td></tr></table></figure></p><p>当执行三个事务如下，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">事务A：会锁住8的上下间隙，(5, 8] (8, 11]</span><br><span class="line">select * from t where a = 8 for update;</span><br><span class="line"></span><br><span class="line">事务B： 正常运行</span><br><span class="line">insert into t values(2);</span><br><span class="line"></span><br><span class="line">事务C：由于该范围被锁住，阻塞</span><br><span class="line">insert into t values(11);</span><br></pre></td></tr></table></figure></p><h3 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h3><p>对于唯一索引，<code>next-key lock</code>会做优化，将锁降级为<code>record lock</code>，也就是行锁，仅仅锁定行本身而不是范围。</p><p>因此，如果a为唯一索引(primary or unique)时，事务B和事务C将正常运行。</p><p>对于主键或唯一索引来说，如果锁定的是不存在的值，也会产品间隙锁。</p><h3 id="索引实现"><a href="#索引实现" class="headerlink" title="索引实现"></a>索引实现</h3><p>Btree（B+Tree）</p><p>参考：<a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html" target="_blank" rel="noopener">http://blog.codinglabs.org/articles/theory-of-mysql-index.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文记录下对事务隔离的理解。&lt;/p&gt;
    
    </summary>
    
      <category term="db" scheme="http://simyy.cn/categories/db/"/>
    
    
      <category term="mysql" scheme="http://simyy.cn/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>分布式事务</title>
    <link href="http://simyy.cn/2017/05/20/distributed-transaction/"/>
    <id>http://simyy.cn/2017/05/20/distributed-transaction/</id>
    <published>2017-05-20T09:40:21.000Z</published>
    <updated>2017-05-20T09:47:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>简单总结下分布式事务相关二段式、三段式提交以及Paxos算法。<br><a id="more"></a></p><h2 id="分布式系统的一致性"><a href="#分布式系统的一致性" class="headerlink" title="分布式系统的一致性"></a>分布式系统的一致性</h2><p>在分布式领域中，任何一个分布式系统都无法同时满足<code>一致性</code>、<code>可用性</code>和<code>容错性</code>（也就是CAP理论）。</p><p>一般来说系统权衡的结果是达到系统的<code>最终一致</code>，而非强一致性。</p><blockquote><p>分布式系统中数据不一致的问题？</p></blockquote><p>为了提高系统的整体性能，往往采用多机进行分布式部署，为了达到数据的同步必然存在着<code>数据复制</code>。但是数据复制在不同的数据节点之间由于网络等异常原因很容易造成数据不一致的情况。</p><h3 id="一致性模型"><a href="#一致性模型" class="headerlink" title="一致性模型"></a>一致性模型</h3><p>一致性模型可以分为三种：</p><ul><li><code>强一致性</code>：当更新操作完成后，任何后续操作访问的结果都是最新更新的值；</li><li><code>弱一致性</code>：当更新操作完成后，系统不保证后续操作访问的结构都一致，但会尽可能保证在某个时间点可以让数据达到一致；</li><li><code>最终一致性</code>：可以保证最终数据会达到一致。</li></ul><h2 id="二段式提交"><a href="#二段式提交" class="headerlink" title="二段式提交"></a>二段式提交</h2><p>二段式提交协议主要保证分布式事务的<code>原子性</code>（保证所有节点的操作一致），为了达到操作的一致引入了一个协调者来掌管所有节点。</p><p>二段式提交可以分为两个阶段：<code>准备阶段</code>和<code>提交阶段</code>。</p><p><code>准备阶段</code>：是一个投票的过程，步骤如下，</p><ul><li>协调者向所有节点询问是否提交操作，等带所有参与节点响应；</li><li>参与者执行询问发起为止的所有事务操作（已经执行了事务），并把是否执行信息写入日志；</li><li>各个参与者向协调者回复询问结果（如果执行成功返回同意，否则返回终止）。</li></ul><p><code>提交阶段</code>：是一个确认的过程，步骤如下，</p><ul><li>协调者接收到参与者的询问结果，如果包含终止结果，则需要对所有参与者发送回滚操作，否则向所有参与者发送提交命令；</li><li>参与者接受者接收到完成操作，释放整个事务期间占用的资源；</li><li>协调者接受到所有参与者完成操作，完成事务。</li></ul><blockquote><p>缺点？</p></blockquote><ul><li><code>同步阻塞</code>：所有参与者都是事务阻塞型的，当参与者占用公共资源时，其他节点在访问该公共资源的时候不得不阻塞等待。</li><li><code>单点故障</code>：协调者管理所有参与节点，如果协调者异常，参与者都会一直阻塞下去。</li><li><code>数据不一致</code>：对于提交阶段，如果协调者和参与者出现网络问题，参与者无法正常完成事务。</li></ul><h2 id="三段式提交"><a href="#三段式提交" class="headerlink" title="三段式提交"></a>三段式提交</h2><p><code>三段式提交</code>是二段式提交的改进版，主要不同在于：</p><ul><li>引入超时机制（协调者和参与者）</li><li>增加了一个询问阶段（但不会执行）</li></ul><p>三个阶段：</p><ul><li><code>can commit</code>：协调者询问参与者是否可以执行事务(投票)</li><li><code>pre commit</code>：执行事务，并返回执行结果</li><li><code>do commit</code>：提交事务，完成</li></ul><p>为了避免阻塞，在提交阶段，如果协调者没有接收到参与者的回应，会执行<code>终止事务</code>，另外，如果参与者一直没有接收到协调者的操作命令，那么就会直接提交事务，但是这并不会避免<code>数据不一致</code>的问题。</p><h2 id="Paxos算法"><a href="#Paxos算法" class="headerlink" title="Paxos算法"></a>Paxos算法</h2><p><a href="http://www.csdn.net/article/2014-01-20/2818197-distributed-system/2" target="_blank" rel="noopener">http://www.csdn.net/article/2014-01-20/2818197-distributed-system/2</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单总结下分布式事务相关二段式、三段式提交以及Paxos算法。&lt;br&gt;
    
    </summary>
    
      <category term="分布式" scheme="http://simyy.cn/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="分布式" scheme="http://simyy.cn/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>java threadlocal</title>
    <link href="http://simyy.cn/2017/04/16/java-threadlocal/"/>
    <id>http://simyy.cn/2017/04/16/java-threadlocal/</id>
    <published>2017-04-16T07:19:20.000Z</published>
    <updated>2017-04-16T07:23:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>介绍java中threadlocal的使用方法。<br><a id="more"></a></p><h2 id="threadlocal"><a href="#threadlocal" class="headerlink" title="threadlocal"></a>threadlocal</h2><p><code>threadlocal</code>主要解决的是每个线程绑定自己的值，也就是说保证相同变量在不同线程的<code>隔离性</code>。</p><p><code>threadlocal</code>保证每一个使用该变量的线程都提供一个变量值得副本，每一个副本的改动不会影响其他副本的值。</p><h2 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h2><p>默认情况下，初始化的<code>threadlocal</code>值为<code>null</code>，通过继承<code>threadlocal</code>并重写<code>initialValue</code>实现覆盖初始值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadLocal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal1</span> <span class="keyword">extends</span> <span class="title">ThreadLocal</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Object <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"default value"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ThreadLocal1 t1 = <span class="keyword">new</span> ThreadLocal1();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SimpleDateFormat安全格式化"><a href="#SimpleDateFormat安全格式化" class="headerlink" title="SimpleDateFormat安全格式化"></a>SimpleDateFormat安全格式化</h2><p><code>SimpleDateFormat</code>类是用来对日期字符串进行解析和格式化输出。</p><p><code>DateFormat</code>和<code>SimpleDateFormat</code>类不都是线程安全的，在多线程环境下调用<code>format</code>和<code>parse</code>方法应该使用同步代码来避免问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DateUtil</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用静态变量来存储SimpleDateFormat</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  String <span class="title">formatDate</span><span class="params">(Date date)</span> <span class="keyword">throws</span> ParseException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sdf.format(date);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Date <span class="title">parse</span><span class="params">(String strDate)</span> <span class="keyword">throws</span> ParseException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sdf.parse(strDate);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSimpleDateFormatThreadSafe</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.join(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e1) &#123;</span><br><span class="line">                e1.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="keyword">this</span>.getName()+<span class="string">":"</span>+DateUtil.parse(<span class="string">"2013-05-24 06:02:20"</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">new</span> TestSimpleDateFormatThreadSafe().start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;Thread-1&quot; Exception in thread &quot;Thread-2&quot; java.lang.NumberFormatException: multiple points</span><br><span class="line">at sun.misc.FloatingDecimal.readJavaFormatString(FloatingDecimal.java:1890)</span><br><span class="line">Thread-0:Fri May 24 06:02:20 CST 2013</span><br><span class="line">at sun.misc.FloatingDecimal.parseDouble(FloatingDecimal.java:110)</span><br><span class="line">at java.lang.Double.parseDouble(Double.java:538)</span><br><span class="line">at java.text.DigitList.getDouble(DigitList.java:169)</span><br><span class="line">at java.text.DecimalFormat.parse(DecimalFormat.java:2056)</span><br><span class="line">at java.text.SimpleDateFormat.subParse(SimpleDateFormat.java:1869)</span><br><span class="line">at java.text.SimpleDateFormat.parse(SimpleDateFormat.java:1514)</span><br><span class="line">at java.text.DateFormat.parse(DateFormat.java:364)</span><br><span class="line">at MyThreadLocal$DateUtil.parse(MyThreadLocal.java:28)</span><br><span class="line">at MyThreadLocal$TestSimpleDateFormatThreadSafe.run(MyThreadLocal.java:42)</span><br></pre></td></tr></table></figure></p><p>这正是由于<code>非线程安全的SimpleDateFormat</code>造成的（<a href="http://www.cnblogs.com/peida/archive/2013/05/31/3070790.html" target="_blank" rel="noopener">详情</a>）。</p><p><strong>推荐方法</strong>：使用<code>threadlocal</code>对不同线程使用不同的<code>SimpleDateFormat</code>对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalDateUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String date_format = <span class="string">"yyyy-MM-dd HH:mm:ss"</span>;</span><br><span class="line">    <span class="comment">// 使用threadlocal来为不同线程生成相同参数的不同副本</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;DateFormat&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;DateFormat&gt;(); </span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DateFormat <span class="title">getDateFormat</span><span class="params">()</span>   </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        DateFormat df = threadLocal.get();  </span><br><span class="line">        <span class="comment">// 默认值为null, 可以继承threadlocal重写initialValue来实现默认值</span></span><br><span class="line">        <span class="keyword">if</span>(df==<span class="keyword">null</span>)&#123;  </span><br><span class="line">            df = <span class="keyword">new</span> SimpleDateFormat(date_format);  </span><br><span class="line">            threadLocal.set(df);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> df;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">formatDate</span><span class="params">(Date date)</span> <span class="keyword">throws</span> ParseException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getDateFormat().format(date);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Date <span class="title">parse</span><span class="params">(String strDate)</span> <span class="keyword">throws</span> ParseException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getDateFormat().parse(strDate);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h2><p><code>ThreadLocal</code>有一个<code>ThreadLocalMap</code>静态内部类，这个<code>Map</code>为每个线程复制一个变量的<code>拷贝</code>，每一个内部线程都有一个<code>ThreadLocalMap</code>对象。</p><p>当线程调用<code>ThreadLocal.set(T object)</code>方法设置变量时，</p><ul><li><p>获取当前<code>线程引用</code>，</p></li><li><p>获取线程内部的<code>ThreadLocalMap</code>对象</p></li><li><p>设置<code>map</code>的<code>key</code>值为<code>threadLocal</code>对象，<code>value</code>为参数中的<code>object</code></p></li></ul><p>当线程调用<code>ThreadLocal.get()</code>方法获取变量时，</p><ul><li><p>获取当前<code>线程引用</code></p></li><li><p>以<code>threadLocal</code>对象为<code>key</code>去获取响应的<code>ThreadLocalMap</code>，</p></li><li><p>如果此<code>Map</code>不存在则初始化一个，否则返回其中的变量</p></li></ul><p>每个线程内部的<code>ThreadLocalMap</code>对象中的<code>key</code>保存的<code>threadLocal</code>对象的引用，但对<code>threadLocal</code>的对象的引用是<code>WeakReference弱引用</code>。</p><blockquote><p><code>ThreadLocalMap</code>是使用<code>ThreadLocal的弱引用</code>作为<code>Key</code>的，弱引用的对象在 <code>GC</code> 时会被回收。</p></blockquote><p>对于一个正常的<code>Map</code>来说，调用<code>Map.clear</code>方法来清空<code>map</code>，所有对象就会释放。调用<code>map.remove(key)</code>方法，会移除<code>key</code>对应的对象整个<code>entry</code>，这样key和value 就不会任何对象引用，被<code>java</code>虚拟机回收。</p><blockquote><p>内存泄露的原因？</p></blockquote><p><code>Thread</code>对象里面的<code>ThreadLocalMap</code>中的<code>key</code>是<code>ThreadLocal</code>的对象的<code>弱引用</code>，如果<code>ThreadLocal</code>对象会回收，那个这个对象对应的<code>key</code>就会变为<code>null</code>，那么<code>ThreadLocalMap</code>就无法移除其对应的<code>value</code>，那么<code>value</code>对象就无法被回收，导致<code>内存泄露</code>。</p><p>但是如果<code>Thread</code>运行结束，整个线程对象被回收，那么<code>value</code>所引用的对象也就会被垃圾回收。</p><p>对于没有使用<code>线程池</code>的方法来说，因为每次线程运行完就退出了，<code>Map</code>里面引用的所有对象都会被垃圾回收，所以没有关系。</p><blockquote><p>如何避免？</p></blockquote><p><code>ThreadLocalMap</code>的设计中已经考虑到这种情况，也加上了一些防护措施：在<code>ThreadLocal</code>的<code>get()</code>,<code>set()</code>,<code>remove()</code>的时候都会清除线程<code>ThreadLocalMap</code>里所有<code>key</code>为<code>null</code>的<code>value</code>。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.cnblogs.com/peida/archive/2013/05/31/3070790.html" target="_blank" rel="noopener">http://www.cnblogs.com/peida/archive/2013/05/31/3070790.html</a><br><a href="http://blog.xiaohansong.com/2016/08/06/ThreadLocal-memory-leak/?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="noopener">http://blog.xiaohansong.com/2016/08/06/ThreadLocal-memory-leak/?utm_source=tuicool&amp;utm_medium=referral</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍java中threadlocal的使用方法。&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="http://simyy.cn/categories/java/"/>
    
    
      <category term="java" scheme="http://simyy.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java 多线程</title>
    <link href="http://simyy.cn/2017/04/12/java-thread/"/>
    <id>http://simyy.cn/2017/04/12/java-thread/</id>
    <published>2017-04-11T16:46:09.000Z</published>
    <updated>2017-04-11T16:47:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>介绍java中多线程。<br><a id="more"></a></p><h2 id="Runnable-amp-Thread"><a href="#Runnable-amp-Thread" class="headerlink" title="Runnable &amp; Thread"></a>Runnable &amp; Thread</h2><p><code>Thread</code>类中的<code>start</code>方法通知<code>线程规划器</code>此线程已经就绪，等待调用线程对象的<code>run</code>方法。</p><p>使用<code>run</code>方法是同步的，此线程对象并不会交给<code>线程规划器</code>来进行处理，而是由当前主线程来同步执行。</p><p>使用<code>start</code>方法是同步的，但系统调用<code>run</code>方法的过程是异步执行，因此线程执行与<code>start</code>的顺序是不一致的。</p><p><code>java</code>不支持多继承，对于已有父类的继承类来说，需要实现<code>Runnable</code>接口来实现线程类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableHello</span> <span class="keyword">extends</span> <span class="title">MyHello</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    RunnableHello runnableHello = <span class="keyword">new</span> RunnableHello();</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(runnableHello);</span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><p><code>synchronized</code>关键字能够保证在同一时刻最多只有一个线程执行该段代码。</p><p><code>synchronized</code>可用于标记<code>对象</code>、<code>代码块</code>、<code>函数</code>等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">synchronized(someObj) &#123; // dosomething &#125;</span><br><span class="line">sychronized(this) &#123; // dosomething&#125;</span><br><span class="line">synchronized public void method() &#123; // dosomething &#125;</span><br></pre></td></tr></table></figure><h2 id="interrupt"><a href="#interrupt" class="headerlink" title="interrupt"></a>interrupt</h2><p><code>interrupt</code>：用于停止当前线程，不会立刻停止，而是先给当前线程打一个中断标记。</p><p><code>interrupted</code>：测试当前线程是否已经中断状态，执行后清除状态标识为<code>false</code>。</p><p><code>isInterrupted</code>：测试当前线程是否已经中断状态，不清除状态标识。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 观察打印结果</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtendsThread1</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.isInterrupted()) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"interrupted"</span>);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ExtendsThread1 thread1 = <span class="keyword">new</span> ExtendsThread1();</span><br><span class="line">    thread1.start();</span><br><span class="line">    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    thread1.interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="suspend"><a href="#suspend" class="headerlink" title="suspend"></a>suspend</h2><p><code>suspend</code>用于暂停线程，但已经<code>废弃</code>了。</p><blockquote><p><code>废弃原因</code>：使用suspend和resume方法容易因为线程暂定导致数据不同步的情况，会造成死锁。</p></blockquote><h2 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h2><p><code>yeild</code>用于放弃当前占用的<code>CPU</code>资源，但放弃的时间不确定，下一次获得<code>CPU</code>的占用权的时间同样不能确定。</p><p><code>yeild</code>特性：</p><ul><li>静态的原生(<code>native</code>)方法；</li><li>状态切换的<code>非实时性</code>；</li><li>当前正在执行的线程把运行机会交给线程池中拥有<code>相同优先级</code>的线程；</li><li>它仅能使一个线程从运行状态转到<code>可运行状态</code>，而不是等待或阻塞状态。</li></ul><h2 id="priority"><a href="#priority" class="headerlink" title="priority"></a>priority</h2><p><code>setPriority</code>方法可以用来设置线程的优先级，优先级高的线程更容易获得<code>CPU的执行权</code>。</p><p><code>java</code>中线程优先级分为1~10，默认定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public final static int MIN_PRIORITY = 1;</span><br><span class="line">public final static int NORM_PRIORITY = 5;</span><br><span class="line">public final static int MAX_PRIORITY = 10;</span><br></pre></td></tr></table></figure></p><p>线程的优先级是<code>可继承的</code>。</p><h2 id="daemon"><a href="#daemon" class="headerlink" title="daemon"></a>daemon</h2><p><code>java</code>中可以通过<code>setDaemon</code>方法设置<code>守护线程</code>。</p><blockquote><p><code>守护线程</code>是一种特殊的线程，只有当JVM停止运行时，该线程才会被结束。例如，垃圾回收器就是一个用于回收内存对象的<code>守护线程</code>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍java中多线程。&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="http://simyy.cn/categories/java/"/>
    
    
      <category term="java" scheme="http://simyy.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java 异常</title>
    <link href="http://simyy.cn/2017/04/08/java-exception/"/>
    <id>http://simyy.cn/2017/04/08/java-exception/</id>
    <published>2017-04-08T14:30:12.000Z</published>
    <updated>2017-04-08T14:31:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>介绍java中的异常处理。<br><a id="more"></a></p><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p><code>java</code>中的异常可分为<code>检查的异常</code>和<code>非检查异常</code>。</p><p>在<code>java</code>中，异常的类层次结构如下，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">           Throwable</span><br><span class="line">         /          \</span><br><span class="line">    Error            Exception</span><br><span class="line">    /   \           /         \</span><br><span class="line">VMError AWTError  IOException  RuntimeException</span><br></pre></td></tr></table></figure></p><p>所有异常都是继承自<code>Throwable</code>，分为<code>Error</code>和<code>Exception</code>。</p><p><code>Error</code>一般是<code>JVM</code>问题导致，也就是说在应用程序控制和处理之外产生的，因此此类异常是<code>不可检查的</code>。</p><p><code>Exception</code>是程序自身产生的异常，是可以通过<code>try-catch</code>和<code>throws</code>来控制。</p><p><code>Exception</code>可被划分为非检查的<code>RuntimeException</code>和检查的<code>IOException</code>。</p><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><h3 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h3><p>在<code>java</code>中可以用<code>try-catch</code>语句来捕获异常（可捕获检查和非检查异常），<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">try &#123;  </span><br><span class="line">    // 可能会发生异常的程序代码  </span><br><span class="line">&#125; catch (Type1 id1)&#123;  </span><br><span class="line">    // 捕获并处置try抛出的异常类型Type1  </span><br><span class="line">&#125; catch (Type2 id2)&#123;  </span><br><span class="line">    // 捕获并处置try抛出的异常类型Type2  </span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    // 无论是否发生异常需要处理</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>异常是按照<code>catch</code>的顺序依次捕获的，所以需要按照继承关系来决定捕获顺序。</p><blockquote><p><code>finally</code>一般用来关闭一下IO操作，例如文件、网络连接。</p></blockquote><h2 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h2><p>在<code>java</code>中可以使用<code>throws</code>来抛出异常，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void method() throws Exception1, Exception2, ... &#123;</span><br><span class="line">    // 执行</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="throwable"><a href="#throwable" class="headerlink" title="throwable"></a>throwable</h2><p><code>throwable</code>作为异常处理的基类，常用的功能函数有,<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">getCause(); <span class="comment">// 获取异常原因</span></span><br><span class="line">getMessage(); <span class="comment">// 异常信息</span></span><br><span class="line">printStackTrace(); <span class="comment">// 堆栈跟踪异常信息</span></span><br></pre></td></tr></table></figure></p><blockquote><p>注意：<code>RuntimeException</code>不需要抛出，并不会造成编译错误。</p></blockquote><h2 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h2><p>通过继承<code>Exception</code>以及其子类可以实现自定义异常，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class MyException extends Exception &#123;</span><br><span class="line">    public MyException() &#123;&#125;</span><br><span class="line">    public MyException(String message) &#123;</span><br><span class="line">        super(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由于继承<code>Exception</code>，则需要接口处理该异常时添加<code>throws</code>指明抛出检查异常，否则无法编译通过。</p><p>如果是继承<code>RuntimeException</code>，则不需要指定<code>throws</code>抛出异常，但是需要注意外层对于该异常的处理方法，这种异常会被隐藏起来。</p><blockquote><p>如何选择异常类型，<code>检查</code> or <code>非检查</code>？</p></blockquote><p>设计异常一般有两种，内部使用和外部使用。</p><p>对于外部使用，也就是提供给调用方来处理的异常，一般是由于服务中依赖某不稳定的服务，提供服务方不能处理该异常，需要调用方自行处理该异常情况。</p><p>对于内部使用，也就是程序内部自定义的异常，一般是由于跳出当前逻辑处理，直接返回，那么，就需要在逻辑的最外层来统一处理该自定义异常。</p><h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><p>在使用异常来做控制流程处理的时候，一般有两种方式：<code>自定义异常</code>和<code>自定义返回结果</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 自定义异常</span><br><span class="line">class BizException extends RuntimeException &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">// 自定义返回结果</span><br><span class="line">class BizResult&lt;T&gt; extends ObjectInfo &#123; ... &#125;</span><br></pre></td></tr></table></figure></p><p>如果使用<code>自定义返回结果</code>，需要在每次调用函数时使用<code>if-else</code>来做判断，这样性能必然是<code>最好的</code>，但是在写业务逻辑的时候就会非常繁琐，每次调用都会添加一次<code>if-else</code>逻辑。</p><p>如果使用<code>自定义异常</code>，需要在调用服务的最外层都添加一个针对<code>自定义异常</code>的异常处理，业务逻辑看起来好一点，但是这样性能就会差一点。</p><blockquote><p>如何提高异常性能？</p></blockquote><p>在参考中的一篇文章中，有提到通过重写<code>fillInStackTrace</code>来提高性能，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public synchronized Throwable fillInStackTrace() &#123;</span><br><span class="line">    if (stackTrace != null ||</span><br><span class="line">        backtrace != null /* Out of protocol state */ ) &#123;</span><br><span class="line">        fillInStackTrace(0);</span><br><span class="line">        stackTrace = UNASSIGNED_STACK;</span><br><span class="line">    &#125;</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>fillInStackTrace</code>函数是一个同步的方法，在多线程的情况下必然会造成性能下降。在测试过程中发现，即使在单线程的情况下，仍然可以提升很大性能。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://niehan.blog.techweb.com.cn/archives/259.html" target="_blank" rel="noopener">http://niehan.blog.techweb.com.cn/archives/259.html</a><br><a href="http://blog.csdn.net/beijiguangyong/article/details/9080727" target="_blank" rel="noopener">http://blog.csdn.net/beijiguangyong/article/details/9080727</a><br><a href="http://www.blogjava.net/stone2083/archive/2010/07/09/325649.html" target="_blank" rel="noopener">http://www.blogjava.net/stone2083/archive/2010/07/09/325649.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍java中的异常处理。&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="http://simyy.cn/categories/java/"/>
    
    
      <category term="java" scheme="http://simyy.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java 日志注解</title>
    <link href="http://simyy.cn/2017/04/08/java-anotion-log/"/>
    <id>http://simyy.cn/2017/04/08/java-anotion-log/</id>
    <published>2017-04-08T09:15:38.000Z</published>
    <updated>2017-04-08T09:30:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>介绍如何使用java注解来添加日志。<br><a id="more"></a></p><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><p><code>元注解</code>的作用是注解其他注解，</p><ul><li><p><code>@Target</code>用于描述注解范围。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CONSTRUCTOR:用于描述构造器</span><br><span class="line">FIELD:用于描述域</span><br><span class="line">LOCAL_VARIABLE:用于描述局部变量</span><br><span class="line">METHOD:用于描述方法</span><br><span class="line">PACKAGE:用于描述包</span><br><span class="line">PARAMETER:用于描述参数</span><br><span class="line">TYPE:用于描述类、接口(包括注解类型) 或enum声明</span><br></pre></td></tr></table></figure></li><li><p><code>@Retention</code>用于描述注解生命周期。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SOURCE:在源文件中有效（即源文件保留）</span><br><span class="line">CLASS:在class文件中有效（即class保留）</span><br><span class="line">RUNTIME:在运行时有效（即运行时保留），可以通过反射获取该注解的属性值</span><br></pre></td></tr></table></figure></li><li><p><code>@Documented</code>用于生命构建注解文档。</p></li><li><code>@Inherited</code>用于描述该注解是可被子类继承的。</li></ul><h3 id="注解格式"><a href="#注解格式" class="headerlink" title="注解格式"></a>注解格式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public @interface 注解名 &#123;定义体&#125;</span><br></pre></td></tr></table></figure><h2 id="日志注解"><a href="#日志注解" class="headerlink" title="日志注解"></a>日志注解</h2><p><code>Log</code>注解定义，参数包含<code>type</code>日志类型、<code>desc</code>日志描述、<code>throwable</code>是否catch异常、<code>withResult</code>是否记录打印结果。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(&#123; ElementType.METHOD, ElementType.PARAMETER &#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Log &#123;</span><br><span class="line">    <span class="function">String <span class="title">type</span><span class="params">()</span> <span class="keyword">default</span> LogConst.RUN_LOG</span>; </span><br><span class="line">    <span class="function">String <span class="title">desc</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">throwable</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">withResult</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>需要注意，注解的默认值必须是常量（不可以设置为枚举）</p></blockquote><p>那么常量如何定义？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogConst</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 日志类型</span></span><br><span class="line">    <span class="comment">/* 访问日志 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String ACCESS_LOG = <span class="string">"ACCESS"</span>;</span><br><span class="line">    <span class="comment">/* 事件日志 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String EVENT_LOG = <span class="string">"EVENT"</span>;</span><br><span class="line">    <span class="comment">/* 运行日志 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String RUN_LOG = <span class="string">"RUN"</span>;</span><br><span class="line">    <span class="comment">/* 异常日志 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String EXCP_LOG = <span class="string">"EXCEPTION"</span>;</span><br></pre></td></tr></table></figure></p><p>开启注解和<code>AOP配置</code>，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;context:annotation-config/&gt;</span><br><span class="line">&lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot;/&gt;</span><br></pre></td></tr></table></figure></p><blockquote><p>在注解中其实还可以做更多的事？在注解中我们可以增加异常监控，增加事件数量监控等等。</p></blockquote><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p>通过切片来获取当前获取被注释执行的函数情况，这里使用<code>aroundExec</code>来实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Aspect</span><br><span class="line">@Component</span><br><span class="line">public class LogAop &#123;</span><br><span class="line">@Around(value = &quot;@annotation(com.simyy.web.aop.Log)&quot;)</span><br><span class="line">public Object aroundExec(ProceedingJoinPoint pjp) throws Throwable &#123;</span><br><span class="line">    Method method = ((MethodSignature) pjp.getSignature()).getMethod();</span><br><span class="line">    String logType = method.getAnnotation(Log.class).type();</span><br><span class="line">    boolean throwable = method.getAnnotation(Log.class).throwable();</span><br><span class="line">    boolean withResult = method.getAnnotation(Log.class).withResult();</span><br><span class="line">    // 设置过无允许抛出异常或设置日志类型为异常日志</span><br><span class="line">    if (throwable == false || logType.equals(LogConst.EXCP_LOG)) &#123;</span><br><span class="line">        return withoutExpProcess(pjp, logType , withResult);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return withExpProcess(pjp, logType , withResult);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对于异常日志处理方式就是通过增加<code>try-catch</code>来捕获并记录日常情况。<br>其中，<code>getEmptyObjectByClassType</code>是用于在捕获异常后返回空对象或失败对象，<code>getContentByType</code>是用于按固定格式打印日志记录的函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">private Object withoutExpProcess(ProceedingJoinPoint pjp, String logType, boolean withResult) throws Throwable &#123;</span><br><span class="line">    Object[] args = pjp.getArgs();</span><br><span class="line">    Method method = ((MethodSignature) pjp.getSignature()).getMethod();</span><br><span class="line">    Class returnType = ((MethodSignature) pjp.getSignature()).getReturnType();</span><br><span class="line"></span><br><span class="line">    Long start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    Object retVal;</span><br><span class="line">    Exception exp = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        retVal = pjp.proceed();</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        retVal = getEmptyObjectByClassType(returnType);</span><br><span class="line">        exp = e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (exp == null) &#123;</span><br><span class="line">        // 异常日志类型不需要捕获正常运行记录，因此直接返回</span><br><span class="line">        if (logType.equals(LogConst.EXCP_LOG)) &#123;</span><br><span class="line">            return retVal;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Long useTime = System.currentTimeMillis() - start;</span><br><span class="line">        String afterLog;</span><br><span class="line">        if (withResult == true) &#123;</span><br><span class="line">            afterLog = getContentByType(AFTER_WITH_RESULT, method, args, useTime, retVal);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            afterLog = getContentByType(AFTER, method, args, useTime, retVal);</span><br><span class="line">        &#125;</span><br><span class="line">        LOGGER.info(afterLog);</span><br><span class="line"></span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        String errorLog = getContentByType(ERROR, method, args, null, null);</span><br><span class="line">        LOGGER.error(errorLog, exp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return retVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>相反，对于不需要捕获异常的运行日志，只需要记录访问情况，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private Object withExpProcess(ProceedingJoinPoint pjp, String logType, boolean withResult) throws Throwable &#123;</span><br><span class="line">    Object[] args = pjp.getArgs();</span><br><span class="line">    Method method = ((MethodSignature) pjp.getSignature()).getMethod();</span><br><span class="line">    Class returnType = ((MethodSignature) pjp.getSignature()).getReturnType();</span><br><span class="line"></span><br><span class="line">    Long start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    String beforeLog = getContentByType(BEFORE, method, args, null, null);</span><br><span class="line">    LOGGER.info(beforeLog);</span><br><span class="line"></span><br><span class="line">    Object retVal = pjp.proceed();</span><br><span class="line"></span><br><span class="line">    Long useTime = System.currentTimeMillis() - start;</span><br><span class="line">    if (withResult == true) &#123;</span><br><span class="line">        String afterLog = getContentByType(AFTER_WITH_RESULT, method, args, useTime, retVal);</span><br><span class="line">        LOGGER.info(afterLog);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return retVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>用于返回空对象的函数,<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">private Object getEmptyObjectByClassType(Class classType) &#123;</span><br><span class="line">    if (classType.equals(List.class)) &#123;</span><br><span class="line">        return Collections.EMPTY_LIST;</span><br><span class="line">    &#125;</span><br><span class="line">    if (classType.equals(Map.class)) &#123;</span><br><span class="line">        return Collections.EMPTY_MAP;</span><br><span class="line">    &#125;</span><br><span class="line">    if (classType.equals(Set.class)) &#123;</span><br><span class="line">        return Collections.EMPTY_SET;</span><br><span class="line">    &#125;</span><br><span class="line">    if (classType.equals(boolean.class) || classType.equals(Boolean.class)) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    // 对于特殊的执行result对象需要特殊处理</span><br><span class="line">    // do somethind</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>定义日志打印格式用于<code>getContentByType</code>函数，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private final String BEFORE_TMPL = &quot;TYPE=[%s] DESC=[%s] METHOD=[%s] PARAMS=[%s]&quot;;</span><br><span class="line">private final String AFTER_TMPL = &quot;TYPE=[%s] DESC=[%s] METHOD=[%s] PARAMS=[%s] TIME=[%d ms]&quot;;</span><br><span class="line">private final String AFTER_TMPL_WITH_RESULT = &quot;TYPE=[%s] DESC=[%s] METHOD=[%s] PARAMS=[%s] TIME=[%d ms] RESULT=[%s]&quot;;</span><br><span class="line">private final String ERROR_TMPL = BEFORE_TMPL;</span><br><span class="line"></span><br><span class="line">// 获取当前类名+函数名称</span><br><span class="line">private String getClassAndMethodName(Method method) &#123;</span><br><span class="line">    String methodName = method.getName();</span><br><span class="line">    String className = method.getDeclaringClass().getSimpleName();</span><br><span class="line">    return className + &quot;.&quot; + methodName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="More"><a href="#More" class="headerlink" title="More"></a>More</h2><p>日志采用<code>异步</code>打印提高性能；<br>增加异常监控或重要事件处理<code>监控方案</code>；<br>毕竟反射还是带来一定的<code>性能损耗</code>。<br>对于异常error的代码行这样会丢失，那可以通过<code>Throable.getStackTrace()</code>方法获取运行栈进行分析获取需要的错误行和错误原因。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍如何使用java注解来添加日志。&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="http://simyy.cn/categories/java/"/>
    
    
      <category term="java" scheme="http://simyy.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>python 定时任务</title>
    <link href="http://simyy.cn/2017/04/03/schedule/"/>
    <id>http://simyy.cn/2017/04/03/schedule/</id>
    <published>2017-04-03T14:39:37.000Z</published>
    <updated>2017-04-08T09:25:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>介绍python中实现定时任务的几种方式。<br><a id="more"></a></p><h2 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h2><p><code>Timer</code>是<code>threading</code>提供的一个阻塞函数，用于延迟执行任务。<br>为了利用<code>Timer</code>实现定时任务，需要使用一个<code>递归</code>来实现，如下<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Timer</span><br><span class="line"></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ding</span><span class="params">(period)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> i</span><br><span class="line">    <span class="keyword">print</span> i,  datetime.now().strftime(<span class="string">"%Y-%m-%d %H:%M:%S"</span>)</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line">    t = Timer(period, ding,  (period,))</span><br><span class="line">    t.start()</span><br><span class="line"></span><br><span class="line">ding(<span class="number">3</span>)</span><br></pre></td></tr></table></figure></p><h2 id="sched"><a href="#sched" class="headerlink" title="sched"></a>sched</h2><p><code>sched</code>是<code>Python</code>内置的一个调度模块（<a href="https://docs.python.org/2/library/sched.html" target="_blank" rel="noopener">详情</a>）。<br>创建调度任务：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sched.scheduler(timefunc, delayfunc)</span><br><span class="line"><span class="comment"># timefunc, delayfunc延迟等待指定的函数</span></span><br></pre></td></tr></table></figure></p><p><code>sched</code>使用<code>调度队列</code>来管理调度任务，<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 调度任务队列，用来存储未执行的任务</span></span><br><span class="line">scheduler.queue</span><br><span class="line"><span class="comment"># 调度任务队列是否为空</span></span><br><span class="line">scheduler.empty()</span><br><span class="line"><span class="comment"># 执行调度任务</span></span><br><span class="line">scheduler.run()</span><br><span class="line"><span class="comment"># 增加任务，向任务队列中增加任务</span></span><br><span class="line"><span class="comment"># delay延迟时间/priority优先级/action执行函数/argument函数参数</span></span><br><span class="line">scheduler.enter(delay, priority, action, argument)</span><br><span class="line"><span class="comment"># 取消任务，从任务队列中删除任务</span></span><br><span class="line">scheduler.cancel(event)</span><br></pre></td></tr></table></figure></p><p>实例，需要注意如果使用<code>delayfunc</code>中包含延时功能，当延时时间大于任务延时时间）可能会增大延时时间。<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> sched</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">schedule = sched.scheduler(time.time, time.sleep)</span><br><span class="line"></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ding</span><span class="params">(period)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> i</span><br><span class="line">    <span class="keyword">print</span> i, datetime.now().strftime(<span class="string">"%Y-%m-%d %H:%M:%S"</span>)</span><br><span class="line">    schedule.enter(period, <span class="number">0</span>, ding, (period,))</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(period=<span class="number">3</span>)</span>:</span></span><br><span class="line">    schedule.enter(<span class="number">0</span>, <span class="number">0</span>, ding, (period,))</span><br><span class="line">    schedule.run()</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure></p><h2 id="apscheduler"><a href="#apscheduler" class="headerlink" title="apscheduler"></a>apscheduler</h2><p><code>apscheduler</code>是一个<code>Python</code>定时任务框架，全称<code>Advanced Python Scheduler</code>（<a href="http://apscheduler.readthedocs.io/en/latest/userguide.html#scheduler-events" target="_blank" rel="noopener">文档</a>）。</p><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><p><code>triggers</code>是用于启动调度逻辑的触发器，每一个任务都拥有自己的触发器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">特定日期`date`、固定间隔`interval`、特定时间定时`cron`</span><br></pre></td></tr></table></figure></p><p><code>job stores</code>是用来存储调度任务，可选内存、缓存、数据库作为存储媒介。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MemoryJobStore内存存储(默认)</span><br><span class="line">MongoDBJobStore数据库存储</span><br><span class="line">SQLAlchemyJobStore数据库存储</span><br></pre></td></tr></table></figure></p><p><code>executors</code>是用来执行调度任务的，可使用线程或进程池作为执行器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor线程池执行器(默认)</span><br><span class="line">ProcessPoolExecutor进程池执行器</span><br></pre></td></tr></table></figure></p><p><code>scheduler</code>主要是用于选择阻塞、异步模型，提供了<code>gevent</code>、<code>Tornador</code>等框架的支持。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BlockingScheduler：阻塞式；</span><br><span class="line">BackgroundScheduler：用于后台执行（需要保证主线程运行，否则关闭）；</span><br><span class="line">AsyncIOScheduler：用于异步IO；</span><br><span class="line">GeventScheduler: 用于gevent；</span><br><span class="line">TornadoScheduler: 用于Tornador;</span><br><span class="line">TwistedScheduler: 用于Twisted;</span><br><span class="line">QtScheduler: 用于Qt;</span><br></pre></td></tr></table></figure></p><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p><code>例1</code>中选择了阻塞调度器<code>BlockingScheduler</code>，并通过设置间隔执行<code>interval</code>，<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 例1</span></span><br><span class="line"><span class="keyword">from</span> apscheduler.schedulers.blocking <span class="keyword">import</span> BlockingScheduler</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ding</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> i</span><br><span class="line">    <span class="keyword">print</span> i, datetime.now().strftime(<span class="string">"%Y-%m-%d %H:%M:%S"</span>)</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">scheduler = BlockingScheduler()</span><br><span class="line">scheduler.add_job(ding, <span class="string">'interval'</span>, seconds=<span class="number">3</span>)</span><br><span class="line">scheduler.start()</span><br></pre></td></tr></table></figure></p><p><code>例12</code>中选择了后台调度器<code>BackgroundScheduler</code>，增加两个任务分别使用<code>interval</code>和<code>cron</code>来设置触发器，<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 例2</span></span><br><span class="line"><span class="keyword">from</span> apscheduler.schedulers.background <span class="keyword">import</span> BackgroundScheduler</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ding</span><span class="params">(name)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> i</span><br><span class="line">    <span class="keyword">print</span> i, name, datetime.now().strftime(<span class="string">"%Y-%m-%d %H:%M:%S"</span>)</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">scheduler = BackgroundScheduler()</span><br><span class="line">scheduler.add_job(ding, <span class="string">'interval'</span>, seconds=<span class="number">3</span>, args=(<span class="string">'interval'</span>,))</span><br><span class="line">scheduler.add_job(ding, <span class="string">'cron'</span>, second=<span class="string">'*/1'</span>, args=(<span class="string">'cron'</span>,))</span><br><span class="line">scheduler.start()</span><br><span class="line"><span class="keyword">print</span> <span class="string">'background scheduler start ... sleep'</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">time.sleep(<span class="number">10</span>)</span><br></pre></td></tr></table></figure></p><p>更多复杂的<a href="http://apscheduler.readthedocs.io/en/latest/userguide.html#code-examples" target="_blank" rel="noopener">例子…</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍python中实现定时任务的几种方式。&lt;br&gt;
    
    </summary>
    
      <category term="python" scheme="http://simyy.cn/categories/python/"/>
    
    
      <category term="python" scheme="http://simyy.cn/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>java object</title>
    <link href="http://simyy.cn/2017/03/30/java-object/"/>
    <id>http://simyy.cn/2017/03/30/java-object/</id>
    <published>2017-03-30T14:16:32.000Z</published>
    <updated>2017-04-08T09:30:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>介绍java中的object类。<br><a id="more"></a></p><h2 id="RegisterNatives"><a href="#RegisterNatives" class="headerlink" title="RegisterNatives"></a>RegisterNatives</h2><p><a href="http://stackoverflow.com/questions/1010645/what-does-the-registernatives-method-do" target="_blank" rel="noopener">StackOverflow</a><br>功能：JVM用来寻找本地函数</p><h2 id="getClass"><a href="#getClass" class="headerlink" title="getClass"></a>getClass</h2><p><a href="http://stackoverflow.com/questions/30918889/how-to-understand-the-object-getclass-method" target="_blank" rel="noopener">StackOverflow</a><br>功能：返回对象的运行时类</p><h2 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode"></a>hashCode</h2><p>功能：获取给定对象的唯一整数，用于确定对象在<code>HashTable</code>中的位置，默认值为对象内存地址编号</p><p>可使用<code>Apache Commons Lang</code>重写<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> PRIME = <span class="number">31</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HashCodeBuilder(getId()%<span class="number">2</span>==<span class="number">0</span>?getId()+<span class="number">1</span>:getId(), PRIME).toHashCode();</span><br><span class="line"> &#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>)</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (o.getClass() != getClass())</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> EqualsBuilder().append(getId(), ((Demo)o).getId()).isEquals();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h2 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h2><p>功能：比较两个对象是否相等<br>注意：如果重写<code>equals</code>方法必须重写<code>hashCode</code>方法</p><p><code>==</code>：基本类型是比较值，引用类型是比较对象地址，而<code>equals</code>方法无法作用于基本类型，默认情况（未重写）下是比较对象的地址。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="clone"><a href="#clone" class="headerlink" title="clone"></a>clone</h2><p>功能：复制对象<br>复制对象需要先分配一个和源对象同样大小的空间，然后在这个空间中创建一个新的对象。</p><p>在JAVA中创建对象的方法有两种：<code>new</code>和<code>clone</code>。<br>new操作符的本意是分配内存。程序执行到new操作符时， 首先去看new操作符后面的类型，因为知道了类型，才能知道要分配多大的内存空间。分配完内存之后，再调用构造函数，填充对象的各个域，这一步叫做对象的初始化，构造方法返回后，一个对象创建完毕，可以把他的引用（地址）发布到外部，在外部就可以使用这个引用操纵这个对象。<br>clone操作符的本意是复制内存。在第一步是和new相似的， 都是分配内存，调用clone方法时，分配的内存和源对象（即调用clone方法的对象）相同，然后再使用原对象中对应的各个域，填充新对象的域， 填充完成之后，clone方法返回，一个新的相同的对象被创建，同样可以把这个新对象的引用发布到外部。</p><p>注意：<code>clone</code>是浅拷贝，也就是只拷贝基本类型的值以及对象的引用。</p><p>为了实现深拷贝，需要实现Clonable接口，覆盖并实现clone方法，除了调用父类中的clone方法得到新的对象， 还要将该类中的引用变量也clone出来，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Body</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;  </span><br><span class="line">    <span class="keyword">public</span> Head head;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Body</span><span class="params">()</span> </span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Body</span><span class="params">(Head head)</span> </span>&#123;<span class="keyword">this</span>.head = head;&#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;  </span><br><span class="line">        Body newBody =  (Body) <span class="keyword">super</span>.clone();  </span><br><span class="line">        newBody.head = (Head) head.clone();  </span><br><span class="line">        <span class="keyword">return</span> newBody;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Head</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;  </span><br><span class="line">    <span class="keyword">public</span>  Face face;  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Head</span><span class="params">()</span> </span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Head</span><span class="params">(Face face)</span></span>&#123;<span class="keyword">this</span>.face = face;&#125;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果在拷贝一个对象时，要想让这个拷贝的对象和源对象完全彼此独立，那么在引用链上的每一级对象都要被显式的拷贝，因此，彻底的深拷贝是非常困难的。</p><h2 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a>toString</h2><p>默认情况下，返回格式如下,<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getClass().getName() + <span class="string">'@'</span> + Integer.toHexString(hashCode())</span><br></pre></td></tr></table></figure></p><p>一般建议每一个类都重写该方法，便于开发和调试。</p><h2 id="object-lock"><a href="#object-lock" class="headerlink" title="object lock"></a>object lock</h2><p>所有对象都自动含有单一的锁。</p><p>JVM负责跟踪对象被加锁的次数。如果一个对象被解锁，其计数变为0。在任务（线程）第一次给对象加锁的时候，计数变为1。每当这个相同的任务（线程）在此对象上获得锁时，计数会递增。</p><p>只有首先获得锁的任务（线程）才能继续获取该对象上的多个锁。</p><p>每当任务离开一个<code>synchronized</code>方法，计数递减，当计数为0的时候，锁被完全释放，此时别的任务就可以使用此资源。</p><p>而<code>wait</code>、<code>notify</code>、<code>notifyAll</code>是<code>Java</code>语言提供的实现线程间阻塞(<code>Blocking</code>)和控制进程内调度(<code>inter-process communication</code>)的底层机制。</p><h2 id="wait"><a href="#wait" class="headerlink" title="wait"></a>wait</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Causes the current thread to wait until another thread invokes the notify() method or the notifyAll() method for this object.</span><br></pre></td></tr></table></figure><p><code>wait</code>方法用来将当前线程置入<code>等待状态</code>，直到接到通知或被中断为止。<br>在调用<code>wait</code>方法之前，线程必须要获得该对象的对象级别锁，即只能在同步方法或同步块中调用<code>wait</code>方法。进入<code>wait</code>方法后，当前线程释放锁。在从<code>wait</code>方法返回前，线程与其他线程竞争重新获得锁。如果调用<code>wait</code>方法时，没有持有适当的锁，则抛出<code>IllegalMonitorStateException</code>，它是<code>RuntimeException</code>的一个子类，因此，不需要<code>try-catch</code>结构。</p><h2 id="notify"><a href="#notify" class="headerlink" title="notify"></a>notify</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Wakes up a single thread that is waiting on this object&apos;s monitor.</span><br></pre></td></tr></table></figure><p><code>notify</code>方法也要在同步方法或同步块中调用，即在调用前，线程也必须要获得该对象的对象级别锁，如果调用<code>notify</code>方法时没有持有适当的锁，也会抛出<code>IllegalMonitorStateException</code>。<br><code>notify</code>方法用来通知那些可能等待该对象的对象锁的其他线程。如果有多个线程等待，则线程规划器任意挑选出其中一个<code>等待状态</code>的线程来发出通知，并使它等待获取该对象的对象锁。其他处于<code>等待状态</code>的线程在未收到<code>notify</code>或<code>notifyAll</code>通知之前，会一直阻塞在<code>等待状态</code>（即使对象已经空闲）。</p><blockquote><p>注意：处于<code>等待状态</code>的线程等待的是<code>notify</code>或<code>notifyAll</code>的通知而不是对象锁，也就是说<code>notify</code>和<code>notifyAll</code>只是回复竞争的机会。</p></blockquote><h2 id="notifyAll"><a href="#notifyAll" class="headerlink" title="notifyAll"></a>notifyAll</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Wakes up all threads that are waiting on this object&apos;s monitor.</span><br></pre></td></tr></table></figure><p> <code>notifyAll</code>方法与<code>notify</code>方法的工作方式相同，重要的一点差异是：<code>全部被唤醒</code>。<code>notifyAll</code>会唤醒所有处于<code>等待状态</code>的线程，变成等待获取该对象上的锁，一旦该对象锁被释放，他们就会去竞争对象锁。如果其中一个线程获得了该对象锁，它就会继续往下执行，在它退出synchronized代码块，释放锁后，其他的已经被唤醒的线程将会继续竞争获取该锁，一直进行下去，直到所有被唤醒的线程都执行完毕。</p><h2 id="finalize"><a href="#finalize" class="headerlink" title="finalize"></a>finalize</h2><p><code>finalize</code>是GC在回收对象之前最先调用的方法。<br><code>C++</code>中的析构函数调用的时机是确定的（对象离开作用域或delete掉），但<code>Java</code>中的<code>finalize</code>的调用具有不确定性，只有当JVM发生GC时才会回收这部分对象的内存。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍java中的object类。&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="http://simyy.cn/categories/java/"/>
    
    
      <category term="java" scheme="http://simyy.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>flex</title>
    <link href="http://simyy.cn/2017/03/27/flex/"/>
    <id>http://simyy.cn/2017/03/27/flex/</id>
    <published>2017-03-27T15:27:41.000Z</published>
    <updated>2017-04-08T09:30:58.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>flex</code>属性用于设置或检索弹性盒模型对象的子元素如何分配空间。<br><a id="more"></a><br><code>flex</code>属性是<code>flex-grow</code>、<code>flex-shrink</code>和<code>flex-basis</code>属性的简写属性。</p><blockquote><p><strong>注意</strong>：如果元素不是弹性盒模型对象的子元素，则 flex 属性不起作用。</p></blockquote><p>属性包括<code>flex-basis</code>、<code>flex-direction</code>、<code>flex-flow</code>、<code>flex-shrink</code>、<code>flex-grow</code>、<code>flex-wrap</code>。</p><h2 id="flex-basis"><a href="#flex-basis" class="headerlink" title="flex-basis"></a><a href="http://www.runoob.com/cssref/css3-pr-flex-basis.html" target="_blank" rel="noopener">flex-basis</a></h2><p><code>flex-basis</code>属性用于设置或检索弹性盒伸缩基准值，默认值<code>auto</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">可选：number|auto|initial|inherit;</span><br><span class="line">其中，number表示长度单位或百分比，auto表示根据内容决定当前盒子长度。</span><br><span class="line"></span><br><span class="line">//实例：指定class=&quot;test&quot;元素下，第二个div元素的宽度</span><br><span class="line">.test div:nth-of-type(2) &#123;</span><br><span class="line">    -webkit-flex-basis: 80px; /* Safari 6.1+ */</span><br><span class="line">    flex-basis: 80px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>nth-of-type()选择器？</p></blockquote><p><code>nth-of-type(n)</code> 选择器匹配属于父元素的特定类型的第 N 个子元素的每个元素。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//实例1：按奇偶顺序改变子元素颜色</span><br><span class="line">p:nth-of-type(odd)</span><br><span class="line">&#123;</span><br><span class="line">  background:#ff0000;</span><br><span class="line">&#125;</span><br><span class="line">p:nth-of-type(even)</span><br><span class="line">&#123;</span><br><span class="line">  background:#0000ff;</span><br><span class="line">&#125;</span><br><span class="line">//实例2：按3n+1的顺序添加背景颜色</span><br><span class="line">p:nth-of-type(3n+0)</span><br><span class="line">&#123;</span><br><span class="line">  background:#ff0000;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="flex-direction"><a href="#flex-direction" class="headerlink" title="flex-direction"></a><a href="http://www.runoob.com/cssref/css3-pr-flex-direction.html" target="_blank" rel="noopener">flex-direction</a></h2><p><code>flex-direction</code>属性用于指定子元素的排列方向。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可选：row|row-reverse|column|column-reverse|initial|inherit</span><br></pre></td></tr></table></figure></p><h2 id="flex-wrap"><a href="#flex-wrap" class="headerlink" title="flex-wrap"></a><a href="http://www.runoob.com/cssref/css3-pr-flex-wrap.html" target="_blank" rel="noopener">flex-wrap</a></h2><p><code>flex-wrap</code>属性用于指定flex容器内子元素的排列方式：单行或多行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可选：nowarp单行|warp多行|warp-reverse反向多行</span><br></pre></td></tr></table></figure></p><h2 id="flex-flow"><a href="#flex-flow" class="headerlink" title="flex-flow"></a><a href="http://www.runoob.com/cssref/css3-pr-flex-flow.html" target="_blank" rel="noopener">flex-flow</a></h2><p><code>flex-flow</code>属性用于设置子元素的排列顺序，是<code>flex-direction</code>和<code>flex-wrap</code>复合属性。</p><h2 id="flex-grow"><a href="#flex-grow" class="headerlink" title="flex-grow"></a><a href="http://www.runoob.com/cssref/css3-pr-flex-grow.html" target="_blank" rel="noopener">flex-grow</a></h2><p><code>flex-grow</code>属性用于设置子元素扩大的比率。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可选：比例（当小于1时缩小）|initial|inherit</span><br></pre></td></tr></table></figure></p><h2 id="flex-shrink"><a href="#flex-shrink" class="headerlink" title="flex-shrink"></a><a href="http://www.runoob.com/cssref/css3-pr-flex-shrink.html" target="_blank" rel="noopener">flex-shrink</a></h2><p><code>flex-shrink</code>属性用于设置子元素缩小的比率。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可选：比例（当大于1时扩小）|initial|inherit</span><br></pre></td></tr></table></figure></p><blockquote><p><code>flex-grow</code>和<code>flex-shrink</code>其实可以实现同样的效果。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;flex&lt;/code&gt;属性用于设置或检索弹性盒模型对象的子元素如何分配空间。&lt;br&gt;
    
    </summary>
    
      <category term="fe" scheme="http://simyy.cn/categories/fe/"/>
    
    
      <category term="css" scheme="http://simyy.cn/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>垃圾回收GC</title>
    <link href="http://simyy.cn/2017/01/25/gc/"/>
    <id>http://simyy.cn/2017/01/25/gc/</id>
    <published>2017-01-24T17:11:45.000Z</published>
    <updated>2017-04-08T09:35:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>现代语言中，大多数都实现了垃圾回收功能，不再需要开发者自己来释放无用的内存资源，大大提高了开发效率。<br><a id="more"></a></p><p><img src="/images/gc-1.jpg" alt=""></p><h2 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h2><p>1960 年前后诞生于 MIT 的 <code>Lisp</code> 语言是第一种高度依赖于动态内存分配技术的语言。Lisp 中几乎所有数据都以“表”的形式出现，而“表”所占用的空间则是在堆中动态分配得到的。 Lisp 语言先天就具有的动态内存管理特性要求Lisp 语言的设计者必须解决堆中每一个内存块的自动释放问题，否则，Lisp 程序员就必然被程序中不计其数的 <code>free / delete</code> 语句淹没，这直接导致了垃圾收集技术的诞生和发展。</p><p>在学校和工作中，我使用过<code>c/c++</code>这种需要开发者自己来维护内存，时时刻刻需要小心内存泄露的问题，也使用过<code>python</code>、<code>golang</code>、<code>js</code>以及<code>java</code>这种不需要关系内存资源的释放，让自己更加专注于程序的设计和开发，但是也带来了性能的损耗。</p><p><code>垃圾回收GC</code>并不是万能的，如果你接受了它的便利，那么你也需要接受<code>GC</code>带来的性能开销。</p><h2 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h2><p>内存分配大概分为三种：静态分配、局部分配以及动态分配。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">静态分配（ Static Allocation ）：</span><br><span class="line">静态变量和全局变量的分配形式。通常，它们无需释放和回收。</span><br><span class="line"></span><br><span class="line">自动分配（ Automatic Allocation ）：</span><br><span class="line">在栈中为局部变量分配内存的方法。栈中的内存可以随着代码块退出时的出栈操作被自动释放。</span><br><span class="line"></span><br><span class="line">动态分配（ Dynamic Allocation ）：</span><br><span class="line">在堆中动态分配内存空间以存储数据的方式。堆中的内存需要开发者自己来管理，谨慎对待每一个动态分配的对象，避免造成内存泄露。</span><br><span class="line">在软件开发中，如果你懒得释放内存，那么你也需要一台类似的机器人——这其实就是一个由特定算法实现的垃圾收集器。</span><br></pre></td></tr></table></figure></p><p>因此，垃圾回收的目的是<code>回收动态分配的内存</code>。</p><h2 id="垃圾回收GC"><a href="#垃圾回收GC" class="headerlink" title="垃圾回收GC"></a>垃圾回收GC</h2><p>垃圾回收技术主要包括：引用计数、跟踪式以及分代。</p><h3 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h3><p><code>引用计数Reference Counting</code>为每个内存对象维护一个引用计数器,<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 新的引用指向某对象时，该对象引用计数器加1</span><br><span class="line">if add refrence:</span><br><span class="line">    counter +=1</span><br><span class="line"></span><br><span class="line">// 对象的引用被销毁时，该对象引用计数器减1</span><br><span class="line">if remove refrence:</span><br><span class="line">   counter -= 1</span><br><span class="line"></span><br><span class="line">// 对象的计数器归零时，回收该对象所占用的内存资源</span><br><span class="line">if counter == 0:</span><br><span class="line">   free object</span><br></pre></td></tr></table></figure></p><p>每个计数器只记录了其对应对象的局部信息-<code>被引用的次数</code>，而没有全局的应用信息。</p><p>由于只维护局部信息，所以不需要扫描全局对象图就可以识别并释放死对象，但也因为缺乏全局对象图信息，所以无法处理<code>循环引用</code>的状况。</p><blockquote><p>循环引用？</p></blockquote><p>A引用B，B又引用了A，那么A和B引用计数器的值均为1，无法释放该资源。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A &lt;- B</span><br><span class="line">B &lt;- A</span><br></pre></td></tr></table></figure></p><p><code>优点 &amp; 缺点</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">优点</span><br><span class="line">- 每次创建和销毁都要更新引用计数值，会引起额外的开销</span><br><span class="line">- 计数简单，只需要记录自身被引用次数</span><br><span class="line">- 实时的垃圾回收，不会造成中断</span><br><span class="line"></span><br><span class="line">缺点</span><br><span class="line">- 无法处理循环引用</span><br><span class="line">- 多线程对同一对象计数更新产设个竞争</span><br></pre></td></tr></table></figure></p><p><code>Python</code>使用了引用计数算法，为了解决循环引用的问题还设计了其他GC模块(<code>标记清除</code>和<code>分代收集</code>)。<br>此外，<code>Python</code>为了解决引用技术的性能问题还引入了内存池机制。</p><h3 id="跟踪式"><a href="#跟踪式" class="headerlink" title="跟踪式"></a>跟踪式</h3><p><code>跟踪式垃圾回收</code>是比较常见的垃圾回收技术，主要原则是从程序栈的若干个根对象出发，构造一个可达链，对于那些不可达的内存对象，做回收。</p><p> 如果一个内存对象有被程序中的至少一个变量引用（直接指向或间接指向），则认为该对象可达，否则认为该对象不可达，可以被垃圾回收。</p><h4 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h4><p><code>标记清除Mark-Sweep</code>的基本思路是遍历以对象为节点、以引用为边构成的图，把所有可以访问到的对象打上标记，然后清扫一遍内存空间，把所有没标记的对象释放。</p><p>具体过程分两步：</p><ul><li>从根（Root）开始遍历，被根引用了的对象标记为非垃圾对象，非垃圾对象引用的对象同样标记为非垃圾对象，以此递归直到标记完所有对象；</li><li>再次从根节点开始，对已被标记为垃圾的对象清除释放。</li></ul><p><img src="/images/gc-2.png" alt=""></p><p>如图，红色代表垃圾对象，黄色代表非垃圾对象，绿色代表未使用空间。</p><blockquote><p>缺点：内存碎片</p></blockquote><p>由于标记清除不需要移动对象的位置，直接回收垃圾对象必然会造成<code>内存碎片</code>。</p><h4 id="标记复制"><a href="#标记复制" class="headerlink" title="标记复制"></a>标记复制</h4><p><code>标记复制 Mark-Copy</code>只需要对对象进行一次遍历。</p><p>它的基本思想是利用空间换时间，从根开始开始遍历对象，如果对象仍然存在引用，就把它复制到新的内存空间中，一次遍历结束之后，所有存在于新空间的对象就是所有的非垃圾对象，可直接释放掉原有内存空间，不会造成内存碎片。</p><p><img src="/images/gc-3.png" alt=""></p><p>如图，红色代表垃圾对象，黄色代表非垃圾对象，绿色代表未使用空间。</p><blockquote><p>缺点：浪费内存</p></blockquote><p>标记复制更快速但是需要额外开辟一块用来复制的内存，对垃圾比例较大的情况占优势。</p><p>此外，内存空间切换过程中需要暂停程序运行（也就是常说GC停顿）。</p><h4 id="标记压缩"><a href="#标记压缩" class="headerlink" title="标记压缩"></a>标记压缩</h4><p><code>标记压缩Mark-Compact</code>是在标记清除算法的基础之上增加对象的移动，从而解决内存碎片的问题。</p><p>在压缩阶段，由于要移动可达对象，那么需要考虑移动对象时的顺序，一般分为下面三种：</p><ul><li><p>任意顺序 - 即不考虑原先对象的排列顺序，也不考虑对象间的引用关系，随意的移动可达对象，这样可能会有内存访问的局部性问题。</p></li><li><p>线性顺序 - 在重新排列对象时，会考虑对象间的引用关系，比如A对象引用了B对象，那么就会尽可能的将A，B对象排列在一起。</p></li><li><p>滑动顺序 - 顾名思义，就是在重新排列对象时，将对象按照原先堆内存中的排列顺序滑动到堆的一端。</p></li></ul><p>现在大多数的垃圾收集算法都是按照任意顺序或滑动顺序去实现的(由于线性顺序需要考虑对象的引用关系所以实现复杂)。</p><p><code>Two-Finger 算法</code>数据移动过程类似快排，分别用两个指针指向内存的两端，分别向中心移动。如果右侧指针遇到垃圾数据直接回收，否则，移动左侧指针直到遇到可替换垃圾对象，然后替换左右指针的对象。</p><p><img src="/images/gc-4.png" alt=""></p><blockquote><p>缺点：移动对象的代价</p></blockquote><p>为了避免内存碎片，移动对象需要遍历整个内存空间，还需要暂停程序更换映射地址空间。</p><h3 id="分代回收"><a href="#分代回收" class="headerlink" title="分代回收"></a>分代回收</h3><p><code>分代回收</code>是根据对象的存活周期的不同将内存划分为几块。一般把java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。</p><p><img src="/images/gc-5.png" alt=""></p><h4 id="年轻代垃圾回收"><a href="#年轻代垃圾回收" class="headerlink" title="年轻代垃圾回收"></a>年轻代垃圾回收</h4><p><img src="/images/gc-6.png" alt=""></p><p>年轻代回收特点：</p><ul><li>新对象的内存分配都是先在Eden区域中进行的；</li><li>当Eden区域的空间不足于分配新对象时，就会触发年轻代上的垃圾回收<code>minor gc</code>（minor garbage collection）；</li><li>每个对象都有一个<code>年龄</code>，代表对象经历过的<code>minor gc</code>的次数；</li><li>当触发<code>minor gc</code>后，所有存活的对象都会被拷贝到一个新的<code>survivor</code>区域，并且年龄增加1；当对象的年龄足够大，它会从survivor内存区域升级到老年代中。</li></ul><h4 id="年老代垃圾回收"><a href="#年老代垃圾回收" class="headerlink" title="年老代垃圾回收"></a>年老代垃圾回收</h4><p>当老年代内存区域（图中<code>Tenured</code>）无法容纳新对象时，这时候就会触发老年代的垃圾回收<code>major gc</code>（major garbage collection”）。</p><blockquote><p>垃圾回收算法<code>PS</code>和<code>CMS</code></p></blockquote><p>常用的垃圾回收算法有<code>Parallel Scavenge(PS)</code> 和<code>Concurrent Mark Sweep(CMS)</code>，它们的不同之处体现在年老代的垃圾回收过程中，而年轻代的垃圾回收过程在这两种垃圾回收器中基本上是一致的。<code>PS</code>在执行垃圾回收时使用了<code>多线程</code>来一起进行垃圾回收，这样可以提高垃圾回收的效率，<code>CMS</code>在进行垃圾回收时，应用程序可以同时运行。</p><p>在年轻代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对他进行分配担保，就必须使用“标记-整理”算法进行回收。</p><h3 id="Parallel-Scavenge"><a href="#Parallel-Scavenge" class="headerlink" title="Parallel Scavenge"></a>Parallel Scavenge</h3><p><code>PS垃圾回收</code>是由<code>标记清除</code>和<code>标记压缩</code>算法组成。</p><p>标记清除算法的一个缺陷就是它会引起内存碎片问题。继而有可能会引发连续的major gc。假设当前存在的内存碎片有10M，但最大的内存碎片只能容纳2M的对象，这个时候如果有一个3M的对象从Survivor区域升级到Tenured区域，那Tenured区域也没有办法存放这个3M的对象。结果就是不断的触发major gc，直到Out of Memory。所以，PS垃圾回收器在清除非可达对象后，还会进行一次compact，来消除内存碎片。</p><h3 id="Concurrent-Mark-Sweep"><a href="#Concurrent-Mark-Sweep" class="headerlink" title="Concurrent Mark Sweep"></a>Concurrent Mark Sweep</h3><p><code>CMS</code>在进行垃圾收集时，应用程序是可以并行运行的，因此，它减少了垃圾收集时暂停应用程序的时间。<br>垃圾回收的四个阶段如下，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1. Initial Mark阶段</span><br><span class="line">程序暂停运行`Stop-The-Word`，标记到根对象的第一层孩子节点即停止 ，然后程序恢复运行。由于只标记一层节点，所以暂停时间很短。</span><br><span class="line"></span><br><span class="line">2. Concurrent Mark阶段</span><br><span class="line">以Initial Mark阶段标记的节点为根对象，重新开始标记Tenured区域中的可达对象（不需要暂停应用程序，因此称为&quot;Concurrent Mark&quot;）。</span><br><span class="line">由于CMS垃圾回收器和应用程序同时运行，Concurrent Mark阶段它并不保证在Tenured区域的可达对象都被标记了（分配新对象）。</span><br><span class="line"></span><br><span class="line">3. Remark阶段</span><br><span class="line">暂停应用程序，确保所有的可达对象都被标记（Concurrent Mark阶段未标记的，`可多线程标记`）。</span><br><span class="line"></span><br><span class="line">4. Concurrent Sweep阶段</span><br><span class="line">恢复应用程序的执行，执行sweep来清除所有非可达对象所占用的内存空间。</span><br></pre></td></tr></table></figure></p><p>与<code>PS</code>相比，<code>CS</code>垃圾回收算法可以减少程序暂停的时间。</p><p><img src="/images/gc-7.png" alt=""></p><h3 id="Garbage-First"><a href="#Garbage-First" class="headerlink" title="Garbage First"></a>Garbage First</h3><p>CMS垃圾收集器虽然减少了暂停应用程序的运行时间，但是由于它没有Compact阶段，它还是存在着内存碎片问题。于是，为了去除内存碎片问题，同时又保留CMS垃圾收集器低暂停时间的优点，JAVA7发布了一个新的垃圾收集器 - G1垃圾收集器。</p><p><img src="/images/gc-8.png" alt=""></p><p>G1垃圾收集器和CMS垃圾收集器有几点不同，最大的不同是内存的组织方式变了。Eden，Survivor和Tenured等内存区域不再是连续的了，而是变成了一个个大小一样的region - 每个region从1M到32M不等。</p><p><code>G1</code>垃圾回收的四个阶段如下，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1. Initial Mark阶段</span><br><span class="line">同CMS垃圾收集器的Initial Mark阶段一样，程序暂停运行`Stop-The-Word`，标记到根对象的第一层孩子节点即停止 ，然后程序恢复运行。</span><br><span class="line">由于只标记一层节点。但它不会单独暂停应用程序的执行，而是在G1触发minor gc是发生。</span><br><span class="line"></span><br><span class="line">2. Concurrent Mark阶段</span><br><span class="line">同CMS垃圾收集器的Concurrent Mark阶段一样，重新开始标记Tenured区域中的可达对象（不需要暂停应用程序）。</span><br><span class="line">但G1还会回收掉Tenured region中对象的存活率很小或者基本没有对象存活的内存区域（不需要等待clean up阶段，因此成为Garbage First），并计算每个 region的对象存活率以供clean up阶段使用 。</span><br><span class="line"></span><br><span class="line">3. Remark阶段 </span><br><span class="line">同CMS垃圾收集器的Remark阶段一样, 但G1采用一种叫做SATB(snapshot-at-the-begining)的算法能够在Remark阶段更快的标记可达对象。</span><br><span class="line"></span><br><span class="line">4. Clean up/Copy阶段</span><br><span class="line">与CMS中不同，它有一个Clean up/Copy阶段，在minor gc发生的同时G1会挑选出那些对象存活率低的region进行回收。</span><br></pre></td></tr></table></figure></p><p>由于Initial Mark阶段和Clean up/Copy阶段都是跟minor gc同时发生的，相比于CMS，G1暂停应用程序的时间更少，从而提高了垃圾回收的效率。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;现代语言中，大多数都实现了垃圾回收功能，不再需要开发者自己来释放无用的内存资源，大大提高了开发效率。&lt;br&gt;
    
    </summary>
    
      <category term="cs" scheme="http://simyy.cn/categories/cs/"/>
    
    
      <category term="gc" scheme="http://simyy.cn/tags/gc/"/>
    
  </entry>
  
  <entry>
    <title>单点登录</title>
    <link href="http://simyy.cn/2016/12/13/sso/"/>
    <id>http://simyy.cn/2016/12/13/sso/</id>
    <published>2016-12-12T16:51:05.000Z</published>
    <updated>2017-04-08T09:33:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>单点登录全称Single Sign On（简称SSO），是指在多系统中用户只需要登录一个系统，便可在其他所有系统中得到授权而无需再次登录。<br><a id="more"></a></p><h2 id="传统方法"><a href="#传统方法" class="headerlink" title="传统方法"></a>传统方法</h2><p>对于小型站点来说，可以直接通过cookie和session在多个页面下实现登录状态的共享。<br>session常被保存在redis/memcache集群中，以便提高访问效率。<br><strong>使用cookie和session有哪些问题？</strong><br>cookie不安全，需要通过加密算法来处理；<br>使用cookie不能跨域。</p><h2 id="单点登录"><a href="#单点登录" class="headerlink" title="单点登录"></a>单点登录</h2><p>主要思想是设计一个独立于各个系统的登录系统，也即是说要把用户登录的权限验证统一管理。</p><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>单点登录需要一个独立的认证中心，只有认证中心能接受用户的用户名密码等安全信息，其他系统不提供登录入口，只接受认证中心的间接授权。</p><h3 id="认证步骤"><a href="#认证步骤" class="headerlink" title="认证步骤"></a>认证步骤</h3><p>通过SSO认证登录，然后把授权信息发送给各个系统，具体步骤如下：</p><ul><li>用户登录某一系统，未登录则跳转到sso认证中心</li><li>用户在sso输入用户名密码，认证通过，生成授权令牌</li><li>sso把授权令牌发送到各个子系统和用户</li><li>用户重新访问原有系统， 通过验证授权令牌，登入系统</li><li><h3 id="注销步骤"><a href="#注销步骤" class="headerlink" title="注销步骤"></a>注销步骤</h3>由于单点登录的状态是统一管理的，那么用户在任何一个系统中注销登录状态的同时需要保证其他系统的授权令牌同时失效，具体步骤如下：</li><li>用户在某一个系统注销登录</li><li>注销信息会传递给sso认证中心</li><li>认证中心再通知各个系统销毁授权令牌</li></ul><h3 id="系统特点"><a href="#系统特点" class="headerlink" title="系统特点"></a>系统特点</h3><ul><li>sso需要保存一份全局的用户登录状态（也就是授权令牌和登录用户的关系）；</li><li>sso作为登录状态的唯一管理者，每次授权和销毁都需要同步最新的授权令牌的状态到各个子系统；</li><li>sso和其他系统之间需要建立一套数据同步机制。</li></ul><h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><p><strong>大量授权请求如何处理？</strong><br>大量授权请求会带来大量的授权数据，由于授权数据的临时性，可将这些授权信息存储的缓存系统中，常见memcache/redis等；<br>大量的授权请求会产生大量的授权令牌的生成，常见的授权令牌都需要加密处理，必然影响系统性能，可通过预生成授权令牌的方式来降低批量生成令牌造成的资源竞争。</p><p><strong>全局和局部的授权令牌如何同步处理？</strong><br>SSO和系统发生认证和注销操作都需要同步给系统中的每一个系统；<br>授权令牌采用按时间过期的方式，定期更新授权令牌到各个子系统；<br>至少保证登录注销的信息传递到SSO认证中心。</p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>常见的单点登录包括一些网站或应用的微信认证登录、QQ认证登录、微博认证登录；<br>淘宝、360、微博、网易、美团的登录认证方式。</p><h2 id="其他类似系统"><a href="#其他类似系统" class="headerlink" title="其他类似系统"></a>其他类似系统</h2><p>全局唯一ID生成器（不仅仅是UUID），可参考微信消息的唯一ID的生成方式</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;单点登录全称Single Sign On（简称SSO），是指在多系统中用户只需要登录一个系统，便可在其他所有系统中得到授权而无需再次登录。&lt;br&gt;
    
    </summary>
    
      <category term="web" scheme="http://simyy.cn/categories/web/"/>
    
    
      <category term="web" scheme="http://simyy.cn/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>redis 跳跃表</title>
    <link href="http://simyy.cn/2016/12/06/redis-skiplist/"/>
    <id>http://simyy.cn/2016/12/06/redis-skiplist/</id>
    <published>2016-12-06T15:52:58.000Z</published>
    <updated>2017-04-08T09:25:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍redis中的跳跃表的原理和实现。<br><a id="more"></a></p><h2 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h2><p>跳跃表通过在每个节点维护多个指向其他节点的指针来提高节点的访问效率。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍redis中的跳跃表的原理和实现。&lt;br&gt;
    
    </summary>
    
      <category term="cache" scheme="http://simyy.cn/categories/cache/"/>
    
    
      <category term="redis" scheme="http://simyy.cn/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>redis 字典</title>
    <link href="http://simyy.cn/2016/12/03/redis-dict/"/>
    <id>http://simyy.cn/2016/12/03/redis-dict/</id>
    <published>2016-12-03T05:37:02.000Z</published>
    <updated>2017-04-08T09:26:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍redis字典的具体实现。<br><a id="more"></a></p><h2 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h2><p>redis字典和python的字典（java中的map）的性质是一样的，也被称为关联数组或映射，是一种保存键值对的数据结构。</p><p>redis字典使用哈希表作为底层实现，字典中的键不允许相同。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">    dictEntry **table; <span class="comment">// 哈希表</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size; <span class="comment">// 哈希表大小</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask; <span class="comment">// 哈希表大小掩码</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used; <span class="comment">// 已使用大小</span></span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure><p>哈希表中每一个键值对用<code>dictEntry</code>来表示，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *key; <span class="comment">// 键</span></span><br><span class="line">    <span class="keyword">union</span> &#123; <span class="comment">// 值</span></span><br><span class="line">        <span class="keyword">void</span> *val;</span><br><span class="line">        <span class="keyword">uint64_t</span> u64;</span><br><span class="line">        <span class="keyword">int64_t</span> s64;</span><br><span class="line">        <span class="keyword">double</span> d;</span><br><span class="line">    &#125; v;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span> <span class="comment">// 链表指针</span></span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure><p>其中，next<code>指针是用来解决哈希表的键冲突的，所有key的哈希值相同的节点都会添加在链表上。</code>v`值支持4种格式：指针、unit64_t、int64_t、double类型。</p><p><img src="/images/redis-hash.png" alt=""></p><h2 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h2><p>添加新的键值对时，需要先计算键的哈希值和索引值，然后按照索引值把键值对插入到对应的位置。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查找key在索引中的位置</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> _dictKeyIndex(dict *d, <span class="keyword">const</span> <span class="keyword">void</span> *key, <span class="keyword">unsigned</span> <span class="keyword">int</span> hash, dictEntry **existing)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> idx, table;</span><br><span class="line">    dictEntry *he;</span><br><span class="line">    <span class="keyword">if</span> (existing) *existing = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Expand the hash table if needed */</span></span><br><span class="line">    <span class="keyword">if</span> (_dictExpandIfNeeded(d) == DICT_ERR) <span class="comment">// 哈希表扩展</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (table = <span class="number">0</span>; table &lt;= <span class="number">1</span>; table++) &#123; <span class="comment">// 遍历两个哈希table</span></span><br><span class="line">        idx = hash &amp; d-&gt;ht[table].sizemask; <span class="comment">// 获取table上索引位置</span></span><br><span class="line">        <span class="comment">/* Search if this slot does not already contain the given key */</span></span><br><span class="line">        he = d-&gt;ht[table].table[idx];</span><br><span class="line">        <span class="keyword">while</span>(he) &#123; <span class="comment">// 遍历桶内数据（冲突链）</span></span><br><span class="line">            <span class="keyword">if</span> (key==he-&gt;key || dictCompareKeys(d, key, he-&gt;key)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (existing) *existing = he;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            he = he-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!dictIsRehashing(d)) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> idx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加键值对</span></span><br><span class="line"><span class="function">dictEntry *<span class="title">dictAddRaw</span><span class="params">(dict *d, <span class="keyword">void</span> *key, dictEntry **existing)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">    dictEntry *entry;</span><br><span class="line">    dictht *ht;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) _dictRehashStep(d); <span class="comment">// 如果在rehash，则采用渐进方式</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Get the index of the new element, or -1 if</span></span><br><span class="line"><span class="comment">     * the element already exists. */</span></span><br><span class="line">    <span class="keyword">if</span> ((index = _dictKeyIndex(d, key, dictHashKey(d,key), existing)) == <span class="number">-1</span>) <span class="comment">// -1代表已存在</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    ht = dictIsRehashing(d) ? &amp;d-&gt;ht[<span class="number">1</span>] : &amp;d-&gt;ht[<span class="number">0</span>];</span><br><span class="line">    entry = zmalloc(<span class="keyword">sizeof</span>(*entry));</span><br><span class="line">    entry-&gt;next = ht-&gt;table[index]; <span class="comment">// 链表头插法</span></span><br><span class="line">    ht-&gt;table[index] = entry;</span><br><span class="line">    ht-&gt;used++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set the hash entry fields. */</span></span><br><span class="line">    dictSetKey(d, entry, key);</span><br><span class="line">    <span class="keyword">return</span> entry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a>功能实现</h2><h3 id="rehash"><a href="#rehash" class="headerlink" title="rehash"></a>rehash</h3><p>当桶后面的链表不断增长时，访问目标键值变慢，就需要rehash来加快访问速度（减少链表长度）。</p><p>此外，随着键值对的添加和删除，需要动态调整哈希表的大小。</p><p>在redis中，字典的存储结构如下，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    dictType *type;</span><br><span class="line">    <span class="keyword">void</span> *privdata;</span><br><span class="line">    dictht ht[<span class="number">2</span>]; <span class="comment">// 默认使用ht[0],ht[1]用于rehash</span></span><br><span class="line">    <span class="keyword">long</span> rehashidx; <span class="comment">/* 是否执行rehash的标识rehashing not in progress if rehashidx == -1 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> iterators; <span class="comment">/* number of iterators currently running */</span></span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure></p><p>其中，ht[2]用来存储字典内容，只有在进行rehash操作时，ht[1]才会被用到（默认hash数据都存储在ht[0]上）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictRehash</span><span class="params">(dict *d, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> empty_visits = n*<span class="number">10</span>; <span class="comment">/* Max number of empty buckets to visit. */</span></span><br><span class="line">    <span class="keyword">if</span> (!dictIsRehashing(d)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(n-- &amp;&amp; d-&gt;ht[<span class="number">0</span>].used != <span class="number">0</span>) &#123;</span><br><span class="line">        dictEntry *de, *nextde;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">        assert(d-&gt;ht[<span class="number">0</span>].size &gt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>)d-&gt;rehashidx);</span><br><span class="line">        <span class="keyword">while</span>(d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            d-&gt;rehashidx++; <span class="comment">// 如果当前table桶中数据为空，则增加索引值</span></span><br><span class="line">            <span class="keyword">if</span> (--empty_visits == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        de = d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx]; <span class="comment">// 获取当前哈希桶中的第一个键值对</span></span><br><span class="line">        <span class="comment">/* Move all the keys in this bucket from the old to the new hash HT */</span></span><br><span class="line">        <span class="keyword">while</span>(de) &#123; <span class="comment">// 遍历哈希桶中的所有数据</span></span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">int</span> h;</span><br><span class="line"></span><br><span class="line">            nextde = de-&gt;next;</span><br><span class="line">            <span class="comment">/* Get the index in the new hash table */</span></span><br><span class="line">            h = dictHashKey(d, de-&gt;key) &amp; d-&gt;ht[<span class="number">1</span>].sizemask; <span class="comment">// rehash原有数据到新的哈希表的桶中</span></span><br><span class="line">            de-&gt;next = d-&gt;ht[<span class="number">1</span>].table[h];</span><br><span class="line">            d-&gt;ht[<span class="number">1</span>].table[h] = de;</span><br><span class="line">            d-&gt;ht[<span class="number">0</span>].used--;</span><br><span class="line">            d-&gt;ht[<span class="number">1</span>].used++;</span><br><span class="line">            de = nextde;</span><br><span class="line">        &#125;</span><br><span class="line">        d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx] = <span class="literal">NULL</span>;</span><br><span class="line">        d-&gt;rehashidx++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check if we already rehashed the whole table... */</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].used == <span class="number">0</span>) &#123; <span class="comment">//如果原有hash表中所有数据已转移完成，则释放旧哈希表</span></span><br><span class="line">        zfree(d-&gt;ht[<span class="number">0</span>].table);</span><br><span class="line">        d-&gt;ht[<span class="number">0</span>] = d-&gt;ht[<span class="number">1</span>];</span><br><span class="line">        _dictReset(&amp;d-&gt;ht[<span class="number">1</span>]);</span><br><span class="line">        d-&gt;rehashidx = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* More to rehash... */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在进行rehash的过程中，字典会同时在ht的两个table上进行查找、删除、更新操作，而新增只会在ht[1]上操作。</p><h3 id="哈希表扩展"><a href="#哈希表扩展" class="headerlink" title="哈希表扩展"></a>哈希表扩展</h3><p>redis提供了<code>dictExpand</code>函数来扩展哈希表的大小。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 哈希表扩展</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictExpand</span><span class="params">(dict *d, <span class="keyword">unsigned</span> <span class="keyword">long</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dictht n; <span class="comment">/* the new hash table */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> realsize = _dictNextPower(size); <span class="comment">// 计算哈希表的大小</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Allocate the new hash table and initialize all pointers to NULL */</span></span><br><span class="line">    n.size = realsize;</span><br><span class="line">    n.sizemask = realsize<span class="number">-1</span>;</span><br><span class="line">    n.table = zcalloc(realsize*<span class="keyword">sizeof</span>(dictEntry*));</span><br><span class="line">    n.used = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Is this the first initialization? If so it's not really a rehashing</span></span><br><span class="line"><span class="comment">     * we just set the first hash table so that it can accept keys. */</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].table == <span class="literal">NULL</span>) &#123; <span class="comment">// 如果哈希表ht[0]没有被初始化，则使用ht[0]</span></span><br><span class="line">        d-&gt;ht[<span class="number">0</span>] = n;</span><br><span class="line">        <span class="keyword">return</span> DICT_OK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Prepare a second hash table for incremental rehashing */</span></span><br><span class="line">    <span class="comment">// 否则，使用ht[1]用于rehash方式扩展</span></span><br><span class="line">    d-&gt;ht[<span class="number">1</span>] = n;</span><br><span class="line">    d-&gt;rehashidx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> DICT_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> _dictNextPower(<span class="keyword">unsigned</span> <span class="keyword">long</span> size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> i = DICT_HT_INITIAL_SIZE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size &gt;= LONG_MAX) <span class="keyword">return</span> LONG_MAX;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        i *= <span class="number">2</span>; <span class="comment">// 2的指数被增大</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将介绍redis字典的具体实现。&lt;br&gt;
    
    </summary>
    
      <category term="cache" scheme="http://simyy.cn/categories/cache/"/>
    
    
      <category term="redis" scheme="http://simyy.cn/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>redis 字符串</title>
    <link href="http://simyy.cn/2016/12/03/redis-sds/"/>
    <id>http://simyy.cn/2016/12/03/redis-sds/</id>
    <published>2016-12-03T04:24:54.000Z</published>
    <updated>2017-04-08T09:25:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>介绍和分析redis数据类型-sds。<br><a id="more"></a></p><h2 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h2><p>在<code>redis</code>中，字符串的基本结构如下，其中，<code>len</code>表示字符串的长度，<code>alloc</code>表示字符串的最大容量，<code>flags</code>表示header的类型。<br><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr8</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span> len; <span class="comment">/* 已占用buf长度 */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> alloc; <span class="comment">/* 申请的buf长度 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p><code>buf</code>表示需要存储的字符数组，数组的长度为len+1（由于需要存储一个结束符’\0’）。</p><p>具体结构如下，</p><p><img src="/images/redis-sds.png" alt=""></p><h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><p>除了上面提到的<code>sdshdr8</code>，还包含<code>sdshdr5、sdshdr16、sdshdr32、sdshdr64</code>。</p><p>在读取字符串时，首先需要获取当字符串的存储类型，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类型 - flags取值</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_5  0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_8  1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_16 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_32 3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_64 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用来获取字符串内容</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_MASK 7 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_BITS 3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_HDR_VAR(T,s) struct sdshdr##T *sh = (void*)((s)-(sizeof(struct sdshdr##T)));</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_HDR(T,s) ((struct sdshdr##T *)((s)-(sizeof(struct sdshdr##T))))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_5_LEN(f) ((f)&gt;&gt;SDS_TYPE_BITS)</span></span><br></pre></td></tr></table></figure></p><p>其中，<code>SDS_HDR</code>和<code>SDS_HDR_VAR</code>可以从sds字符串中获取header的起始位置。</p><h2 id="函数实现"><a href="#函数实现" class="headerlink" title="函数实现"></a>函数实现</h2><p>sds包含很多功能，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdsnewlen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *init, <span class="keyword">size_t</span> initlen)</span></span>;</span><br><span class="line"><span class="function">sds <span class="title">sdsnew</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *init)</span></span>;</span><br><span class="line"><span class="function">sds <span class="title">sdsempty</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function">sds <span class="title">sdsdup</span><span class="params">(<span class="keyword">const</span> sds s)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsfree</span><span class="params">(sds s)</span></span>;</span><br><span class="line"><span class="function">sds <span class="title">sdsgrowzero</span><span class="params">(sds s, <span class="keyword">size_t</span> len)</span></span>;</span><br><span class="line"><span class="function">sds <span class="title">sdscatlen</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">void</span> *t, <span class="keyword">size_t</span> len)</span></span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>这里只详细介绍下初始化和追加函数，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdsnewlen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *init, <span class="keyword">size_t</span> initlen)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *sh;</span><br><span class="line">    sds s;</span><br><span class="line">    <span class="keyword">char</span> type = sdsReqType(initlen); <span class="comment">// 通过初始化长度获取数据类型</span></span><br><span class="line">    <span class="comment">/* Empty strings are usually created in order to append. Use type 8</span></span><br><span class="line"><span class="comment">     * since type 5 is not good at this. */</span></span><br><span class="line">    <span class="keyword">if</span> (type == SDS_TYPE_5 &amp;&amp; initlen == <span class="number">0</span>) type = SDS_TYPE_8;</span><br><span class="line">    <span class="keyword">int</span> hdrlen = sdsHdrSize(type);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *fp; <span class="comment">/* flags pointer. */</span></span><br><span class="line"></span><br><span class="line">    sh = s_malloc(hdrlen+initlen+<span class="number">1</span>); <span class="comment">// 申请内存空间：header长度+buf长度+1</span></span><br><span class="line">    <span class="keyword">if</span> (!init)</span><br><span class="line">        <span class="built_in">memset</span>(sh, <span class="number">0</span>, hdrlen+initlen+<span class="number">1</span>); <span class="comment">// 全部设置为0</span></span><br><span class="line">    <span class="keyword">if</span> (sh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    s = (<span class="keyword">char</span>*)sh+hdrlen; <span class="comment">// 获取buf指针位置</span></span><br><span class="line">    fp = ((<span class="keyword">unsigned</span> <span class="keyword">char</span>*)s)<span class="number">-1</span>; <span class="comment">// 获取类型flag字段</span></span><br><span class="line">    <span class="keyword">switch</span>(type) &#123;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_5: &#123;</span><br><span class="line">            *fp = type | (initlen &lt;&lt; SDS_TYPE_BITS);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_8: &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">8</span>,s);</span><br><span class="line">            sh-&gt;len = initlen;</span><br><span class="line">            sh-&gt;alloc = initlen;</span><br><span class="line">            *fp = type;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (initlen &amp;&amp; init)</span><br><span class="line">        <span class="built_in">memcpy</span>(s, init, initlen); <span class="comment">// 拷贝数据</span></span><br><span class="line">    s[initlen] = <span class="string">'\0'</span>; <span class="comment">// buf最后一位置为'\0'</span></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>为sds增加可用空间，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdsMakeRoomFor</span><span class="params">(sds s, <span class="keyword">size_t</span> addlen)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *sh, *newsh;</span><br><span class="line">    <span class="keyword">size_t</span> avail = sdsavail(s);</span><br><span class="line">    <span class="keyword">size_t</span> len, newlen;</span><br><span class="line">    <span class="keyword">char</span> type, oldtype = s[<span class="number">-1</span>] &amp; SDS_TYPE_MASK; <span class="comment">// 获取数据类型</span></span><br><span class="line">    <span class="keyword">int</span> hdrlen;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Return ASAP if there is enough space left. */</span></span><br><span class="line">    <span class="keyword">if</span> (avail &gt;= addlen) <span class="keyword">return</span> s; <span class="comment">// 如果可用空间大于请求的长度，则不需要增加空间</span></span><br><span class="line"></span><br><span class="line">    len = sdslen(s);</span><br><span class="line">    sh = (<span class="keyword">char</span>*)s-sdsHdrSize(oldtype);</span><br><span class="line">    newlen = (len+addlen);</span><br><span class="line">    <span class="keyword">if</span> (newlen &lt; SDS_MAX_PREALLOC) <span class="comment">// 2倍的新长度</span></span><br><span class="line">        newlen *= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        newlen += SDS_MAX_PREALLOC;</span><br><span class="line"></span><br><span class="line">    type = sdsReqType(newlen);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Don't use type 5: the user is appending to the string and type 5 is</span></span><br><span class="line"><span class="comment">     * not able to remember empty space, so sdsMakeRoomFor() must be called</span></span><br><span class="line"><span class="comment">     * at every appending operation. */</span></span><br><span class="line">    <span class="keyword">if</span> (type == SDS_TYPE_5) type = SDS_TYPE_8;</span><br><span class="line"></span><br><span class="line">    hdrlen = sdsHdrSize(type);</span><br><span class="line">    <span class="keyword">if</span> (oldtype==type) &#123;</span><br><span class="line">        newsh = s_realloc(sh, hdrlen+newlen+<span class="number">1</span>);  <span class="comment">// 如果类型保持不变，则增加原有长度</span></span><br><span class="line">        <span class="keyword">if</span> (newsh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        s = (<span class="keyword">char</span>*)newsh+hdrlen;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Since the header size changes, need to move the string forward,</span></span><br><span class="line"><span class="comment">         * and can't use realloc */</span></span><br><span class="line">        newsh = s_malloc(hdrlen+newlen+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (newsh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">memcpy</span>((<span class="keyword">char</span>*)newsh+hdrlen, s, len+<span class="number">1</span>); <span class="comment">// 如果类型发生改变，则重新申请新类型数据，并拷贝buf数据</span></span><br><span class="line">        s_free(sh);</span><br><span class="line">        s = (<span class="keyword">char</span>*)newsh+hdrlen;</span><br><span class="line">        s[<span class="number">-1</span>] = type;</span><br><span class="line">        sdssetlen(s, len);</span><br><span class="line">    &#125;</span><br><span class="line">    sdssetalloc(s, newlen);</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="sds与普通string的区别"><a href="#sds与普通string的区别" class="headerlink" title="sds与普通string的区别"></a>sds与普通string的区别</h2><h3 id="获取字符串长度复杂度"><a href="#获取字符串长度复杂度" class="headerlink" title="获取字符串长度复杂度"></a>获取字符串长度复杂度</h3><p>string获取字符串长度的时间复杂度为O(N)，需要遍历整个字符串；而sds不再需要遍历字符串，通过len字段可以直接获取存储在buf内字符串的长度，时间复杂度为O(1)。</p><h3 id="空间分配和释放"><a href="#空间分配和释放" class="headerlink" title="空间分配和释放"></a>空间分配和释放</h3><p>对于C语言来说，每一次字符串长度的增加，都会造成一次内存分配的操作；每一次字符串长度的减少，都会造成一次内存释放操作。如果redis同样需要平凡的内存分配和释放，对性能会造成严重的影响。</p><p>sds通过alloc字段来记录预分配空间的大小，len字段来记录当前存储字符串的长度。当有资源需要释放时，sds只是减少len的大小；当需要增加空间时，只有当剩余的空位不足，才会重新申请新的空间，否则只需要增加len的大小。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍和分析redis数据类型-sds。&lt;br&gt;
    
    </summary>
    
      <category term="cache" scheme="http://simyy.cn/categories/cache/"/>
    
    
      <category term="redis" scheme="http://simyy.cn/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>tire tree算法</title>
    <link href="http://simyy.cn/2016/11/27/simWS-tire-tree/"/>
    <id>http://simyy.cn/2016/11/27/simWS-tire-tree/</id>
    <published>2016-11-27T08:39:58.000Z</published>
    <updated>2017-04-08T09:33:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>tire tree称为查找树或字典树，插入和查询的复杂度为O(K)（K为被插入或查询的关键字长度）。<br><a id="more"></a></p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>tire tree的基本性质如下，</p><ul><li>根节点不包含任何字符</li><li>除根节点外每一个节点都仅包含一个字符</li><li>树的每一条路径的所有节点连接起来代表一个被添加的字符串</li></ul><p><img src="/images/tire-tree-1.png" alt=""></p><p>tire tree的核心思想是空间换时间，并利用字符串的公共前缀来降低查询时间的开销以及节约存储空间。</p><p>如图所示，“故事”和“故乡”拥有共同的前缀“故”，所以“故”只需要存储一次，达到了节约存储空间的目的。</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="统计词频"><a href="#统计词频" class="headerlink" title="统计词频"></a>统计词频</h3><p>对于哈希和堆来说，tire tree的公共前缀可以有效降低内存空间，当需要统计的数据越多时，这个压缩的效果越明显。</p><h3 id="前缀匹配"><a href="#前缀匹配" class="headerlink" title="前缀匹配"></a>前缀匹配</h3><p>由于tire tree是按照前缀匹配来存储字符串的，那么查询字符串的复杂度只是O(K)，K为字符串的长度，因此，可以用来加载分词的词库。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>这里使用go来实现简单的tire树，完整代码：<a href="https://github.com/yxd123/simWS/blob/master/tire/tire.go。" target="_blank" rel="noopener">https://github.com/yxd123/simWS/blob/master/tire/tire.go。</a></p><h3 id="节点的定义"><a href="#节点的定义" class="headerlink" title="节点的定义"></a>节点的定义</h3><p>树的节点需要包含节点值、子节点指针、节点状态。</p><ul><li>节点值：当前节点存储的值</li><li>子节点指针：当前节点的子节点的指针（记录了当前节点的所有子节点）</li><li>节点状态：记录当前节点是否为代表字符串的结尾（用于判断以当前节点为结尾的字符串是否被添加过）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">type Node struct &#123;</span><br><span class="line">    value     byte //当前节点存储的值</span><br><span class="line">    nextNodes []*Node // 子节点指针</span><br><span class="line">    nextNums  int  //子节点个数</span><br><span class="line">    flag      bool //是否为结尾字符</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="节点的添加"><a href="#节点的添加" class="headerlink" title="节点的添加"></a>节点的添加</h3><p>节点的添加需要考虑几种情况：</p><ul><li>是否为公共前缀</li><li>是否为结尾字符</li></ul><p><code>values</code>代表需要添加的字符串，<code>place</code>代表当前需要处理的字符位置，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">func (t *Node) add(values []byte, place int) &#123;</span><br><span class="line">    // 达到字符串的末尾</span><br><span class="line">    if place &gt;= len(values) &#123;</span><br><span class="line">        t.flag = true</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   //如果没有子节点，需要添加新节点</span><br><span class="line">    if t.nextNodes == nil &#123;</span><br><span class="line">        log.Println(&quot;new nextNodes&quot;)</span><br><span class="line">        t.nextNodes = make([]*Node, 0, 26)</span><br><span class="line">        t.nextNums = 0</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if t.nextNums &gt; 0 &#123;</span><br><span class="line">        for _, node := range t.nextNodes &#123;</span><br><span class="line">            // 如果子节点中包含待添加字符，则递归添加下一节点</span><br><span class="line">            if node.value == values[place] &#123;</span><br><span class="line">                log.Println(&quot;duplicate byte:&quot;, string(node.value))</span><br><span class="line">                node.add(values, place + 1)</span><br><span class="line">                return</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 子节点无待添加字符，则添加新的子节点</span><br><span class="line">    node := NewNode(values[place])</span><br><span class="line">    node.add(values, place + 1)</span><br><span class="line">    t.nextNodes = append(t.nextNodes, node)</span><br><span class="line">    t.nextNums += 1</span><br><span class="line">    log.Println(&quot;add new Node:&quot;, string(node.value), t.nextNums)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="节点的查找"><a href="#节点的查找" class="headerlink" title="节点的查找"></a>节点的查找</h3><p>节点的查找和添加类似，都是从树的根节点开始，递归到目的节点。</p><p>节点的查找需要注意结尾标记。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">func (t *Node) find(values []byte, place int) bool &#123;</span><br><span class="line">    //如果没有子节点，则未查到</span><br><span class="line">    if t == nil || t.nextNums == 0 &#123;</span><br><span class="line">        log.Println(&quot;can&apos;t cmp&quot;, string(values[place]), &quot;nextNums:&quot;, string(t.value), t.nextNums)</span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for _, node := range t.nextNodes &#123;</span><br><span class="line">        log.Println(&quot;cmp:&quot;, string(node.value), string(values[place]))</span><br><span class="line">        // 找到待查找字符</span><br><span class="line">        if node.value == values[place] &#123;</span><br><span class="line">            //当前待查找字符为结尾，则找到目标字符串</span><br><span class="line">            if place == len(values) - 1 &#123;</span><br><span class="line">                return node.flag</span><br><span class="line">            &#125;</span><br><span class="line">            // 非结尾字符串，递归查找下一字符</span><br><span class="line">            return node.find(values, place + 1)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;tire tree称为查找树或字典树，插入和查询的复杂度为O(K)（K为被插入或查询的关键字长度）。&lt;br&gt;
    
    </summary>
    
      <category term="algorithm" scheme="http://simyy.cn/categories/algorithm/"/>
    
    
      <category term="algorithm" scheme="http://simyy.cn/tags/algorithm/"/>
    
      <category term="中文分词" scheme="http://simyy.cn/tags/%E4%B8%AD%E6%96%87%E5%88%86%E8%AF%8D/"/>
    
  </entry>
  
  <entry>
    <title>编译原理（二）语法分析</title>
    <link href="http://simyy.cn/2016/11/14/compiling-2/"/>
    <id>http://simyy.cn/2016/11/14/compiling-2/</id>
    <published>2016-11-14T14:36:09.000Z</published>
    <updated>2017-04-08T09:35:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>语法分析是编译过程的一个逻辑阶段。语法分析的任务是在词法分析的基础上将单词序列组合成各类语法短语。<br><a id="more"></a></p><h2 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h2><p>目前语法分析常用的两类方法：</p><ul><li>自顶向下</li><li>自底向上</li></ul><p>本文采用自顶向下的分析方法。</p><h2 id="分析原理"><a href="#分析原理" class="headerlink" title="分析原理"></a>分析原理</h2><p>分析的目标是构造一个计算机可以识别的模型，在这里，使用语法树作为计算器的识别结构。 </p><p><img src="/images/compiling-2-1.jpeg" alt="图片1"></p><p>其中，节点的结构如上一篇文章中的定义（包含优先级、类型）。</p><h3 id="操作符定义"><a href="#操作符定义" class="headerlink" title="操作符定义"></a>操作符定义</h3><p>首先，需要定义所有操作符对应的方法(这里仅提供加、减、乘、除四中运算法方法)，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Opt(object):</span><br><span class="line">    @staticmethod</span><br><span class="line">    def add(self, children):</span><br><span class="line">        return children[0].value + children[1].value</span><br><span class="line"></span><br><span class="line">    @staticmethod</span><br><span class="line">    def sub(self, children):</span><br><span class="line">        return children[0].value - children[1].value</span><br><span class="line"></span><br><span class="line">    @staticmethod</span><br><span class="line">    def mux(self, children):</span><br><span class="line">        return children[0].value * children[1].value</span><br><span class="line"></span><br><span class="line">    @staticmethod</span><br><span class="line">    def div(self, children):</span><br><span class="line">        return children[0].value / children[1].value</span><br></pre></td></tr></table></figure><p>在构建语法树的时候，需要把操作符作为根节点来处理，其中加法操作对应的语法树如下,</p><p><img src="/images/compiling-2-2.jpeg" alt="图片2"></p><h3 id="节点定义与计算"><a href="#节点定义与计算" class="headerlink" title="节点定义与计算"></a>节点定义与计算</h3><p>语法树的节点可以是操作符，也可以是具体的值。但需要注意，所有的值应该是叶子节点，而操作符不可能为叶子节点。</p><p>节点定义包含：节点名称、节点优先级、节点类型、当前节点值以及子节点。</p><p>需要注意的是<code>在计算当前节点的值时是需要递归计算子树下所有节点的结果的</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">class ASTNode(object):</span><br><span class="line">    def __init__(self, token):</span><br><span class="line">        self.token = token</span><br><span class="line">        self.children = list()</span><br><span class="line"> </span><br><span class="line">    @property</span><br><span class="line">    def token_name(self):</span><br><span class="line">        return self.token.name</span><br><span class="line"></span><br><span class="line">    @property</span><br><span class="line">    def priority(self):</span><br><span class="line">        return self.token.priority</span><br><span class="line"></span><br><span class="line">    @property</span><br><span class="line">    def is_opt(self):</span><br><span class="line">        return self.token.type == TOKENTYPE.OPT</span><br><span class="line"></span><br><span class="line">    @property</span><br><span class="line">    def is_scp(self):</span><br><span class="line">        return self.token.type == TOKENTYPE.SCP</span><br><span class="line"></span><br><span class="line">    def add_child(self, child):</span><br><span class="line">        self.children.append(child)</span><br><span class="line"></span><br><span class="line">    def pop_child(self):</span><br><span class="line">        return self.children.pop()</span><br><span class="line"></span><br><span class="line">    @property</span><br><span class="line">    def value(self):</span><br><span class="line">        if self.is_opt:</span><br><span class="line">            return calcuate(self) # 递归计算得到该操作符的操作结果</span><br><span class="line">        else:</span><br><span class="line">            return self.token.value</span><br><span class="line"></span><br><span class="line">    def __str__(self):</span><br><span class="line">        if not self.is_opt:</span><br><span class="line">            return &apos;(leaf [%s])&apos; % self.token.value</span><br><span class="line">        else:</span><br><span class="line">            return &apos;(%s %s, %s)&apos; % (self.token_name, str(self.children[0]), </span><br><span class="line">                                    str(self.children[1]))</span><br><span class="line">    __repr__ =  __str__</span><br></pre></td></tr></table></figure><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>构造语法树可以使用递归的方式来处理，具体的思想如下：</p><ol start="0"><li>从左侧出发，遍历代码片段</li><li>判断操作符类型：值、操作符、停止符（括号）</li><li>比较当前操作符和上一次操作符的优先级，调整语法树结构：优先级小于等于上一次操作符，则把当前操作符作为根节点，原有语法树作为左子树，剩余代码片段作为待处理的右子树；优先级大于上一次操作符，则当前操作符替换上一次值的位置，上一次值作为当前操作符的做节点，剩余代码片段作为待处理的右子树。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">def parse(tokens, stop_name=None):</span><br><span class="line">    last_opt = None</span><br><span class="line">    for token in tokens:</span><br><span class="line">        if stop_name and token.name == stop_name:</span><br><span class="line">            return last_opt</span><br><span class="line">        node = ASTNode(token)</span><br><span class="line">        if node.is_opt:</span><br><span class="line">            next_node = ASTNode(tokens.next())</span><br><span class="line">            if next_node.is_scp:</span><br><span class="line">                next_node = parse(tokens, </span><br><span class="line">                    stop_name=TOKEN_SCP_MATCH.get(next_node.token_name))</span><br><span class="line">            if node.priority &lt;= last_opt.priority:</span><br><span class="line">                node.add_child(last_opt)</span><br><span class="line">                node.add_child(next_node)</span><br><span class="line">                last_opt = node</span><br><span class="line">            else:</span><br><span class="line">                node.add_child(last_opt.pop_child())</span><br><span class="line">                node.add_child(next_node)</span><br><span class="line">                last_opt.add_child(node)</span><br><span class="line">        else:</span><br><span class="line">            last_opt = node</span><br><span class="line">        print last_opt</span><br><span class="line">    return last_opt</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;语法分析是编译过程的一个逻辑阶段。语法分析的任务是在词法分析的基础上将单词序列组合成各类语法短语。&lt;br&gt;
    
    </summary>
    
      <category term="cs" scheme="http://simyy.cn/categories/cs/"/>
    
    
      <category term="编译原理" scheme="http://simyy.cn/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>编译原理（一）词法分析</title>
    <link href="http://simyy.cn/2016/10/30/compiling-1/"/>
    <id>http://simyy.cn/2016/10/30/compiling-1/</id>
    <published>2016-10-30T04:06:20.000Z</published>
    <updated>2017-04-12T14:42:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>词法分析（Lexical analysis）是完成编译程序的第一个阶段的工作。<br><a id="more"></a><br>词法分析是从左到右一个字符一个字符地读入源程序，即对构成源程序的字符流进行扫描然后根据构词规则识别单词(也称单词符号或符号)。词法分析程序实现这个任务。词法分析程序可以使用lex等工具自动生成。</p><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><p>词法分析主要任务就是需要把由代码组成的字符串来识别出来，生成可以被识别的关键字序列。</p><p><img src="/images/compoling-1.jpeg" alt="图片1"></p><p>本文只实现了5种关键字类型，其中<code>IGN</code>是可悲忽略的字符，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 关键字类型</span><br><span class="line">class TOKENTYPE(object):</span><br><span class="line">    IGN = 0 # ignore</span><br><span class="line">    OPT = 1 # oprate</span><br><span class="line">    SCP = 1 # reserved</span><br><span class="line">    INT = 2 # int</span><br><span class="line">    STR = 3 # string</span><br></pre></td></tr></table></figure></p><p>对于不同的关键字需要对应的正则表达式来匹配该数据，并且需要预设关键字的优先级，例如，乘号的优先级高于加号，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 关键字定义</span><br><span class="line">class TokenRegex(object):</span><br><span class="line">    def __init__(self, regex, name,type=TOKENTYPE.OPT, priority=1):</span><br><span class="line">        self.regex = regex</span><br><span class="line">        self.name = name</span><br><span class="line">        self.type = type</span><br><span class="line">        self.priority = priority</span><br><span class="line">        self.value = None</span><br></pre></td></tr></table></figure></p><p>关键字定义如下，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">_TokenRegexs = (</span><br><span class="line">    TokenRegex(r&apos;\=&apos;, &apos;eq&apos;),</span><br><span class="line">    TokenRegex(r&apos;\+&apos;, &apos;add&apos;),</span><br><span class="line">    TokenRegex(r&apos;\-&apos;, &apos;sub&apos;),</span><br><span class="line">    TokenRegex(r&apos;\*&apos;, &apos;mux&apos;, priority=2),</span><br><span class="line">    TokenRegex(r&apos;\/&apos;, &apos;div&apos;, priority=2),</span><br><span class="line">    TokenRegex(r&apos;\(&apos;, &apos;(&apos;, type=TOKENTYPE.SCP, priority=3),</span><br><span class="line">    TokenRegex(r&apos;\)&apos;, &apos;)&apos;, type=TOKENTYPE.SCP, priority=3),</span><br><span class="line">    TokenRegex(r&apos;\&#123;&apos;, &apos;&#123;&apos;, type=TOKENTYPE.SCP, priority=3),</span><br><span class="line">    TokenRegex(r&apos;\&#125;&apos;, &apos;&#125;&apos;, type=TOKENTYPE.SCP, priority=3),</span><br><span class="line">    TokenRegex(r&apos;if&apos;, &apos;_if&apos;),</span><br><span class="line">    TokenRegex(r&apos;else&apos;, &apos;_else&apos;),</span><br><span class="line">    TokenRegex(r&apos;;&apos;, &apos;end&apos;),</span><br><span class="line">    TokenRegex(r&apos;[0-9]+&apos;, &apos;int&apos;,  type=TOKENTYPE.INT),</span><br><span class="line">    TokenRegex(r&apos;[a-zA-Z][a-zA-Z0-9_]*&apos;, &apos;str&apos;, type=TOKENTYPE.STR),</span><br><span class="line">    TokenRegex(r&apos;\n&apos;, &apos;enter&apos;, type=TOKENTYPE.IGN),</span><br><span class="line">    TokenRegex(r&apos; &apos;, &apos;blank&apos;, type=TOKENTYPE.IGN),</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>此外，还需要定义特殊关键子匹配规则，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TOKEN_SCP_MATCH = &#123;</span><br><span class="line">    &apos;(&apos;:  &apos;)&apos;,</span><br><span class="line">    &apos;&#123;&apos;:  &apos;&#125;&apos;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>递归遍历输入字符，生成对应的关键字链表，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">def lex(characters):</span><br><span class="line">    pos = 0 </span><br><span class="line">    length = len(characters)</span><br><span class="line">    while pos &lt; length:</span><br><span class="line">        for token_regex in _TokenRegexs:</span><br><span class="line">            regex = re.compile(token_regex.regex)</span><br><span class="line">            r = regex.match(characters, pos)</span><br><span class="line">            if r:</span><br><span class="line">                if token_regex.type is not TOKENTYPE.IGN:</span><br><span class="line">                    yield Token(r.group(0), token_regex)</span><br><span class="line">                pos = r.end(0)</span><br><span class="line">                break</span><br><span class="line">        else:</span><br><span class="line">            print &apos;char:&apos;, characters[pos]</span><br><span class="line">            sys.stderr.write(&apos;Illgal character: %s\n&apos; % characters[pos])</span><br><span class="line">            sys.exit(1)</span><br></pre></td></tr></table></figure></p><h3 id="关键字识别"><a href="#关键字识别" class="headerlink" title="关键字识别"></a>关键字识别</h3><p>关键字识别单元，用来存储每一个关键字的信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Token(object):</span><br><span class="line">    def __init__(self, value, token_regex):</span><br><span class="line">        self.value = int(value) if value.isdigit() else value</span><br><span class="line">        self.name = token_regex.name</span><br><span class="line">        self.type = token_regex.type</span><br><span class="line">        self.priority = token_regex.priority</span><br><span class="line"></span><br><span class="line">    def __repr__(self):</span><br><span class="line">        return &apos;&lt;Token(\&apos;%s\&apos;) %s %s&gt;&apos; % (self.name, self.value, self.priority)</span><br><span class="line"></span><br><span class="line">    def is_end(self):</span><br><span class="line">        return True if self.name == &apos;end&apos; else False</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;词法分析（Lexical analysis）是完成编译程序的第一个阶段的工作。&lt;br&gt;
    
    </summary>
    
      <category term="cs" scheme="http://simyy.cn/categories/cs/"/>
    
    
      <category term="编译原理" scheme="http://simyy.cn/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>SimHash算法</title>
    <link href="http://simyy.cn/2016/10/27/simhash/"/>
    <id>http://simyy.cn/2016/10/27/simhash/</id>
    <published>2016-10-26T17:30:43.000Z</published>
    <updated>2017-04-08T09:33:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>Google采用这种算法来解决万亿级别的网页的去重任务。<br><a id="more"></a></p><p>由于实验室和互联网基本没啥关系，也就从来没有关注过数据挖掘相关的东西。在实际工作中，第一次接触到匹配和聚类等工作，虽然用一些简单的匹配算法可以做小数据的聚类，但数据量达到一定的时候就束手无策了。</p><p>所以，趁着周末把这方面的东西看了看，做个笔记。</p><h2 id="来历"><a href="#来历" class="headerlink" title="来历"></a>来历</h2><p>google的论文“detecting near-duplicates for web crawling”——–simhash。</p><h2 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h2><p>simhash算法的主要思想是降维，将高维的特征向量映射成一个低维的特征向量，通过两个向量的Hamming Distance来确定文章是否重复或者高度近似。</p><p>算法步骤：　　</p><ol><li>对于给定的一段语句，进行分词，得到有效的特征向量</li><li>为每一个特征向量设置一个权值</li><li>对每一个特征向量计算hash值，为01组成的n-bit签名</li><li>所有特征向量进行加权（1则为正，0则为负），然后累加</li><li>对于n-bit签名的累加结果，如果&gt;0置1，否则置0</li><li>得到该语句的simhash值</li><li>根据不同语句simhash的海明距离就来判断相似程度<br>　　<br>具体如图，<br><img src="/images/simhash.png" alt="simhash"></li></ol><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>simhash用于比较大文本，比如500字以上效果都还蛮好，距离小于3的基本都是相似，误判率也比较低。</p><p>这样的话，小文本呢？如何解决？</p><p><a href="http://blog.163.com/cindy_19810217/blog/static/20105911820104279560289/" target="_blank" rel="noopener">该博客</a>给出一个思路是，将短文本抽象出有序关键字，计算此有序字串的simhash值，寻找simhash相等的集合，缩小的搜索范围。还提到了并查集和bloom filter。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.lanceyan.com/tech/arch/simhash_hamming_distance_similarity.html" target="_blank" rel="noopener">http://www.lanceyan.com/tech/arch/simhash_hamming_distance_similarity.html</a><br><a href="http://www.cnblogs.com/zhengyun_ustc/archive/2012/06/12/sim.html" target="_blank" rel="noopener">http://www.cnblogs.com/zhengyun_ustc/archive/2012/06/12/sim.html</a><br><a href="http://blog.jobbole.com/21928/" target="_blank" rel="noopener">http://blog.jobbole.com/21928/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Google采用这种算法来解决万亿级别的网页的去重任务。&lt;br&gt;
    
    </summary>
    
      <category term="algorithm" scheme="http://simyy.cn/categories/algorithm/"/>
    
    
      <category term="algorithm" scheme="http://simyy.cn/tags/algorithm/"/>
    
  </entry>
  
</feed>
